#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import os
import signal
import atexit

import sqlite3
import requests
import logging
import random
import threading
import json
import shutil
import zipfile
import re
import time
import html
import asyncio
import pytz
import gzip
import hashlib
from pathlib import Path
from aiogram.filters import StateFilter  
from datetime import datetime, timedelta
from typing import Set, List, Dict, Optional, Tuple, Any
from collections import defaultdict

try:
    import asyncio
except ImportError as e:
    print(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªÙŠØ±Ø§Ø¯ asyncio: {e}")
    sys.exit(1)

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
try:
    from advanced_systems import (  # type: ignore
        show_button_position_editor,
        show_schedules_manager,
        show_schedule_edit_menu,
        QuranAudioSystem,
        SURAHS_NAMES
    )
    ADVANCED_SYSTEMS_LOADED = True
    print("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­")
except ImportError as e:
    ADVANCED_SYSTEMS_LOADED = False
    print(f"ØªØ­Ø°ÙŠØ±: Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©: {e}")

from aiogram import Bot, Dispatcher, types, F, Router
from aiogram.client.bot import DefaultBotProperties
from aiogram.exceptions import TelegramForbiddenError, TelegramBadRequest, TelegramUnauthorizedError, TelegramNotFound
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton

# Global references for scheduler
bot = None
main_loop = None

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger

# ==========================================
# Configuration & Permanent DB Setup
# ==========================================
# API_TOKEN = "8591447168:AAESdoEQBMfLzfBfuKrbCHPB8Bu8SMA3sDU"
API_TOKEN = "8591447168:AAGLE35E6J3OtGXe5JGI2amOT_ZGs_4ZGhw" # Ø¶Ø¹ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ù†Ø§"
ADMIN_ID = 6579451811

# Ù‚Ù†Ø§Ø©/Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ (Ø¶Ø¹ None Ø¥Ø°Ø§ Ù„Ù… ØªØ±Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§)
REQUIRED_CHANNEL = None  # Ù…Ø«Ø§Ù„: "@channel_name" Ø£Ùˆ "-1001234567890"

# Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ±Ù‡Ø§ Ø­Ø³Ø¨ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³ÙŠØ±ÙØ±)
DEFAULT_TIMEZONE = "Asia/Riyadh"

# Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø·Ù„Ù‚ Ù„Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
DB_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "bot_data")
DB_NAME = os.path.join(DB_DIR, "islamic_bot_permanent.db")
BACKUP_DIR = os.path.join(DB_DIR, "backups")
LOGS_DIR = os.path.join(DB_DIR, "logs")

os.makedirs(DB_DIR, exist_ok=True)
os.makedirs(BACKUP_DIR, exist_ok=True)
os.makedirs(LOGS_DIR, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(LOGS_DIR, f"bot_{datetime.now().strftime('%Y%m%d')}.log"), encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)
router = Router()

# ==========================================
# Auto-Save & Shutdown Protection System
# ==========================================
class AutoSaveSystem:
    """Ù†Ø¸Ø§Ù… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙˆØ­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù"""
    
    def __init__(self, db_name: str, backup_dir: str):
        self.db_name = db_name
        self.backup_dir = backup_dir
        self.is_shutting_down = False
        self.last_save = datetime.now()
        self.save_interval = 300  # Ø­ÙØ¸ ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        
    def create_emergency_backup(self) -> bool:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø·Ø§Ø±Ø¦Ø©"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_file = os.path.join(self.backup_dir, f"emergency_backup_{timestamp}.db")
            
            if os.path.exists(self.db_name):
                shutil.copy2(self.db_name, backup_file)
                logger.info(f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø·Ø§Ø±Ø¦Ø©: {backup_file}")
                return True
            return False
        except Exception as e:
            logger.error(f"âŒ ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø·Ø§Ø±Ø¦Ø©: {e}")
            return False
    
    def save_state(self) -> bool:
        """Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
        try:
            # Ø­ÙØ¸ ÙÙŠ Ù…Ù„Ù JSON
            state_file = os.path.join(self.backup_dir, "last_state.json")
            state_data = {
                'last_save': datetime.now().isoformat(),
                'status': 'running',
                'db_size': os.path.getsize(self.db_name) if os.path.exists(self.db_name) else 0
            }
            
            with open(state_file, 'w', encoding='utf-8') as f:
                json.dump(state_data, f, ensure_ascii=False, indent=2)
            
            self.last_save = datetime.now()
            return True
        except Exception as e:
            logger.error(f"âŒ ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø©: {e}")
            return False
    
    def graceful_shutdown(self):
        """Ø¥ØºÙ„Ø§Ù‚ Ø¢Ù…Ù† Ù…Ø¹ Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        if self.is_shutting_down:
            return
        
        self.is_shutting_down = True
        logger.info("\n" + "="*60)
        logger.info("ğŸ›‘ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¢Ù…Ù†...")
        logger.info("="*60)
        
        try:
            # 1. Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø·Ø§Ø±Ø¦Ø©
            logger.info("ğŸ“¦ 1/3 Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø·Ø§Ø±Ø¦Ø©...")
            self.create_emergency_backup()
            
            # 2. Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø©
            logger.info("ğŸ’¾ 2/3 Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª...")
            self.save_state()
            
            # 3. Ø¥ØºÙ„Ø§Ù‚ Ø¬Ù…ÙŠØ¹ Ø§ØªØµØ§Ù„Ø§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            logger.info("ğŸ”’ 3/3 Ø¥ØºÙ„Ø§Ù‚ Ø§ØªØµØ§Ù„Ø§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
            try:
                conn = sqlite3.connect(self.db_name)
                conn.execute("PRAGMA optimize")
                conn.execute("PRAGMA wal_checkpoint(TRUNCATE)")
                conn.close()
            except:
                pass
            
            logger.info("="*60)
            logger.info("âœ… ØªÙ… Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¢Ù…Ù† Ø¨Ù†Ø¬Ø§Ø­ - Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©")
            logger.info("="*60 + "\n")
            
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¢Ù…Ù†: {e}")

# Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
auto_save = AutoSaveSystem(DB_NAME, BACKUP_DIR)

# Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ù„Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¢Ù…Ù†
def signal_handler(signum, frame):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… (Ctrl+C, Kill, etc)"""
    logger.info(f"\nâš ï¸ ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø¥Ø´Ø§Ø±Ø© Ø¥ÙŠÙ‚Ø§Ù: {signum}")
    auto_save.graceful_shutdown()
    sys.exit(0)

# ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
signal.signal(signal.SIGINT, signal_handler)   # Ctrl+C
signal.signal(signal.SIGTERM, signal_handler)  # Kill command

if hasattr(signal, 'SIGBREAK'):  # Windows
    signal.signal(signal.SIGBREAK, signal_handler)

# ØªØ³Ø¬ÙŠÙ„ Ø¯Ø§Ù„Ø© ØªÙ†ÙØ° Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨Ø£ÙŠ Ø·Ø±ÙŠÙ‚Ø©
atexit.register(auto_save.graceful_shutdown)

# ==========================================
# Data Protection System - Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
# ==========================================
class DataProtectionSystem:
    """Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ù…ØªØ·ÙˆØ± Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ"""
    def __init__(self, db_path=DB_NAME, backup_dir=BACKUP_DIR):
        self.db_path = db_path
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        for subdir in ["daily", "weekly", "monthly", "auto", "manual"]:
            (self.backup_dir / subdir).mkdir(exist_ok=True)
    
    def check_integrity(self):
        """ÙØ­Øµ Ø³Ù„Ø§Ù…Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("PRAGMA integrity_check")
            result = cursor.fetchone()[0]
            conn.close()
            return result == "ok"
        except:
            return False
    
    def create_backup(self, backup_type="auto", compress=True):
        """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ø¶ØºÙˆØ·Ø©"""
        if not os.path.exists(self.db_path):
            return False, None, "Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©"
        
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_folder = self.backup_dir / backup_type
            
            if compress:
                backup_file = backup_folder / f"backup_{timestamp}.db.gz"
                with open(self.db_path, 'rb') as f_in:
                    with gzip.open(backup_file, 'wb') as f_out:
                        shutil.copyfileobj(f_in, f_out)
            else:
                backup_file = backup_folder / f"backup_{timestamp}.db"
                shutil.copy2(self.db_path, backup_file)
            
            size_mb = round(os.path.getsize(backup_file) / (1024*1024), 2)
            logger.info(f"âœ… Backup created: {backup_file} ({size_mb} MB)")
            return True, str(backup_file), f"ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© ({size_mb} MB)"
        except Exception as e:
            logger.error(f"âŒ Backup failed: {e}")
            return False, None, str(e)
    
    def list_backups(self, backup_type=None):
        """Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©"""
        backups = []
        folders = [backup_type] if backup_type else ["daily", "weekly", "monthly", "auto", "manual"]
        
        for folder in folders:
            backup_folder = self.backup_dir / folder
            if not backup_folder.exists():
                continue
            
            for backup_file in sorted(backup_folder.glob("backup_*.db*"), reverse=True):
                size_mb = round(os.path.getsize(backup_file) / (1024*1024), 2)
                backups.append({
                    "file": backup_file.name,
                    "path": str(backup_file),
                    "type": folder,
                    "size_mb": size_mb,
                    "date": datetime.fromtimestamp(backup_file.stat().st_mtime)
                })
        return backups
    
    def restore_backup(self, backup_path):
        """Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©"""
        if not os.path.exists(backup_path):
            return False, "Ø§Ù„Ù†Ø³Ø®Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©"
        
        try:
            # Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ù† Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            self.create_backup("auto", compress=True)
            
            # Ø§Ø³ØªØ¹Ø§Ø¯Ø©
            if backup_path.endswith('.gz'):
                with gzip.open(backup_path, 'rb') as f_in:
                    with open(self.db_path, 'wb') as f_out:
                        shutil.copyfileobj(f_in, f_out)
            else:
                shutil.copy2(backup_path, self.db_path)
            
            if not self.check_integrity():
                return False, "Ø§Ù„Ù†Ø³Ø®Ø© ØªØ§Ù„ÙØ©"
            
            logger.info(f"âœ… Restored from: {backup_path}")
            return True, "ØªÙ…Øª Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­"
        except Exception as e:
            logger.error(f"âŒ Restore failed: {e}")
            return False, str(e)

# Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¹Ø§Ù…
data_protection = DataProtectionSystem()

# ==========================================
# Ultimate Anti-Duplicate System (Strict)
# ==========================================
class UltimateAntiDuplicate:
    def __init__(self, max_size: int = 10000):
        self.recent_quran: Set[str] = set()
        self.recent_hadith: Set[str] = set()
        self.recent_azkar: Set[str] = set()
        self.recent_images: Set[str] = set()
        self.recent_audio: Set[str] = set()
        self.max_size = max_size
        
        self.quran_list: List[str] = []
        self.hadith_list: List[str] = []
        self.azkar_list: List[str] = []
        self.images_list: List[str] = []
        self.audio_list: List[str] = []
        self._lock = threading.Lock()
    
    def add_quran(self, surah: int, ayah: int) -> bool:
        key = f"{surah}:{ayah}"
        with self._lock:
            if key in self.recent_quran:
                return False
            if len(self.quran_list) >= self.max_size:
                old = self.quran_list.pop(0)
                self.recent_quran.discard(old)
            self.quran_list.append(key)
            self.recent_quran.add(key)
            return True
    
    def is_duplicate_quran(self, surah: int, ayah: int) -> bool:
        return f"{surah}:{ayah}" in self.recent_quran
    
    def clear_quran(self):
        with self._lock:
            self.recent_quran.clear()
            self.quran_list.clear()

anti_dup = UltimateAntiDuplicate(max_size=10000)

# ==========================================
# FSM States (Complete System)
# ==========================================
class Form(StatesGroup):
    #_broadcast
    bc_target = State()
    bc_content = State()
    bc_test = State()
    
    #buttons
    btn_system_edit = State()
    btn_system_edit_name = State()
    btn_system_edit_order = State()
    btn_system_edit_icon = State()
    btn_edit_value = State()  # Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‚ÙŠÙ… Ø§Ù„Ø£Ø²Ø±Ø§Ø± (Ø§Ù„Ø§Ø³Ù…ØŒ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©ØŒ Ø§Ù„ØªØ±ØªÙŠØ¨)
    
    #scheduling - Advanced System
    sch_select_type = State()
    sch_once_date = State()  # ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©
    sch_start_date = State()
    sch_time = State()
    sch_duration = State()
    sch_days_week = State()
    sch_target = State()
    sch_content = State()
    sch_preview = State()  # Ø¬Ø¯ÙŠØ¯: Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
    sch_confirm = State()  # Ø¬Ø¯ÙŠØ¯: Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯
    sch_edit_time = State()
    sch_edit_value = State()  # Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‚ÙŠÙ… Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
    
    #search - Enhanced Navigation
    search_quran = State()
    search_quran_nav = State()
    search_quran_tafsir = State()
    
    # Quran Audio Manager (New) - Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„
    quran_reciter_name = State()
    quran_add_audio = State()  # State to receive audio files
    quran_rename = State()
    quran_add_reciter_name = State()  # Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    quran_add_reciter_info = State()  # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø±Ø¦
    quran_select_reciter = State()  # Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø§Ø±Ø¦
    quran_select_surah = State()  # Ø§Ø®ØªÙŠØ§Ø± Ø³ÙˆØ±Ø©
    quran_upload_audio = State()  # Ø±ÙØ¹ Ù…Ù„Ù ØµÙˆØªÙŠ
    quran_edit_reciter = State()  # ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø§Ø±Ø¦
    quran_delete_confirm = State()  # ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù
    
    #custom button
    custom_btn_add_text = State()
    custom_btn_add_file = State()
    custom_btn_add_confirm = State()
    custom_btn_del_select = State()
    custom_btn_view = State()
    
    #azkar data
    data_add_type = State()
    data_add_category = State()
    data_add_text = State()
    data_add_file = State()
    data_add_reference = State()
    data_add_count = State()
    data_delete_select = State()
    data_view_select = State()
    
    #khatma
    khatma_pages = State()
    khatma_calc_pages = State()  # Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©
    khatma_30_start = State()     # Ø®ØªÙ…Ø© 30 ÙŠÙˆÙ…
    
    #tafseer
    tafseer_search = State()  # Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙØ³ÙŠØ±
    
    #admin management  
    add_admin_id = State()  # Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù
    
    #welcome message
    welcome_edit = State()
    
    #contact reply
    contact_msg = State()  # Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙˆØ§ØµÙ„
    contact_reply = State()
    contact_block = State()
    contact_reply_text = State()
    
    #admin management
    add_admin = State()
    remove_admin = State()
    
    #subscription check
    subscription_check = State()
    
    #delete message
    delete_msg_select = State()
    delete_msg_single = State()
    
    #block management
    block_management = State()
    block_user_id = State()
    block_reason = State()
    unblock_user_select = State()
    
    #tasbih
    tasbih_counter = State()
    tasbih_type_select = State()
    tasbih_free_select = State()
    
    # alarm content management
    alarm_content_add_type = State()
    alarm_content_add_text = State()
    alarm_content_add_file = State()
    
    # alarm link management
    alarm_link_input = State()

# ==========================================
# Alarms Content Library (Standard)
# ==========================================
ALARMS_CONTENT = {
    "salawat_ibrahim": {
        "title": "Ø§Ù„ØµÙ„Ø§Ø© Ø§Ù„Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…ÙŠØ©",
        "type": "text",
        "data": [
            "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ Ø¹Ù„Ù‰ Ù…Ø­Ù…Ø¯ ÙˆØ¹Ù„Ù‰ Ø¢Ù„ Ù…Ø­Ù…Ø¯ ÙƒÙ…Ø§ ØµÙ„ÙŠØª Ø¹Ù„Ù‰ Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ… ÙˆØ¹Ù„Ù‰ Ø¢Ù„ Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ… Ø¥Ù†Ùƒ Ø­Ù…ÙŠØ¯ Ù…Ø¬ÙŠØ¯ØŒ Ø§Ù„Ù„Ù‡Ù… Ø¨Ø§Ø±Ùƒ Ø¹Ù„Ù‰ Ù…Ø­Ù…Ø¯ ÙˆØ¹Ù„Ù‰ Ø¢Ù„ Ù…Ø­Ù…Ø¯ ÙƒÙ…Ø§ Ø¨Ø§Ø±ÙƒØª Ø¹Ù„Ù‰ Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ… ÙˆØ¹Ù„Ù‰ Ø¢Ù„ Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ… Ø¥Ù†Ùƒ Ø­Ù…ÙŠØ¯ Ù…Ø¬ÙŠØ¯.",
            "Ø§Ù„Ù„Ù‘ÙÙ‡ÙÙ…Ù‘Ù ØµÙÙ„Ù‘Ù Ø¹ÙÙ„ÙÙ‰ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù ÙˆÙØ£ÙØ²Ù’ÙˆÙØ§Ø¬ÙÙ‡Ù ÙˆÙØ°ÙØ±Ù‘ÙÙŠÙ‘ÙØªÙÙ‡ÙØŒ ÙƒÙÙ…ÙØ§ ØµÙÙ„Ù‘ÙÙŠÙ’ØªÙ Ø¹ÙÙ„ÙÙ‰ Ø¢Ù„Ù Ø¥ÙØ¨Ù’Ø±ÙØ§Ù‡ÙÙŠÙ…ÙØŒ ÙˆÙØ¨ÙØ§Ø±ÙÙƒÙ’ Ø¹ÙÙ„ÙÙ‰ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù ÙˆÙØ£ÙØ²Ù’ÙˆÙØ§Ø¬ÙÙ‡Ù ÙˆÙØ°ÙØ±Ù‘ÙÙŠÙ‘ÙØªÙÙ‡ÙØŒ ÙƒÙÙ…ÙØ§ Ø¨ÙØ§Ø±ÙÙƒÙ’ØªÙ Ø¹ÙÙ„ÙÙ‰ Ø¢Ù„Ù Ø¥ÙØ¨Ù’Ø±ÙØ§Ù‡ÙÙŠÙ…ÙØŒ Ø¥ÙÙ†Ù‘ÙÙƒÙ Ø­ÙÙ…ÙÙŠØ¯ÙŒ Ù…ÙØ¬ÙÙŠØ¯ÙŒ."
        ]
    },
    "salawat_text": {
        "title": "ØµÙŠØº Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ (Ù†Øµ)",
        "type": "text",
        "data": [
            "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ ÙˆØ³Ù„Ù… Ø¹Ù„Ù‰ Ù†Ø¨ÙŠÙ†Ø§ Ù…Ø­Ù…Ø¯",
            "ØµÙ„Ù‰ Ø§Ù„Ù„Ù‡ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù…",
            "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ Ø¹Ù„Ù‰ Ø³ÙŠØ¯Ù†Ø§ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø© ØªØ­Ù„ Ø¨Ù‡Ø§ Ø§Ù„Ø¹Ù‚Ø¯ ÙˆØªÙ†ÙØ±Ø¬ Ø¨Ù‡Ø§ Ø§Ù„ÙƒØ±Ø¨",
            "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ ÙˆØ³Ù„Ù… ÙˆØ¨Ø§Ø±Ùƒ Ø¹Ù„Ù‰ Ø³ÙŠØ¯Ù†Ø§ Ù…Ø­Ù…Ø¯ ÙˆØ¹Ù„Ù‰ Ø¢Ù„Ù‡ ÙˆØµØ­Ø¨Ù‡ Ø£Ø¬Ù…Ø¹ÙŠÙ†"
        ]
    },
    "dhikr_tasbih": {
        "title": "Ø§Ù„ØªØ³Ø¨ÙŠØ­",
        "type": "text",
        "data": [
            "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡",
            "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø­Ù…Ø¯Ù‡",
            "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…",
            "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø­Ù…Ø¯Ù‡ØŒ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…"
        ]
    },
    "dhikr_istighfar": {
        "title": "Ø§Ù„Ø§Ø³ØªØºÙØ§Ø±",
        "type": "text",
        "data": [
            "Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡",
            "Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ… ÙˆØ£ØªÙˆØ¨ Ø¥Ù„ÙŠÙ‡",
            "Ø±Ø¨ Ø§ØºÙØ± Ù„ÙŠ ÙˆØªØ¨ Ø¹Ù„ÙŠ Ø¥Ù†Ùƒ Ø£Ù†Øª Ø§Ù„ØªÙˆØ§Ø¨ Ø§Ù„Ø±Ø­ÙŠÙ…",
            "Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù‚ÙŠÙˆÙ… ÙˆØ£ØªÙˆØ¨ Ø¥Ù„ÙŠÙ‡"
        ]
    },
    "dhikr_tahmid": {
        "title": "Ø§Ù„ØªØ­Ù…ÙŠØ¯",
        "type": "text",
        "data": ["Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡", "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø±Ø¨ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠÙ†", "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø­Ù…Ø¯Ø§Ù‹ ÙƒØ«ÙŠØ±Ø§Ù‹ Ø·ÙŠØ¨Ø§Ù‹ Ù…Ø¨Ø§Ø±ÙƒØ§Ù‹ ÙÙŠÙ‡"]
    },
    "dhikr_takbir": {
        "title": "Ø§Ù„ØªÙƒØ¨ÙŠØ±",
        "type": "text",
        "data": ["Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±", "Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø± ÙƒØ¨ÙŠØ±Ø§Ù‹"]
    },
    "dhikr_hawqala": {
        "title": "Ø§Ù„Ø­ÙˆÙ‚Ù„Ø©",
        "type": "text",
        "data": ["Ù„Ø§ Ø­ÙˆÙ„ ÙˆÙ„Ø§ Ù‚ÙˆØ© Ø¥Ù„Ø§ Ø¨Ø§Ù„Ù„Ù‡", "Ù„Ø§ Ø­ÙˆÙ„ ÙˆÙ„Ø§ Ù‚ÙˆØ© Ø¥Ù„Ø§ Ø¨Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ù„ÙŠ Ø§Ù„Ø¹Ø¸ÙŠÙ…"]
    },
     "salawat_image": {
        "title": "ØµÙˆØ± Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ",
        "type": "image",
        "data": [] # Will be populated if file_ids are added or generic placeholder used
    },
    "salawat_audio": {
        "title": "ØµÙˆØªÙŠØ§Øª Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ",
        "type": "audio",
        "data": []
    }
}

# ==========================================
# Database Manager (Ultimate Version with Smart Stats & Advanced Scheduler)
# ==========================================
class Database:
    def __init__(self, db_name):
        self.db_name = db_name
        self.lock = threading.Lock()
        self.init_tables_sync()

    def get_connection(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ timeout Ù…Ø­Ø³Ù‘Ù†"""
        conn = sqlite3.connect(self.db_name, check_same_thread=False, timeout=10.0)
        # ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… WAL mode
        conn.execute("PRAGMA journal_mode=WAL")
        conn.execute("PRAGMA synchronous=NORMAL")
        return conn
    
    def init_tables_sync(self):
        conn = self.get_connection()
        c = conn.cursor()
        
        # Users table - Enhanced with strict status tracking
        c.execute("""CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            status TEXT DEFAULT 'active',
            join_date TEXT,
            last_activity TEXT,
            blocked_date TEXT,
            left_date TEXT
        )""")
        
        # Chats table - Enhanced with strict status tracking
        c.execute("""CREATE TABLE IF NOT EXISTS chats (
            chat_id INTEGER PRIMARY KEY,
            type TEXT,
            title TEXT,
            username TEXT,
            invite_link TEXT,
            added_date TEXT,
            status TEXT DEFAULT 'active',
            removed_date TEXT,
            is_admin INTEGER DEFAULT 0,
            admin_rights TEXT,
            last_checked TEXT
        )""")
        
        # Migration: Add new columns if they don't exist
        try:
            c.execute("ALTER TABLE chats ADD COLUMN is_admin INTEGER DEFAULT 0")
        except:
            pass
        try:
            c.execute("ALTER TABLE chats ADD COLUMN admin_rights TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE chats ADD COLUMN last_checked TEXT")
        except:
            pass
        
        # Migration: Add username and invite_link columns if they don't exist
        try:
            c.execute("ALTER TABLE chats ADD COLUMN username TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE chats ADD COLUMN invite_link TEXT")
        except:
            pass
        
        # Services Settings (New for Modularity)
        c.execute("""CREATE TABLE IF NOT EXISTS chat_services (
            entity_id INTEGER PRIMARY KEY, 
            enable_afaq INTEGER DEFAULT 1,
            enable_wird INTEGER DEFAULT 0,
            enable_salawat INTEGER DEFAULT 0
        )""")
        
        # Smart Alarms Settings (Detailed Alarm System)
        c.execute("""CREATE TABLE IF NOT EXISTS alarm_settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chat_id INTEGER,
            alarm_type TEXT,
            is_active INTEGER DEFAULT 0,
            interval_minutes INTEGER DEFAULT 60,
            content_mode TEXT DEFAULT 'random',
            selected_content_index INTEGER DEFAULT 0,
            last_run TIMESTAMP,
            next_run TIMESTAMP,
            UNIQUE(chat_id, alarm_type)
        )""")
        c.execute("CREATE INDEX IF NOT EXISTS idx_alarm_next_run ON alarm_settings(next_run, is_active)")
        
        # Alarms Customized Content
        c.execute("""CREATE TABLE IF NOT EXISTS alarm_content (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            alarm_type TEXT,
            content_type TEXT DEFAULT 'text',
            text_content TEXT,
            file_id TEXT,
            reply_markup TEXT,
            added_by INTEGER DEFAULT 0,
            added_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )""")

        # Admins table
        c.execute("""CREATE TABLE IF NOT EXISTS admins (
            user_id INTEGER PRIMARY KEY,
            added_by INTEGER,
            added_date TEXT
        )""")
        
        # Blocked users via contact
        c.execute("""CREATE TABLE IF NOT EXISTS blocked_via_contact (
            user_id INTEGER PRIMARY KEY,
            blocked_by INTEGER,
            blocked_date TEXT,
            reason TEXT
        )""")
        
        # System Configuration (New for Maintenance Mode & Global Settings)
        c.execute("""CREATE TABLE IF NOT EXISTS system_config (
            key TEXT PRIMARY KEY,
            value TEXT
        )""")
        
        
        # Welcome message
        c.execute("""CREATE TABLE IF NOT EXISTS settings (
            key TEXT PRIMARY KEY,
            value TEXT
        )""")
        
        # Azkar Library
        c.execute("""CREATE TABLE IF NOT EXISTS azkar_data (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            category TEXT,
            subcategory TEXT,
            content_type TEXT,
            file_id TEXT,
            text TEXT,
            reference TEXT,
            count INTEGER DEFAULT 1,
            added_date TEXT,
            usage_count INTEGER DEFAULT 0
        )""")
        
        # System Buttons
        c.execute("""CREATE TABLE IF NOT EXISTS system_buttons (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            btn_key TEXT UNIQUE,
            btn_name TEXT,
            btn_order INTEGER DEFAULT 0,
            is_visible INTEGER DEFAULT 1,
            icon TEXT,
            description TEXT
        )""")
        
        # Custom Buttons
        c.execute("""CREATE TABLE IF NOT EXISTS custom_buttons (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            btn_name TEXT,
            parent_id INTEGER DEFAULT NULL,
            content_type TEXT,
            file_id TEXT,
            text TEXT,
            sort_order INTEGER DEFAULT 0,
            created_by INTEGER,
            created_at TEXT,
            FOREIGN KEY (parent_id) REFERENCES custom_buttons(id) ON DELETE CASCADE
        )""")
        
        c.execute("CREATE INDEX IF NOT EXISTS idx_parent ON custom_buttons(parent_id)")
        
        # Scheduled Tasks - Advanced Professional System
        c.execute("""CREATE TABLE IF NOT EXISTS scheduled_tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            task_name TEXT,
            task_type TEXT,  -- daily, specific_days, once
            target TEXT,
            content_type TEXT,
            file_id TEXT,
            text TEXT,
            entities TEXT,  -- JSON serialized entities
            service TEXT DEFAULT 'all',
            run_time TEXT,  -- HH:MM format
            start_date TEXT,  -- YYYY-MM-DD
            end_date TEXT,    -- YYYY-MM-DD or NULL for infinite
            days_of_week TEXT, -- JSON array [0,1,2] (0=Monday in Python, but we'll use custom mapping)
            timezone TEXT DEFAULT 'Asia/Riyadh',
            is_active INTEGER DEFAULT 1,
            validation_status TEXT DEFAULT 'pending', -- pending, validated, cancelled
            preview_sent INTEGER DEFAULT 0,
            created_by INTEGER,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            last_run TEXT,
            run_count INTEGER DEFAULT 0,
            total_targets INTEGER DEFAULT 0
        )""")
        
        # Indexes for performance - Ù…Ø­Ø³Ù‘Ù† Ù„Ù„Ø£Ø¯Ø§Ø¡
        c.execute("CREATE INDEX IF NOT EXISTS idx_schedule_status ON scheduled_tasks(is_active, validation_status)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_user_status ON users(status)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_chat_status ON chats(status)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_system_buttons_order ON system_buttons(btn_order, is_visible)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_custom_buttons_parent ON custom_buttons(parent_id, sort_order)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_scheduled_tasks_time ON scheduled_tasks(run_time, is_active)")
        
        # Broadcast History
        c.execute("""CREATE TABLE IF NOT EXISTS broadcast_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            broadcast_name TEXT,
            content_preview TEXT,
            target_type TEXT,
            target INTEGER,
            status TEXT DEFAULT 'success',
            sent_count INTEGER,
            failed_count INTEGER,
            sent_at TEXT,
            admin_id INTEGER,
            service TEXT DEFAULT 'manual'
        )""")
        
        # Contact messages
        c.execute("""CREATE TABLE IF NOT EXISTS contact_messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            from_user_id INTEGER,
            from_username TEXT,
            message_id INTEGER,
            content_type TEXT,
            content TEXT,
            file_id TEXT,
            sent_at TEXT,
            is_replied INTEGER DEFAULT 0
        )""")
        
        # Quran Audio System - Advanced
        c.execute("""CREATE TABLE IF NOT EXISTS reciters (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            reciter_key TEXT UNIQUE,
            name_ar TEXT,
            name_en TEXT,
            icon TEXT DEFAULT 'ğŸ™',
            server_url TEXT,
            quality TEXT DEFAULT '128kbps',
            is_active INTEGER DEFAULT 1,
            sort_order INTEGER DEFAULT 0,
            added_at TEXT,
            added_by INTEGER,
            total_surahs INTEGER DEFAULT 0
        )""")
        
        # Migration: Add new columns to existing reciters table
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN reciter_key TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN name_en TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN icon TEXT DEFAULT 'ğŸ™'")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN server_url TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN quality TEXT DEFAULT '128kbps'")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN is_active INTEGER DEFAULT 1")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN sort_order INTEGER DEFAULT 0")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN added_by INTEGER")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN total_surahs INTEGER DEFAULT 0")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN description TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE reciters ADD COLUMN created_by INTEGER")
        except:
            pass

        c.execute("""CREATE TABLE IF NOT EXISTS quran_audio (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            reciter_id INTEGER,
            surah_number INTEGER,
            file_id TEXT,
            file_size INTEGER,
            duration INTEGER,
            uploaded_at TEXT,
            uploaded_by INTEGER,
            FOREIGN KEY(reciter_id) REFERENCES reciters(id) ON DELETE CASCADE,
            UNIQUE(reciter_id, surah_number)
        )""")
        
        # Migration: Add new columns to existing quran_audio table
        try:
            c.execute("ALTER TABLE quran_audio ADD COLUMN file_size INTEGER")
        except:
            pass
        try:
            c.execute("ALTER TABLE quran_audio ADD COLUMN duration INTEGER")
        except:
            pass
        try:
            c.execute("ALTER TABLE quran_audio ADD COLUMN uploaded_at TEXT")
        except:
            pass
        try:
            c.execute("ALTER TABLE quran_audio ADD COLUMN uploaded_by INTEGER")
        except:
            pass
        
        # Quran Upload Progress Tracking
        c.execute("""CREATE TABLE IF NOT EXISTS quran_upload_sessions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            reciter_id INTEGER,
            admin_id INTEGER,
            status TEXT DEFAULT 'active',
            current_surah INTEGER DEFAULT 0,
            total_uploaded INTEGER DEFAULT 0,
            started_at TEXT,
            completed_at TEXT,
            FOREIGN KEY(reciter_id) REFERENCES reciters(id) ON DELETE CASCADE
        )""")
        
        # Create indexes only after ensuring columns exist
        try:
            c.execute("CREATE INDEX IF NOT EXISTS idx_reciters_active ON reciters(is_active, sort_order)")
        except:
            pass
        try:
            c.execute("CREATE INDEX IF NOT EXISTS idx_quran_audio_reciter ON quran_audio(reciter_id, surah_number)")
        except:
            pass
        
        # Migrate old reciters data: convert 'name' column to 'name_ar' if needed
        try:
            # Check if old 'name' column exists
            old_reciters = c.execute("SELECT id, name FROM reciters WHERE name_ar IS NULL").fetchall()
            for reciter in old_reciters:
                c.execute("UPDATE reciters SET name_ar = ?, reciter_key = ? WHERE id = ?", 
                         (reciter[1], reciter[1].lower().replace(" ", "_"), reciter[0]))
        except:
            pass
        
        # User Activity Tracking for Advanced Statistics
        c.execute("""CREATE TABLE IF NOT EXISTS user_activity (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            activity_type TEXT,
            activity_details TEXT,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP
        )""")
        c.execute("CREATE INDEX IF NOT EXISTS idx_user_activity ON user_activity(user_id, activity_type)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_activity_timestamp ON user_activity(timestamp)")
        
        # Activity Log for Real-time Stats
        c.execute("""CREATE TABLE IF NOT EXISTS activity_log (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            entity_id INTEGER,
            entity_type TEXT,  -- user, group, channel
            action TEXT,       -- joined, left, blocked, unblocked
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP
        )""")

        # Ensure new column exists for older DBs
        try:
            c.execute("ALTER TABLE scheduled_tasks ADD COLUMN service TEXT DEFAULT 'all'")
        except:
            pass
        
        # Ensure broadcast_history has target column (for older databases)
        try:
            c.execute("ALTER TABLE broadcast_history ADD COLUMN target INTEGER")
        except:
            pass
        
        # Ensure broadcast_history has service column (for scheduled vs manual tracking)
        try:
            c.execute("ALTER TABLE broadcast_history ADD COLUMN service TEXT DEFAULT 'manual'")
        except:
            pass
        
        # Initialize system buttons
        self._init_system_buttons(c)
        
        # Initialize default welcome message
        c.execute("""INSERT OR IGNORE INTO settings (key, value) VALUES ('welcome_msg', ?)""", 
                 ("Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ Ø§Ù„Ø±Ø­Ù…Ù† Ø§Ù„Ø±Ø­ÙŠÙ…\n\nØ£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ {name} ÙÙŠ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠ Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„\n\nØ§Ù„Ù…Ù…ÙŠØ²Ø§Øª:\nâ€¢ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… Ù…Ø¹ Ø§Ù„ØªÙØ³ÙŠØ±\nâ€¢ Ø£Ø°ÙƒØ§Ø± ÙˆØ£Ø¯Ø¹ÙŠØ© Ù…ØªÙ†ÙˆØ¹Ø©\nâ€¢ Ù…Ø³Ø¨Ø­Ø© Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©",))
        
        conn.commit()
        conn.close()
        logger.info("Database initialized successfully with Advanced Scheduler & Smart Stats")

    def _init_system_buttons(self, cursor):
        default_buttons = [
            ("quran", "Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…", 1, "", "Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… Ù…Ø¹ Ø§Ù„ØªÙØ³ÙŠØ±"),
            ("hadith", "Ø­Ø¯ÙŠØ« Ø´Ø±ÙŠÙ", 2, "", "Ø£Ø­Ø§Ø¯ÙŠØ« Ù†Ø¨ÙˆÙŠØ© Ø´Ø±ÙŠÙØ©"),
            ("azkar", "Ø£Ø°ÙƒØ§Ø± ÙˆØ£Ø¯Ø¹ÙŠØ©", 3, "", "Ø£Ø°ÙƒØ§Ø± ÙˆØ£Ø¯Ø¹ÙŠØ© Ù…Ù† Ø§Ù„Ø³Ù†Ø©"),
            ("tasbih", "Ø§Ù„Ù…Ø³Ø¨Ø­Ø©", 4, "", "Ù…Ø³Ø¨Ø­Ø© Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©"),
            ("add_bot_help", "Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª", 5, "", "Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ùˆ Ø§Ù„Ù‚Ù†Ø§Ø©"),
            ("contact", "ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§", 6, "", "Ù„Ù„ØªÙˆØ§ØµÙ„ ÙˆØ§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª")
        ]
        
        # update contact button to be visible only in main menu by default if logic supported category
        # Since we don't have category column in system_buttons initialization tuple here, 
        # we assume logic handles it elsewhere or we just rely on get_system_buttons filter.
        
        for key, name, order, icon, desc in default_buttons:
            cursor.execute("""INSERT OR IGNORE INTO system_buttons 
                (btn_key, btn_name, btn_order, icon, description) 
                VALUES (?, ?, ?, ?, ?)""", (key, name, order, icon, desc))

    # ========== Smart Real-time Stats System ==========
    def update_entity_status(self, entity_id: int, entity_type: str, status: str, title: str = None, username: str = None, invite_link: str = None):
        """ØªØ­Ø¯ÙŠØ« ÙÙˆØ±ÙŠ Ù„Ø­Ø§Ù„Ø© Ø§Ù„ÙƒÙŠØ§Ù† (Ù…Ø³ØªØ®Ø¯Ù…/Ù…Ø¬Ù…ÙˆØ¹Ø©/Ù‚Ù†Ø§Ø©)"""
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            c = conn.cursor()
            
            if entity_type == 'user':
                if status == 'active':
                    c.execute("""INSERT OR REPLACE INTO users 
                        (user_id, username, status, join_date, last_activity, left_date) 
                        VALUES (?, ?, 'active', COALESCE((SELECT join_date FROM users WHERE user_id=?), ?), ?, NULL)""",
                        (entity_id, username, entity_id, now, now))
                elif status == 'left' or status == 'kicked':
                    c.execute("""UPDATE users SET status = 'inactive', left_date = ? WHERE user_id = ?""", (now, entity_id))
                    # Log activity
                    c.execute("""INSERT INTO activity_log (entity_id, entity_type, action, timestamp) 
                               VALUES (?, 'user', ?, ?)""", (entity_id, status, now))
            
            elif entity_type in ['group', 'supergroup', 'channel']:
                if status == 'active':
                    # V5 Upgrade: Support Username & Link
                    # Use INSERT INTO ... ON CONFLICT to preserve other fields if needed, or REPLACE
                    # REPLACE deletes old row, so we might lose original added_date if logic below fails?
                    # The logic uses subquery COALESCE, so it preserves added_date.
                    
                    c.execute("""INSERT INTO chats (chat_id, type, title, username, invite_link, added_date, status, removed_date)
                        VALUES (?, ?, ?, ?, ?, COALESCE((SELECT added_date FROM chats WHERE chat_id=?), ?), 'active', NULL)
                        ON CONFLICT(chat_id) DO UPDATE SET
                            title=excluded.title,
                            username=excluded.username,
                            invite_link=COALESCE(excluded.invite_link, chats.invite_link),
                            status='active',
                            removed_date=NULL
                        """,
                        (entity_id, entity_type, title, username, invite_link, entity_id, now))
                        
                elif status == 'left' or status == 'kicked':
                    c.execute("""UPDATE chats SET status = 'inactive', removed_date = ? WHERE chat_id = ?""", (now, entity_id))
                    c.execute("""INSERT INTO activity_log (entity_id, entity_type, action, timestamp) 
                               VALUES (?, ?, ?, ?)""", (entity_id, entity_type, status, now))
            
            conn.commit()
            conn.close()
            logger.info(f"Entity {entity_id} ({entity_type}) status updated to {status}")
            return True
        except Exception as e:
            logger.error(f"Error updating entity status: {e}")
            return False

    def get_live_stats(self):
        """Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø³ÙŠØ·Ø©"""
        conn = self.get_connection()
        try:
            # Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
            users_total = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
            users_active = conn.execute("SELECT COUNT(*) FROM users WHERE status='active' OR status IS NULL").fetchone()[0]
            
            # Ø¹Ø¯Ø¯ ÙƒÙ„ Ø§Ù„Ø´Ø§ØªØ§Øª
            all_chats = conn.execute('SELECT COUNT(*) FROM chats').fetchone()[0]
            
            # ØªØµÙ†ÙŠÙ Ø§Ù„Ø´Ø§ØªØ§Øª - Ù…Ø¨Ø§Ø´Ø± Ø¨Ø¯ÙˆÙ† ØªØ¹Ù‚ÙŠØ¯
            channels = conn.execute("SELECT COUNT(*) FROM chats WHERE type='channel'").fetchone()[0]
            groups = conn.execute("SELECT COUNT(*) FROM chats WHERE type IN ('group', 'supergroup')").fetchone()[0]
            unknown = all_chats - channels - groups
            
            # Ø§Ù„Ø´Ø§ØªØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©
            channels_active = conn.execute("SELECT COUNT(*) FROM chats WHERE type='channel' AND (status='active' OR status IS NULL)").fetchone()[0]
            groups_active = conn.execute("SELECT COUNT(*) FROM chats WHERE type IN ('group', 'supergroup') AND (status='active' OR status IS NULL)").fetchone()[0]
            unknown_active = conn.execute("SELECT COUNT(*) FROM chats WHERE type NOT IN ('channel', 'group', 'supergroup') AND (status='active' OR status IS NULL)").fetchone()[0]
            
            stats = {
                'users': {
                    'total': users_total,
                    'active': users_active,
                    'blocked': conn.execute("SELECT COUNT(*) FROM users WHERE status='blocked'").fetchone()[0],
                    'inactive': users_total - users_active,
                },
                'channels': {
                    'total': channels,
                    'active': channels_active,
                    'inactive': channels - channels_active
                },
                'groups': {
                    'total': groups,
                    'active': groups_active,
                    'inactive': groups - groups_active
                },
                'unknown_chats': {
                    'total': unknown,
                    'active': unknown_active,
                },
                'today': {
                    'new_users': conn.execute("SELECT COUNT(*) FROM users WHERE date(join_date) = date('now')").fetchone()[0],
                },
                'week': {
                    'active_users': conn.execute("SELECT COUNT(*) FROM users WHERE last_activity >= datetime('now', '-7 days')").fetchone()[0],
                }
            }
            
            # Ø§Ù„Ù…Ø¬Ø§Ù…ÙŠØ¹
            stats['total_all'] = users_total + all_chats
            stats['total_active'] = users_active + channels_active + groups_active + unknown_active
            stats['total_inactive'] = stats['total_all'] - stats['total_active']
            
            # Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©
            stats['broadcast'] = {
                'all_targets': stats['total_active'],
                'users_only': users_active,
                'channels_only': channels_active,
                'groups_only': groups_active,
                'chats_only': channels_active + groups_active + unknown_active
            }
            
            logger.info(f"ğŸ“Š STATS: Users={users_total}({users_active}), Channels={channels}({channels_active}), Groups={groups}({groups_active}), Unknown={unknown}")
            
            return stats
        except Exception as e:
            logger.error(f"Error in get_live_stats: {e}", exc_info=True)
            return None

    def add_user(self, user_id, username=None):
        """Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ù†Ø´Ø§Ø·Ù‡ - ØªØ­Ø¯ÙŠØ« Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ø­Ø³Ù‘Ù†"""
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            c = conn.cursor()
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØªØ­Ø¯ÙŠØ«Ù‡ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±
            c.execute("SELECT status FROM users WHERE user_id = ?", (user_id,))
            result = c.fetchone()
            
            if result:
                # ØªØ­Ø¯ÙŠØ« Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù† Ù…Ø­Ø¸ÙˆØ± (Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª)
                if result[0] not in ['blocked', 'left']:
                    c.execute("""UPDATE users SET last_activity = ?, username = ?, status = 'active', left_date = NULL, blocked_date = NULL WHERE user_id = ?""", 
                             (now, username, user_id))
                    logger.debug(f"ğŸ“Š Updated active user: {user_id}")
                else:
                    # ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± Ù†Ø´Ø§Ø· ÙÙ‚Ø· Ø¯ÙˆÙ† ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©
                    c.execute("""UPDATE users SET last_activity = ?, username = ? WHERE user_id = ?""", 
                             (now, username, user_id))
                    logger.debug(f"ğŸ“Š Updated {result[0]} user activity: {user_id}")
            else:
                c.execute("""INSERT INTO users 
                    (user_id, username, status, join_date, last_activity) 
                    VALUES (?, ?, 'active', ?, ?)""", (user_id, username, now, now))
                logger.info(f"âœ… NEW USER REGISTERED: {user_id} (@{username})")
            
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Add user error: {e}", exc_info=True)

    # ========== Users & Stats Management (Active Only) ==========
    def block_user(self, user_id, blocked_by):
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            conn.execute("""UPDATE users SET status = 'blocked', blocked_date = ? WHERE user_id = ?""", 
                        (now, user_id))
            conn.execute("""INSERT OR REPLACE INTO blocked_via_contact (user_id, blocked_by, blocked_date) 
                           VALUES (?, ?, ?)""", (user_id, blocked_by, now))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Block user error: {e}")
            return False

    def unblock_user(self, user_id):
        try:
            conn = self.get_connection()
            conn.execute("""UPDATE users SET status = 'active', blocked_date = NULL WHERE user_id = ?""", (user_id,))
            conn.execute("""DELETE FROM blocked_via_contact WHERE user_id = ?""", (user_id,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Unblock user error: {e}")
            return False

    def is_user_blocked(self, user_id):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT status FROM users WHERE user_id = ?", (user_id,)).fetchone()
            conn.close()
            return result and result[0] == 'blocked'
        except:
            return False
    
    def get_blocked_users_list(self):
        """Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†"""
        try:
            conn = self.get_connection()
            result = conn.execute("""SELECT user_id, blocked_by, blocked_date, reason 
                                  FROM blocked_via_contact 
                                  ORDER BY blocked_date DESC""").fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get blocked users error: {e}")
            return []

    def get_service_subscriber_count(self, service_name):
        try:
           conn = self.get_connection()
           count = 0
           if service_name == "afaq":
               # Afaq is enabled by default unless disabled in chat_services
               query = """
               SELECT COUNT(*) FROM (
                   SELECT user_id FROM users WHERE status='active'
                   UNION ALL
                   SELECT chat_id FROM chats WHERE status='active'
               ) as active_entities
               WHERE active_entities.user_id NOT IN (
                   SELECT entity_id FROM chat_services WHERE enable_afaq=0
               )
               """
               count = conn.execute(query).fetchone()[0]
               
           elif service_name == "wird":
               # Wird must be explicitly enabled
               query = """
               SELECT COUNT(*) FROM chat_services 
               WHERE enable_wird=1 AND (
                   entity_id IN (SELECT user_id FROM users WHERE status='active') OR
                   entity_id IN (SELECT chat_id FROM chats WHERE status='active')
               )
               """
               count = conn.execute(query).fetchone()[0]

           elif service_name == "alarms":
               # Alarms are counted if they have any active alarm setting
               query = """
               SELECT COUNT(DISTINCT chat_id) FROM alarm_settings 
               WHERE is_active=1 AND (
                   chat_id IN (SELECT user_id FROM users WHERE status='active') OR
                   chat_id IN (SELECT chat_id FROM chats WHERE status='active')
               )
               """
               count = conn.execute(query).fetchone()[0]
               
           conn.close()
           return count
        except Exception as e:
           logger.error(f"Get service stats error: {e}")
           return 0

    # âŒ ØªÙ… Ø­Ø°Ù get_user_stats() Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© - Ø§Ø³ØªØ®Ø¯Ù… get_live_stats() ÙÙ‚Ø·
    # âŒ ØªÙ… Ø­Ø°Ù get_detailed_stats() Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© - Ø§Ø³ØªØ®Ø¯Ù… get_live_stats() ÙÙ‚Ø· (88 Ø³Ø·Ø± Ù…ÙƒØ±Ø± ØªÙ… Ø­Ø°ÙÙ‡)

    # ========== Chats Management ==========
    def add_chat(self, chat_id, chat_type, title, username=None, link=None):
        """Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ ØªÙØ¹ÙŠÙ„ Ù…Ø­Ø§Ø¯Ø«Ø© ÙˆØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡Ø§"""
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            
            # Use REPLACE or UPDATE to capture new username/link even if already exists
            conn.execute("""INSERT INTO chats (chat_id, type, title, username, invite_link, added_date, status) 
                VALUES (?, ?, ?, ?, ?, ?, 'active')
                ON CONFLICT(chat_id) DO UPDATE SET 
                    title=excluded.title,
                    username=excluded.username,
                    invite_link=COALESCE(excluded.invite_link, chats.invite_link),
                    status='active',
                    removed_date=NULL
                """, (chat_id, chat_type, title, username, link, now))
            
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Add chat error: {e}")

    def remove_chat(self, chat_id):
        """ØªØ¹Ø·ÙŠÙ„ Ù…Ø­Ø§Ø¯Ø«Ø© (ÙˆÙ„ÙŠØ³ Ø­Ø°ÙÙ‡Ø§)"""
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            conn.execute("""UPDATE chats SET status = 'inactive', removed_date = ? WHERE chat_id = ?""", 
                        (now, chat_id))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Remove chat error: {e}")

    # âŒ ØªÙ… Ø­Ø°Ù get_chat_stats() Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© - Ø§Ø³ØªØ®Ø¯Ù… get_live_stats() ÙÙ‚Ø·

    # ========== Admins Management ==========
    def add_admin(self, user_id, added_by):
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            conn.execute("""INSERT OR IGNORE INTO admins (user_id, added_by, added_date) VALUES (?, ?, ?)""",
                        (user_id, added_by, now))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Add admin error: {e}")
            return False

    def remove_admin(self, user_id):
        try:
            conn = self.get_connection()
            conn.execute("""DELETE FROM admins WHERE user_id = ?""", (user_id,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Remove admin error: {e}")
            return False

    def is_admin(self, user_id):
        if user_id == ADMIN_ID:
            return True
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT 1 FROM admins WHERE user_id = ?", (user_id,)).fetchone()
            conn.close()
            return result is not None
        except:
            return False

    def get_admins_list(self):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT user_id FROM admins").fetchall()
            conn.close()
            return [r[0] for r in result]
        except:
            return []

    # ========== System Config Management (New) ==========
    def set_config(self, key, value):
        try:
            conn = self.get_connection()
            conn.execute("INSERT OR REPLACE INTO system_config (key, value) VALUES (?, ?)", (str(key), str(value)))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Set config error: {e}")
            return False

    def get_config(self, key, default=None):
        try:
            conn = self.get_connection()
            res = conn.execute("SELECT value FROM system_config WHERE key = ?", (str(key),)).fetchone()
            conn.close()
            return res[0] if res else default
        except Exception as e:
            logger.error(f"Get config error: {e}")
            return default

    # ========== Services Management (New) ==========
    def get_chat_services(self, entity_id):
        try:
            conn = self.get_connection()
            # If not exists, create with defaults
            row = conn.execute("SELECT enable_afaq, enable_wird, enable_salawat FROM chat_services WHERE entity_id = ?", (entity_id,)).fetchone()
            if not row:
                conn.execute("INSERT INTO chat_services (entity_id) VALUES (?)", (entity_id,))
                conn.commit()
                row = (1, 0, 0) # Defaults
            conn.close()
            return {"afaq": row[0], "wird": row[1], "salawat": row[2]}
        except Exception as e:
            logger.error(f"Get services error: {e}")
            return {"afaq": 1, "wird": 0, "salawat": 0}

    def update_chat_service(self, entity_id, service, status: bool):
        try:
            conn = self.get_connection()
            col_map = {"afaq": "enable_afaq", "wird": "enable_wird", "salawat": "enable_salawat"}
            if service not in col_map: 
                return False
            col = col_map[service]
            val = 1 if status else 0
            
            # Ensure record exists
            conn.execute("INSERT OR IGNORE INTO chat_services (entity_id) VALUES (?)", (entity_id,))
            conn.execute(f"UPDATE chat_services SET {col} = ? WHERE entity_id = ?", (val, entity_id))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Update service error: {e}")
            return False

    def update_chat_services(self, entity_id, enable_afaq=None, enable_wird=None, enable_salawat=None):
        try:
            conn = self.get_connection()
            conn.execute("INSERT OR IGNORE INTO chat_services (entity_id) VALUES (?)", (entity_id,))
            
            updates = []
            params = []
            if enable_afaq is not None:
                updates.append("enable_afaq=?")
                params.append(1 if enable_afaq else 0)
            if enable_wird is not None:
                updates.append("enable_wird=?")
                params.append(1 if enable_wird else 0)
            if enable_salawat is not None:
                updates.append("enable_salawat=?")
                params.append(1 if enable_salawat else 0)
                
            if updates:
                params.append(entity_id)
                conn.execute(f"UPDATE chat_services SET {', '.join(updates)} WHERE entity_id=?", tuple(params))
                conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Update chat services error: {e}")
            return False

    def get_service_subscribers(self, service):
        try:
           conn = self.get_connection()
           col_map = {"afaq": "enable_afaq", "wird": "enable_wird", "salawat": "enable_salawat"}
           col = col_map.get(service, "enable_afaq")
           
           conn.execute("CREATE TABLE IF NOT EXISTS chat_services (entity_id INTEGER PRIMARY KEY, enable_afaq INTEGER DEFAULT 1, enable_wird INTEGER DEFAULT 0, enable_salawat INTEGER DEFAULT 0)")
           
           # Get IDs where service is enabled
           query = f"SELECT entity_id FROM chat_services WHERE {col} = 1"
           rows = conn.execute(query).fetchall()
           conn.close()
           return [r[0] for r in rows]
        except Exception as e:
           logger.error(f"Get subscribers error: {e}")
           return []

    # ========== Smart Alarms Manager ==========
    def get_alarm_settings(self, chat_id, alarm_type):
        try:
            conn = self.get_connection()
            row = conn.execute("""
                SELECT is_active, interval_minutes, content_mode, selected_content_index 
                FROM alarm_settings 
                WHERE chat_id = ? AND alarm_type = ?
            """, (chat_id, alarm_type)).fetchone()
            
            if not row:
                # Default settings: Inactive, 60 mins, random
                return {"is_active": 0, "interval": 60, "mode": "random", "content_index": 0}
            
            return {
                "is_active": row[0],
                "interval": row[1],
                "mode": row[2],
                "content_index": row[3]
            }
        except Exception as e:
            logger.error(f"Get alarm settings error: {e}")
            return {"is_active": 0, "interval": 60, "mode": "random", "content_index": 0}

    def update_alarm_settings(self, chat_id, alarm_type, is_active=None, interval=None, mode=None, content_index=None):
        try:
            conn = self.get_connection()
            # Check existence
            exists = conn.execute("SELECT 1 FROM alarm_settings WHERE chat_id=? AND alarm_type=?", (chat_id, alarm_type)).fetchone()
            
            if not exists:
                conn.execute("""
                    INSERT INTO alarm_settings (chat_id, alarm_type, next_run) 
                    VALUES (?, ?, ?)
                """, (chat_id, alarm_type, datetime.now()))
                
            updates = []
            params = []
            
            if is_active is not None:
                updates.append("is_active = ?")
                params.append(1 if is_active else 0)
                # If activating, reset next_run to now + interval if it's in the past? Or just now.
                if is_active:
                     updates.append("next_run = ?")
                     params.append(datetime.now())

            if interval is not None:
                updates.append("interval_minutes = ?")
                params.append(interval)
            
            if mode is not None:
                updates.append("content_mode = ?")
                params.append(mode)
            
            if content_index is not None:
                updates.append("selected_content_index = ?")
                params.append(content_index)
            
            if updates:
                query = f"UPDATE alarm_settings SET {', '.join(updates)} WHERE chat_id=? AND alarm_type=?"
                params.append(chat_id)
                params.append(alarm_type)
                conn.execute(query, tuple(params))
                conn.commit()
            
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Update alarm settings error: {e}")
            return False

    def get_due_alarms(self):
        try:
            conn = self.get_connection()
            # Fetch alarms where is_active=1 AND next_run <= NOW
            now = datetime.now()
            
            # Using Row Factory or manual dict creation might be better, but tuple is faster
            rows = conn.execute("""
                SELECT id, chat_id, alarm_type, interval_minutes, content_mode, selected_content_index
                FROM alarm_settings 
                WHERE is_active = 1 AND next_run <= ?
            """, (now,)).fetchall()
            conn.close()
            return rows
        except Exception as e:
            logger.error(f"Get due alarms error: {e}")
            return []

    def update_alarm_next_run(self, alarm_id, interval_minutes):
        try:
            conn = self.get_connection()
            next_run = datetime.now() + timedelta(minutes=interval_minutes)
            conn.execute("UPDATE alarm_settings SET last_run = ?, next_run = ? WHERE id = ?", (datetime.now(), next_run, alarm_id))
            conn.commit()
            conn.close()
        except:
            pass

    # ========== Wird Settings Manager ==========
    def get_wird_settings(self, chat_id):
        try:
            conn = self.get_connection()
            # Ensure table
            conn.execute("""CREATE TABLE IF NOT EXISTS wird_settings (
                chat_id INTEGER PRIMARY KEY,
                quran_edition TEXT DEFAULT 'madina',
                current_page INTEGER DEFAULT 1,
                pages_per_day INTEGER DEFAULT 1,
                notification_time TEXT DEFAULT '08:00',
                status TEXT DEFAULT 'active'
            )""")
            
            row = conn.execute("SELECT notification_time, status, pages_per_day, quran_edition FROM wird_settings WHERE chat_id=?", (chat_id,)).fetchone()
            conn.close()
            
            if row:
                return {
                    "time": row[0],
                    "status": row[1] == 'active',
                    "pages": row[2],
                    "edition": row[3]
                }
            else:
                return {"time": "08:00", "status": False, "pages": 1, "edition": "madina"}
        except Exception as e:
            logger.error(f"Get wird settings error: {e}")
            return {"time": "08:00", "status": False, "pages": 1, "edition": "madina"}

    def update_wird_settings(self, chat_id, **kwargs):
        try:
            conn = self.get_connection()
            # Ensure row exists
            conn.execute("INSERT OR IGNORE INTO wird_settings (chat_id) VALUES (?)", (chat_id,))
            
            updates = []
            params = []
            
            if "time" in kwargs:
                updates.append("notification_time=?")
                params.append(kwargs["time"])
            if "status" in kwargs:
                updates.append("status=?")
                params.append('active' if kwargs["status"] else 'inactive')
            if "pages" in kwargs:
                updates.append("pages_per_day=?")
                params.append(kwargs["pages"])
            if "edition" in kwargs:
                updates.append("quran_edition=?")
                params.append(kwargs["edition"])
                
            if updates and params:
                params.append(chat_id)
                conn.execute(f"UPDATE wird_settings SET {', '.join(updates)} WHERE chat_id=?", tuple(params))
                conn.commit()
            
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Update wird settings error: {e}")
            return False

    def get_chat_services_status(self, chat_id):
        try:
            conn = self.get_connection()
            conn.execute("CREATE TABLE IF NOT EXISTS chat_services (entity_id INTEGER PRIMARY KEY, enable_afaq INTEGER DEFAULT 1, enable_wird INTEGER DEFAULT 0, enable_salawat INTEGER DEFAULT 0)")
            row = conn.execute("SELECT enable_afaq, enable_wird, enable_salawat FROM chat_services WHERE entity_id=?", (chat_id,)).fetchone()
            conn.close()
            if row:
                return {"afaq": bool(row[0]), "wird": bool(row[1]), "alarms": bool(row[2])}
            return {"afaq": True, "wird": False, "alarms": False}
        except Exception as e:
            logger.error(f"Get services status error: {e}")
            return {"afaq": True, "wird": False, "alarms": False}

    # ========== Alarm Content Management ==========
    def get_alarm_content(self, alarm_type):
        """Get content from DB, fallback to code if empty initially"""
        try:
            conn = self.get_connection()
            rows = conn.execute("SELECT id, content_type, text_content, file_id, reply_markup FROM alarm_content WHERE alarm_type=?", (alarm_type,)).fetchall()
            
            # If DB empty for this type, check static dict and populate once
            if not rows and alarm_type in ALARMS_CONTENT:
                # Populate
                static = ALARMS_CONTENT[alarm_type]
                data = static.get('data', [])
                st_type = static.get('type', 'text')
                
                for item in data:
                    txt = item if st_type == 'text' else None
                    fid = item if st_type != 'text' else None # In static dict, simplistic
                    # Actually static dict has strings for text. For files, we better handle later. 
                    # Assuming static dict only has text for now as per code.
                    conn.execute("INSERT INTO alarm_content (alarm_type, content_type, text_content) VALUES (?, ?, ?)", 
                                 (alarm_type, st_type, txt))
                conn.commit()
                # Re-fetch
                rows = conn.execute("SELECT id, content_type, text_content, file_id, reply_markup FROM alarm_content WHERE alarm_type=?", (alarm_type,)).fetchall()
            
            conn.close()
            
            # Helper format
            results = []
            for r in rows:
                results.append({
                    "id": r[0],
                    "type": r[1],
                    "text": r[2],
                    "file_id": r[3]
                })
            return results
        except Exception as e:
            logger.error(f"Get alarm content error: {e}")
            return []

    def add_alarm_content(self, alarm_type, content_type, text=None, file_id=None, user_id=0):
        try:
            conn = self.get_connection()
            conn.execute("INSERT INTO alarm_content (alarm_type, content_type, text_content, file_id, added_by) VALUES (?, ?, ?, ?, ?)",
                         (alarm_type, content_type, text, file_id, user_id))
            conn.commit()
            conn.close()
            return True
        except:
            return False

    def delete_alarm_content(self, content_id):
        try:
            conn = self.get_connection()
            conn.execute("DELETE FROM alarm_content WHERE id=?", (content_id,))
            conn.commit()
            conn.close()
            return True
        except:
            return False

    # ========== Welcome Message ==========
    def get_welcome_message(self):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT value FROM settings WHERE key = 'welcome_msg'").fetchone()
            conn.close()
            return result[0] if result else None
        except:
            return None

    def set_welcome_message(self, text):
        try:
            conn = self.get_connection()
            conn.execute("INSERT OR REPLACE INTO settings (key, value) VALUES ('welcome_msg', ?)", (text,))
            conn.commit()
            conn.close()
            return True
        except:
            return False

    # ========== System Buttons ==========
    def get_system_buttons(self, for_admin: bool = False, category: str = None):
        try:
            conn = self.get_connection()
            if for_admin:
                if category:
                    result = conn.execute("SELECT id, btn_key, btn_name, btn_order, is_visible, icon FROM system_buttons WHERE category=? ORDER BY btn_order", (category,)).fetchall()
                else:
                    # Default view for admin (maybe all?) or just uncategorized/main?
                    # For backward compatibility showing all for main list if category is None
                    result = conn.execute("SELECT id, btn_key, btn_name, btn_order, is_visible, icon FROM system_buttons ORDER BY btn_order").fetchall()
            else:
                if category:
                    result = conn.execute("SELECT btn_key, btn_name, icon, btn_order FROM system_buttons WHERE is_visible=1 AND category=? ORDER BY btn_order", (category,)).fetchall()
                else:
                    # Fallback for old code: fetch everything OR fetch those with category NULL or 'main'?
                    # To be safe, let's fetch 'main' and 'maintop' if no category specified, or just all.
                    # Best to filter by category IS NULL or default 'main' if desired, but for now let's return all visible to avoid breaking old calls if any.
                    result = conn.execute("SELECT btn_key, btn_name, icon, btn_order FROM system_buttons WHERE is_visible=1 ORDER BY btn_order").fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get system buttons error: {e}")
            return []

    def update_system_button(self, btn_id: int, new_name: str = None, new_order: int = None, is_visible: bool = None, new_icon: str = None):
        try:
            conn = self.get_connection()
            if new_name:
                conn.execute("UPDATE system_buttons SET btn_name=? WHERE id=?", (new_name, btn_id))
            if new_order is not None:
                conn.execute("UPDATE system_buttons SET btn_order=? WHERE id=?", (new_order, btn_id))
            if is_visible is not None:
                conn.execute("UPDATE system_buttons SET is_visible=? WHERE id=?", (1 if is_visible else 0, btn_id))
            if new_icon is not None:
                conn.execute("UPDATE system_buttons SET icon=? WHERE id=?", (new_icon, btn_id))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Update system button error: {e}")
            return False

    def get_system_button_by_id(self, btn_id: int):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT id, btn_key, btn_name, btn_order, is_visible, icon FROM system_buttons WHERE id=?", (btn_id,)).fetchone()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get system button by id error: {e}")
            return None

    def get_system_button_by_name(self, btn_name: str):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT id, btn_key, btn_name, btn_order, is_visible, icon FROM system_buttons WHERE btn_name=?", (btn_name,)).fetchone()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get system button by name error: {e}")
            return None

    # ========== Custom Buttons ==========
    def get_root_buttons(self):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT id, btn_name FROM custom_buttons WHERE parent_id IS NULL ORDER BY sort_order").fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get root buttons error: {e}")
            return []
    
    def get_button_content(self, btn_id: int):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT content_type, file_id, text FROM custom_buttons WHERE id=?", (btn_id,)).fetchone()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get button content error: {e}")
            return None
    
    def add_custom_button(self, btn_name: str, parent_id: Optional[int], content_type: str, file_id: str, text: str, created_by: int):
        try:
            conn = self.get_connection()
            conn.execute("""INSERT INTO custom_buttons 
                (btn_name, parent_id, content_type, file_id, text, created_by, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (btn_name, parent_id, content_type, file_id, text, created_by, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Add custom button error: {e}")
            return False
    
    def delete_custom_button(self, btn_id: int):
        try:
            conn = self.get_connection()
            conn.execute("DELETE FROM custom_buttons WHERE id=?", (btn_id,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Delete custom button error: {e}")
            return False

    def get_all_custom_buttons(self):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT id, btn_name, parent_id, content_type FROM custom_buttons ORDER BY parent_id, sort_order").fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get all custom buttons error: {e}")
            return []

    # ========== Azkar Data ==========
    def add_azkar(self, category: str, subcategory: str, content_type: str, file_id: str, text: str, reference: str = None, count: int = 1):
        try:
            conn = self.get_connection()
            
            # ÙØ­Øµ Ø§Ù„ØªÙƒØ±Ø§Ø±: Ù„Ø§ Ù†Ø¶ÙŠÙ Ø°ÙƒØ± Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù†ÙØ³ Ø§Ù„Ù†Øµ Ø£Ùˆ file_id
            if text:
                existing = conn.execute("SELECT id FROM azkar_data WHERE text = ? AND category = ?", (text.strip(), category)).fetchone()
                if existing:
                    logger.info(f"Duplicate azkar text found, skipping: {text[:50]}...")
                    conn.close()
                    return False
            
            if file_id:
                existing = conn.execute("SELECT id FROM azkar_data WHERE file_id = ?", (file_id,)).fetchone()
                if existing:
                    logger.info(f"Duplicate azkar file found, skipping")
                    conn.close()
                    return False
            
            conn.execute("""INSERT INTO azkar_data 
                (category, subcategory, content_type, file_id, text, reference, count, added_date, usage_count)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0)""",
                (category, subcategory, content_type, file_id, text, reference, count, 
                 datetime.now().strftime("%Y-%m-%d")))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Add azkar error: {e}")
            return False
    
    def remove_duplicate_azkar(self):
        """Ø­Ø°Ù Ø§Ù„Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ù…ÙƒØ±Ø±Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        try:
            conn = self.get_connection()
            c = conn.cursor()
            
            # Ø­Ø°Ù Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ (ÙŠØ¨Ù‚ÙŠ Ø§Ù„Ø£Ù‚Ø¯Ù…)
            c.execute("""
                DELETE FROM azkar_data 
                WHERE id NOT IN (
                    SELECT MIN(id) 
                    FROM azkar_data 
                    WHERE text IS NOT NULL AND text != ''
                    GROUP BY text, category
                ) AND text IS NOT NULL AND text != ''
            """)
            text_dups = c.rowcount
            
            # Ø­Ø°Ù Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ file_id
            c.execute("""
                DELETE FROM azkar_data 
                WHERE id NOT IN (
                    SELECT MIN(id) 
                    FROM azkar_data 
                    WHERE file_id IS NOT NULL AND file_id != ''
                    GROUP BY file_id
                ) AND file_id IS NOT NULL AND file_id != ''
            """)
            file_dups = c.rowcount
            
            conn.commit()
            conn.close()
            
            total_removed = text_dups + file_dups
            if total_removed:
                logger.info(f"Removed {total_removed} duplicate azkar ({text_dups} text, {file_dups} file)")
            return total_removed
        except Exception as e:
            logger.error(f"Remove duplicate azkar error: {e}")
            return 0
    
    def get_azkar(self, category: str = None, subcategory: str = None, limit: int = 10, exclude_used: bool = False):
        try:
            conn = self.get_connection()
            
            if category:
                result = conn.execute("""SELECT id, content_type, file_id, text, reference, count 
                                      FROM azkar_data 
                                      WHERE category=?
                                      ORDER BY RANDOM() LIMIT ?""", 
                                      (category, limit)).fetchall()
            else:
                result = conn.execute("""SELECT id, content_type, file_id, text, reference, count 
                                      FROM azkar_data 
                                      ORDER BY RANDOM() LIMIT ?""", (limit,)).fetchall()
            
            # ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
            for row in result:
                conn.execute("UPDATE azkar_data SET usage_count=usage_count+1 WHERE id=?", (row[0],))
            
            conn.commit()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get azkar error: {e}")
            return []

    def get_ordered_azkar(self, category: str, limit: int = 100):
        try:
            conn = self.get_connection()
            result = conn.execute("""SELECT id, content_type, file_id, text, reference, count 
                                  FROM azkar_data 
                                  WHERE category=?
                                  ORDER BY id ASC LIMIT ?""", 
                                  (category, limit)).fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get ordered azkar error: {e}")
            return []
    
    def get_azkar_categories(self):
        try:
            conn = self.get_connection()
            result = conn.execute("SELECT DISTINCT category FROM azkar_data").fetchall()
            conn.close()
            return [r[0] for r in result]
        except Exception as e:
            logger.error(f"Get azkar categories error: {e}")
            return []
    
    def get_all_azkar_list(self):
        try:
            conn = self.get_connection()
            result = conn.execute("""SELECT id, category, text, reference, count 
                                  FROM azkar_data 
                                  ORDER BY category, id DESC""").fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get all azkar list error: {e}")
            return []
    
    def delete_azkar(self, item_id: int):
        try:
            conn = self.get_connection()
            conn.execute("DELETE FROM azkar_data WHERE id=?", (item_id,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Delete azkar error: {e}")
            return False

    # ========== Advanced Professional Scheduling System ==========
    
    # Ø®Ø±ÙŠØ·Ø© Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù„Ù„ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ù†ØµÙˆØµ
    WEEKDAYS_MAP = {
        0: "Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†",
        1: "Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡", 
        2: "Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡",
        3: "Ø§Ù„Ø®Ù…ÙŠØ³",
        4: "Ø§Ù„Ø¬Ù…Ø¹Ø©",
        5: "Ø§Ù„Ø³Ø¨Øª",
        6: "Ø§Ù„Ø£Ø­Ø¯"
    }
    
    def add_advanced_task(self, task_name: str, task_type: str, target: str, 
                         content_type: str, file_id: str, text: str, entities: str,
                         run_time: str, start_date: str, end_date: str = None,
                         days_of_week: str = None, timezone: str = DEFAULT_TIMEZONE,
                         created_by: int = None, service: str = 'all') -> int:
        """Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙˆÙ„Ø© Ù…ØªÙ‚Ø¯Ù…Ø©"""
        try:
            conn = self.get_connection()
            c = conn.cursor()
            
            c.execute("""INSERT INTO scheduled_tasks 
                (task_name, task_type, target, content_type, file_id, text, entities,
                 service, run_time, start_date, end_date, days_of_week, timezone, 
                 validation_status, created_by, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)""",
                (task_name, task_type, target, content_type, file_id, text, entities,
                 service, run_time, start_date, end_date, days_of_week, timezone,
                 created_by, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
            
            task_id = c.lastrowid
            conn.commit()
            conn.close()
            logger.info(f"Advanced task created with ID: {task_id}")
            return task_id
        except Exception as e:
            logger.error(f"Add advanced task error: {e}")
            return None
    
    def validate_task(self, task_id: int) -> bool:
        """ØªØ£ÙƒÙŠØ¯ ÙˆØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ù…Ù‡Ù…Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©"""
        try:
            conn = self.get_connection()
            conn.execute("""UPDATE scheduled_tasks SET validation_status='validated', 
                        is_active=1 WHERE id=?""", (task_id,))
            conn.commit()
            conn.close()
            logger.info(f"Task {task_id} validated")
            return True
        except Exception as e:
            logger.error(f"Validate task error: {e}")
            return False
    
    def get_pending_tasks(self):
        """Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…ÙØµØ¯ÙÙ‘Ù‚Ø© Ø§Ù„ØªÙŠ ÙŠØ¬Ø¨ ØªÙ†ÙÙŠØ°Ù‡Ø§ Ø§Ù„Ø¢Ù†"""
        try:
            tz = pytz.timezone(DEFAULT_TIMEZONE)
            now = datetime.now(tz)
            current_time = now.strftime("%H:%M")
            current_date = now.strftime("%Y-%m-%d")
            current_weekday = now.weekday()  # 0=Monday, 6=Sunday
            
            # Check Maintenance Status
            afaq_maint = self.get_config('afaq_maintenance') == '1'
            alarms_maint = self.get_config('alarms_maintenance') == '1'
            wird_maint = self.get_config('wird_maintenance') == '1'

            conn = self.get_connection()
            c = conn.cursor()
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù†Ø´Ø·Ø© ÙˆØ§Ù„Ù…ÙØµØ¯ÙÙ‘Ù‚Ø©
            c.execute("""SELECT id, task_type, target, content_type, file_id, text, entities,
                        service, days_of_week, end_date, last_run
                        FROM scheduled_tasks 
                        WHERE is_active=1 
                        AND validation_status='validated'
                        AND run_time=? 
                        AND start_date <= ?
                        AND (end_date IS NULL OR end_date >= ?)""",
                     (current_time, current_date, current_date))
            
            tasks = c.fetchall()
            logger.info(f"ğŸ” get_pending_tasks: Found {len(tasks)} potential tasks for time={current_time}, date={current_date}")
            
            valid_tasks = []
            
            for task in tasks:
                task_id, task_type, _, _, _, _, _, service, days_of_week, end_date, last_run = task
                logger.debug(f"   Task #{task_id}: type={task_type}, end_date={end_date}, last_run={last_run}")
                
                # 1. Maintenance Mode Regulation
                if service == 'afaq' and afaq_maint: 
                    logger.debug(f"   Task #{task_id} skipped: afaq maintenance mode")
                    continue
                if service == 'alarms' and alarms_maint: continue
                if service == 'wird' and wird_maint: continue

                # 2. Duplicate Execution Check
                if last_run:
                    # Parse last_run (Naive) and convert to Timezone Aware for comparison OR compare dates only
                    # DB stores naive strftime("%Y-%m-%d %H:%M:%S"). 
                    # We assume DB time is roughly synced or we check the DATE part.
                    try:
                        last_run_dt = datetime.strptime(last_run, "%Y-%m-%d %H:%M:%S")
                        # Compare dates using the timezone-aware 'now' date
                        if last_run_dt.date() == now.date():
                            continue
                    except ValueError:
                        pass # if format error, re-run might happen but safer than crashing
                
                # 3. Schedule Type Logic
                if task_type == 'daily':
                    pass
                
                elif task_type == 'specific_days' and days_of_week:
                    import json
                    try:
                        selected_days = json.loads(days_of_week)
                        if current_weekday not in selected_days:
                            continue
                    except:
                        continue
                
                elif task_type == 'once' or task_type == 'one_time':
                    # Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© - Ø­Ø°Ù ÙÙˆØ±ÙŠ Ø¥Ø°Ø§ Ù†ÙÙØ°Øª
                    if last_run:
                        # Ø¥Ø°Ø§ Ù†ÙÙØ°Øª Ù…Ù† Ù‚Ø¨Ù„ØŒ Ø§Ø­Ø°ÙÙ‡Ø§ ÙˆØ£ÙˆÙ‚Ù Ø§Ù„ØªØ­Ù‚Ù‚
                        logger.info(f"   Task #{task_id} already executed on {last_run}, deleting...")
                        conn.execute("DELETE FROM scheduled_tasks WHERE id=?", (task_id,))
                        conn.commit()
                        continue
                    
                    # ÙˆØ¶Ø¹ Ø¹Ù„Ø§Ù…Ø© Ù…Ø¤Ù‚ØªØ© Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…ØªÙƒØ±Ø±
                    conn.execute(
                        "UPDATE scheduled_tasks SET last_run=? WHERE id=?",
                        (datetime.now().strftime("%Y-%m-%d %H:%M:%S"), task_id)
                    )
                    conn.commit()
                    
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯ (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹)
                    if end_date:
                        # end_date ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ù„ØªÙ†ÙÙŠØ°
                        if current_date != end_date:
                            # Ù„Ù… ÙŠØ­Ù† Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ø¹Ø¯ Ø£Ùˆ ÙØ§Øª
                            logger.debug(f"   Task #{task_id} skipped: scheduled for {end_date}, today is {current_date}")
                            continue
                        logger.info(f"   Task #{task_id} matched: scheduled for today ({end_date})")
                    # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ end_dateØŒ Ù†ÙØ°Ù‡Ø§ Ø§Ù„ÙŠÙˆÙ… (Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„Ø¥ØµØ¯Ø§Ø±Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©)
                
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ø¯Ø© Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© (Ù„Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø±Ù‰ ÙÙ‚Ø·)
                if end_date and task_type not in ['once', 'one_time'] and end_date < current_date:
                    # Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù†ØªÙ‡Øª Ù…Ø¯ØªÙ‡Ø§
                    logger.info(f"   Task #{task_id} expired and deleting...")
                    conn.execute("DELETE FROM scheduled_tasks WHERE id=?", (task_id,))
                    conn.commit()
                    logger.info(f"Task #{task_id} expired and deleted")
                    continue

                valid_tasks.append(task)
                logger.info(f"   âœ… Task #{task_id} validated and will be executed")
            
            conn.close()
            logger.info(f"âœ… get_pending_tasks: Returning {len(valid_tasks)} valid tasks")
            return valid_tasks
            
        except Exception as e:
            logger.error(f"Get pending tasks error: {e}")
            return []
    
    def mark_task_executed(self, task_id, targets_count=0):
        """ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ†ÙÙŠØ° ÙˆØ­Ø°Ù Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ù† Ù†ÙˆØ¹ once"""
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ù‡Ù…Ø©
            task_type = conn.execute("SELECT task_type FROM scheduled_tasks WHERE id=?", (task_id,)).fetchone()
            
            if task_type and task_type[0] in ['once', 'one_time']:
                # Ø­Ø°Ù ÙÙˆØ±ÙŠ Ù„Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ù† Ù†ÙˆØ¹ once
                conn.execute("DELETE FROM scheduled_tasks WHERE id=?", (task_id,))
                logger.info(f"âœ… Task #{task_id} (type: once) executed and DELETED")
            else:
                # ØªØ­Ø¯ÙŠØ« Ø¹Ø§Ø¯ÙŠ Ù„Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…ØªÙƒØ±Ø±Ø©
                conn.execute("""UPDATE scheduled_tasks 
                              SET last_run = ?, 
                                  run_count = run_count + 1,
                                  total_targets = total_targets + ? 
                              WHERE id = ?""",
                            (now, targets_count, task_id))
            
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Mark task executed error: {e}")
    
    def deactivate_task(self, task_id: int):
        """ØªØ¹Ø·ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© ÙÙˆØ±Ø§Ù‹"""
        try:
            conn = self.get_connection()
            # Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØªØ¹Ø·ÙŠÙ„Ù‡Ø§ ÙÙ‚Ø·
            conn.execute("DELETE FROM scheduled_tasks WHERE id = ?", (task_id,))
            conn.commit()
            conn.close()
            logger.info(f"Task {task_id} deleted completely")
            return True
        except Exception as e:
            logger.error(f"Deactivate task error: {e}")
            return False
    
    def cleanup_expired_tasks(self):
        """Ø­Ø°Ù Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© ÙˆØ§Ù„Ù…Ù„ØºØ§Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"""
        try:
            conn = self.get_connection()
            c = conn.cursor()
            today = datetime.now().strftime("%Y-%m-%d")
            
            # Ø­Ø°Ù Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ù„ØºØ§Ø©
            c.execute("DELETE FROM scheduled_tasks WHERE validation_status = 'cancelled'")
            cancelled_count = c.rowcount
            
            # Ø­Ø°Ù Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© (Ø§Ù„ØªÙŠ Ø§Ù†ØªÙ‡Øª Ù…Ø¯ØªÙ‡Ø§)
            c.execute("DELETE FROM scheduled_tasks WHERE end_date IS NOT NULL AND end_date < ?", (today,))
            expired_count = c.rowcount
            
            # Ø­Ø°Ù Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„ØªÙŠ ØªÙ…Øª Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙˆØ§Ù†ØªÙ‡Øª
            c.execute("DELETE FROM scheduled_tasks WHERE task_type = 'once' AND is_active = 0")
            once_count = c.rowcount
            
            conn.commit()
            conn.close()
            
            if cancelled_count or expired_count or once_count:
                logger.info(f"Cleanup: deleted {cancelled_count} cancelled, {expired_count} expired, {once_count} completed-once tasks")
            
            return cancelled_count + expired_count + once_count
        except Exception as e:
            logger.error(f"Cleanup expired tasks error: {e}")
            return 0
    
    def get_active_tasks_only(self):
        """Ø¬Ù„Ø¨ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø© ÙÙ‚Ø· (Ù„ÙŠØ³Øª Ù…Ù„ØºØ§Ø© ÙˆÙ„Ù… ØªÙ†ØªÙ‡)"""
        try:
            conn = self.get_connection()
            today = datetime.now().strftime("%Y-%m-%d")
            result = conn.execute("""
                  SELECT id, task_name, task_type, target, start_date, end_date, 
                      run_time, is_active, validation_status, run_count, created_at, service
                FROM scheduled_tasks 
                WHERE is_active = 1 
                  AND validation_status = 'validated'
                  AND (end_date IS NULL OR end_date >= ?)
                ORDER BY id DESC
            """, (today,)).fetchall()
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get active tasks only error: {e}")
            return []

    def update_task_time(self, task_id: int, new_time: str) -> bool:
        try:
            conn = self.get_connection()
            conn.execute("UPDATE scheduled_tasks SET run_time=? WHERE id=?", (new_time, task_id))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Update task time error: {e}")
            return False
    
    def get_manual_tasks_list(self, active_only=False):
        """Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ - ÙÙ‚Ø· Ø§Ù„Ù†Ø´Ø·Ø© Ø§Ù„ØªÙŠ Ù„Ù… ØªÙ†ØªÙ‡ ÙˆÙ„Ù… ØªÙÙ„ØºÙ"""
        try:
            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ù„ØºØ§Ø© ÙˆØ§Ù„Ù…Ù†ØªÙ‡ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
            self.cleanup_expired_tasks()
            
            conn = self.get_connection()
            today = datetime.now().strftime("%Y-%m-%d")
            
            if active_only:
                sql = """SELECT id, task_name, task_type, target, start_date, end_date, 
                                                run_time, is_active, validation_status, run_count, created_at, service
                        FROM scheduled_tasks 
                        WHERE is_active=1 AND validation_status='validated'
                          AND (end_date IS NULL OR end_date >= ?)
                        ORDER BY id DESC"""
                result = conn.execute(sql, (today,)).fetchall()
            else:
                # Ø­ØªÙ‰ Ø¹Ù†Ø¯ Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„ØŒ Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„ØºØ§Ø© Ø£Ùˆ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
                sql = """SELECT id, task_name, task_type, target, start_date, end_date, 
                                                run_time, is_active, validation_status, run_count, created_at, service
                        FROM scheduled_tasks 
                        WHERE validation_status != 'cancelled'
                          AND (end_date IS NULL OR end_date >= ?)
                        ORDER BY id DESC"""
                result = conn.execute(sql, (today,)).fetchall()
            
            conn.close()
            return result
        except Exception as e:
            logger.error(f"Get manual tasks list error: {e}")
            return []

    # ========== Broadcast ==========
    def get_broadcast_targets(self, target_type, only_active=True, service_filter='all'):
        """ğŸ”¥ Ø§Ù„Ø­Ù„ Ø§Ù„Ø¬Ø°Ø±ÙŠ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ - Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø¯Ù‚Ø© 100%"""
        conn = self.get_connection()
        ids = []
        
        try:
            # ğŸ¯ Ù‚Ø±Ø§Ø¡Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
            if target_type in ["Ø§Ù„ÙƒÙ„", "all"]:
                # Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†
                if only_active:
                    users = conn.execute("SELECT user_id FROM users WHERE status='active'").fetchall()
                    chats = conn.execute("SELECT chat_id FROM chats WHERE status='active'").fetchall()
                else:
                    users = conn.execute("SELECT user_id FROM users").fetchall()
                    chats = conn.execute("SELECT chat_id FROM chats").fetchall()
                
                ids = [x[0] for x in users] + [x[0] for x in chats]
                logger.info(f"âœ… Broadcast targets: Ø§Ù„ÙƒÙ„ = {len(ids)} ({len(users)} users + {len(chats)} chats)")
                
            elif target_type in ["Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", "users"]:
                # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙ‚Ø·
                if only_active:
                    users = conn.execute("SELECT user_id FROM users WHERE status='active'").fetchall()
                else:
                    users = conn.execute("SELECT user_id FROM users").fetchall()
                
                ids = [x[0] for x in users]
                logger.info(f"âœ… Broadcast targets: Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† = {len(ids)} users")
                
            elif target_type in ["Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", "groups"]:
                # Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙ‚Ø·
                if only_active:
                    groups = conn.execute("SELECT chat_id FROM chats WHERE type IN ('group', 'supergroup') AND status='active'").fetchall()
                else:
                    groups = conn.execute("SELECT chat_id FROM chats WHERE type IN ('group', 'supergroup')").fetchall()
                
                ids = [x[0] for x in groups]
                logger.info(f"âœ… Broadcast targets: Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª = {len(ids)} groups")
                
            elif target_type in ["Ø§Ù„Ù‚Ù†ÙˆØ§Øª", "channels"]:
                # Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙÙ‚Ø·
                if only_active:
                    channels = conn.execute("SELECT chat_id FROM chats WHERE type='channel' AND status='active'").fetchall()
                else:
                    channels = conn.execute("SELECT chat_id FROM chats WHERE type='channel'").fetchall()
                
                ids = [x[0] for x in channels]
                logger.info(f"âœ… Broadcast targets: Ø§Ù„Ù‚Ù†ÙˆØ§Øª = {len(ids)} channels")
                
            elif target_type in ["Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", "channels_groups"]:
                # Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
                if only_active:
                    chats = conn.execute("SELECT chat_id FROM chats WHERE type IN ('channel', 'group', 'supergroup') AND status='active'").fetchall()
                else:
                    chats = conn.execute("SELECT chat_id FROM chats WHERE type IN ('channel', 'group', 'supergroup')").fetchall()
                
                ids = [x[0] for x in chats]
                logger.info(f"âœ… Broadcast targets: Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª = {len(ids)} chats")
            
            # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
            ids = list(set(ids))
            logger.info(f"ğŸ¯ Final broadcast targets after dedup: {len(ids)}")
            
        except Exception as e:
            logger.error(f"âŒ Get broadcast targets error: {e}", exc_info=True)
        finally:
            conn.close()
        
        return ids

    def log_broadcast(self, name, preview, target_type, success, failed, admin_id, service='manual'):
        """ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
        Args:
            name: Ø§Ø³Ù… Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©
            preview: Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
            target_type: Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¯Ù (Ø§Ù„ÙƒÙ„ØŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†ØŒ Ø§Ù„Ù‚Ù†ÙˆØ§ØªØŒ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª)
            success: Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Ø§Ø¬Ø­Ø©
            failed: Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙØ§Ø´Ù„Ø©
            admin_id: Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø´Ø±Ù
            service: Ù†ÙˆØ¹ Ø§Ù„Ø®Ø¯Ù…Ø© (manual Ø£Ùˆ scheduled)
        """
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            conn.execute("""INSERT INTO broadcast_history 
                (broadcast_name, content_preview, target_type, sent_count, failed_count, sent_at, admin_id, service)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                (name, preview, target_type, success, failed, now, admin_id, service))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Log broadcast error: {e}")

    # ========== Contact Messages ==========
    def save_contact_message(self, user_id, username, message_id, content_type, text, file_id):
        try:
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = self.get_connection()
            conn.execute("""INSERT INTO contact_messages 
                (from_user_id, from_username, message_id, content_type, content, file_id, sent_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (user_id, username, message_id, content_type, text, file_id, now))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logger.error(f"Save contact message error: {e}")
            return False

    def close(self):
        pass

# === Optimization for High Concurrency (10000+ users) ===
import threading
from concurrent.futures import ThreadPoolExecutor

# Thread pool for database operations
db_executor = ThreadPoolExecutor(max_workers=10, thread_name_prefix="db_")

# Caching system
_cache = {}
_cache_times = {}
_cache_lock = threading.RLock()

def get_cached(key, func, ttl=300):
    """Ø¬Ù„Ø¨ Ù…Ù† cache Ø£Ùˆ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯"""
    import time as time_module
    now = time_module.time()
    
    with _cache_lock:
        if key in _cache and (now - _cache_times.get(key, 0)) < ttl:
            return _cache[key]
        
        result = func()
        _cache[key] = result
        _cache_times[key] = now
        return result

# Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ DB_CONN ÙÙŠ main()
DB_CONN = None

def get_db():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ù…Ø­Ø³Ù‘Ù† Ù„Ù„Ø£Ø¯Ø§Ø¡"""
    return DB_CONN

# ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡: Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
def cleanup_db_connections():
    """ØªÙ†Ø¸ÙŠÙ Ø§ØªØµØ§Ù„Ø§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©"""
    try:
        db = get_db()
        # ÙÙ‚Ø· Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø§ØªØµØ§Ù„ ÙŠØ¹Ù…Ù„
        db.get_connection().close()
    except:
        pass

# ==========================================
# Quran Data - All 114 Surahs
# ==========================================

QURAN_SURAHS = [
    "Ø§Ù„ÙØ§ØªØ­Ø©", "Ø§Ù„Ø¨Ù‚Ø±Ø©", "Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†", "Ø§Ù„Ù†Ø³Ø§Ø¡", "Ø§Ù„Ù…Ø§Ø¦Ø¯Ø©",
    "Ø§Ù„Ø£Ù†Ø¹Ø§Ù…", "Ø§Ù„Ø£Ø¹Ø±Ø§Ù", "Ø§Ù„Ø£Ù†ÙØ§Ù„", "Ø§Ù„ØªÙˆØ¨Ø©", "ÙŠÙˆÙ†Ø³",
    "Ù‡ÙˆØ¯", "ÙŠÙˆØ³Ù", "Ø§Ù„Ø±Ø¹Ø¯", "Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…", "Ø§Ù„Ø­Ø¬Ø±",
    "Ø§Ù„Ù†Ø­Ù„", "Ø§Ù„Ø¥Ø³Ø±Ø§Ø¡", "Ø§Ù„ÙƒÙ‡Ù", "Ù…Ø±ÙŠÙ…", "Ø·Ù‡",
    "Ø§Ù„Ø£Ù†Ø¨ÙŠØ§Ø¡", "Ø§Ù„Ø­Ø¬", "Ø§Ù„Ù…Ø¤Ù…Ù†ÙˆÙ†", "Ø§Ù„Ù†ÙˆØ±", "Ø§Ù„ÙØ±Ù‚Ø§Ù†",
    "Ø§Ù„Ø´Ø¹Ø±Ø§Ø¡", "Ø§Ù„Ù†Ù…Ù„", "Ø§Ù„Ù‚ØµØµ", "Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª", "Ø§Ù„Ø±ÙˆÙ…",
    "Ù„Ù‚Ù…Ø§Ù†", "Ø§Ù„Ø³Ø¬Ø¯Ø©", "Ø§Ù„Ø£Ø­Ø²Ø§Ø¨", "Ø³Ø¨Ø£", "ÙØ§Ø·Ø±",
    "ÙŠØ³", "Ø§Ù„ØµØ§ÙØ§Øª", "Øµ", "Ø§Ù„Ø²Ù…Ø±", "ØºØ§ÙØ±",
    "ÙØµÙ„Øª", "Ø§Ù„Ø´ÙˆØ±Ù‰", "Ø§Ù„Ø²Ø®Ø±Ù", "Ø§Ù„Ø¯Ø®Ø§Ù†", "Ø§Ù„Ø¬Ø§Ø«ÙŠØ©",
    "Ø§Ù„Ø£Ø­Ù‚Ø§Ù", "Ù…Ø­Ù…Ø¯", "Ø§Ù„ÙØªØ­", "Ø§Ù„Ø­Ø¬Ø±Ø§Øª", "Ù‚",
    "Ø§Ù„Ø°Ø§Ø±ÙŠØ§Øª", "Ø§Ù„Ø·ÙˆØ±", "Ø§Ù„Ù†Ø¬Ù…", "Ø§Ù„Ù‚Ù…Ø±", "Ø§Ù„Ø±Ø­Ù…Ù†",
    "Ø§Ù„ÙˆØ§Ù‚Ø¹Ø©", "Ø§Ù„Ø­Ø¯ÙŠØ¯", "Ø§Ù„Ù…Ø¬Ø§Ø¯Ù„Ø©", "Ø§Ù„Ø­Ø´Ø±", "Ø§Ù„Ù…Ù…ØªØ­Ù†Ø©",
    "Ø§Ù„ØµÙ", "Ø§Ù„Ø¬Ù…Ø¹Ø©", "Ø§Ù„Ù…Ù†Ø§ÙÙ‚ÙˆÙ†", "Ø§Ù„ØªØºØ§Ø¨Ù†", "Ø§Ù„Ø·Ù„Ø§Ù‚",
    "Ø§Ù„ØªØ­Ø±ÙŠÙ…", "Ø§Ù„Ù…Ù„Ùƒ", "Ø§Ù„Ù‚Ù„Ù…", "Ø§Ù„Ø­Ø§Ù‚Ø©", "Ø§Ù„Ù…Ø¹Ø§Ø±Ø¬",
    "Ù†ÙˆØ­", "Ø§Ù„Ø¬Ù†", "Ø§Ù„Ù…Ø²Ù…Ù„", "Ø§Ù„Ù…Ø¯Ø«Ø±", "Ø§Ù„Ù‚ÙŠØ§Ù…Ø©",
    "Ø§Ù„Ø¥Ù†Ø³Ø§Ù†", "Ø§Ù„Ù…Ø±Ø³Ù„Ø§Øª", "Ø§Ù„Ù†Ø¨Ø£", "Ø§Ù„Ù†Ø§Ø²Ø¹Ø§Øª", "Ø¹Ø¨Ø³",
    "Ø§Ù„ØªÙƒÙˆÙŠØ±", "Ø§Ù„Ø§Ù†ÙØ·Ø§Ø±", "Ø§Ù„Ù…Ø·ÙÙÙŠÙ†", "Ø§Ù„Ø§Ù†Ø´Ù‚Ø§Ù‚", "Ø§Ù„Ø¨Ø±ÙˆØ¬",
    "Ø§Ù„Ø·Ø§Ø±Ù‚", "Ø§Ù„Ø£Ø¹Ù„Ù‰", "Ø§Ù„ØºØ§Ø´ÙŠØ©", "Ø§Ù„ÙØ¬Ø±", "Ø§Ù„Ø¨Ù„Ø¯",
    "Ø§Ù„Ø´Ù…Ø³", "Ø§Ù„Ù„ÙŠÙ„", "Ø§Ù„Ø¶Ø­Ù‰", "Ø§Ù„Ø´Ø±Ø­", "Ø§Ù„ØªÙŠÙ†",
    "Ø§Ù„Ø¹Ù„Ù‚", "Ø§Ù„Ù‚Ø¯Ø±", "Ø§Ù„Ø¨ÙŠÙ†Ø©", "Ø§Ù„Ø²Ù„Ø²Ù„Ø©", "Ø§Ù„Ø¹Ø§Ø¯ÙŠØ§Øª",
    "Ø§Ù„Ù‚Ø§Ø±Ø¹Ø©", "Ø§Ù„ØªÙƒØ§Ø«Ø±", "Ø§Ù„Ø¹ØµØ±", "Ø§Ù„Ù‡Ù…Ø²Ø©", "Ø§Ù„ÙÙŠÙ„",
    "Ù‚Ø±ÙŠØ´", "Ø§Ù„Ù…Ø§Ø¹ÙˆÙ†", "Ø§Ù„ÙƒÙˆØ«Ø±", "Ø§Ù„ÙƒØ§ÙØ±ÙˆÙ†", "Ø§Ù„Ù†ØµØ±",
    "Ø§Ù„Ù…Ø³Ø¯", "Ø§Ù„Ø¥Ø®Ù„Ø§Øµ", "Ø§Ù„ÙÙ„Ù‚", "Ø§Ù„Ù†Ø§Ø³"
]

# ==========================================
# Quran APIs (Fixed & Enhanced)
# ==========================================

class QuranAPI:
    def __init__(self):
        self.base_url = "https://api.alquran.cloud/v1"
        self.qurancom_api = "https://api.quran.com/api/v4"
        self._surah_names = self._init_surah_names()
        self._surah_verses = self._init_surah_verses()
        
    def _init_surah_names(self):
        return {
            1: "Ø§Ù„ÙØ§ØªØ­Ø©", 2: "Ø§Ù„Ø¨Ù‚Ø±Ø©", 3: "Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†", 4: "Ø§Ù„Ù†Ø³Ø§Ø¡", 5: "Ø§Ù„Ù…Ø§Ø¦Ø¯Ø©",
            6: "Ø§Ù„Ø£Ù†Ø¹Ø§Ù…", 7: "Ø§Ù„Ø£Ø¹Ø±Ø§Ù", 8: "Ø§Ù„Ø£Ù†ÙØ§Ù„", 9: "Ø§Ù„ØªÙˆØ¨Ø©", 10: "ÙŠÙˆÙ†Ø³",
            11: "Ù‡ÙˆØ¯", 12: "ÙŠÙˆØ³Ù", 13: "Ø§Ù„Ø±Ø¹Ø¯", 14: "Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…", 15: "Ø§Ù„Ø­Ø¬Ø±",
            16: "Ø§Ù„Ù†Ø­Ù„", 17: "Ø§Ù„Ø¥Ø³Ø±Ø§Ø¡", 18: "Ø§Ù„ÙƒÙ‡Ù", 19: "Ù…Ø±ÙŠÙ…", 20: "Ø·Ù‡",
            21: "Ø§Ù„Ø£Ù†Ø¨ÙŠØ§Ø¡", 22: "Ø§Ù„Ø­Ø¬", 23: "Ø§Ù„Ù…Ø¤Ù…Ù†ÙˆÙ†", 24: "Ø§Ù„Ù†ÙˆØ±", 25: "Ø§Ù„ÙØ±Ù‚Ø§Ù†",
            26: "Ø§Ù„Ø´Ø¹Ø±Ø§Ø¡", 27: "Ø§Ù„Ù†Ù…Ù„", 28: "Ø§Ù„Ù‚ØµØµ", 29: "Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª", 30: "Ø§Ù„Ø±ÙˆÙ…",
            31: "Ù„Ù‚Ù…Ø§Ù†", 32: "Ø§Ù„Ø³Ø¬Ø¯Ø©", 33: "Ø§Ù„Ø£Ø­Ø²Ø§Ø¨", 34: "Ø³Ø¨Ø£", 35: "ÙØ§Ø·Ø±",
            36: "ÙŠØ³", 37: "Ø§Ù„ØµØ§ÙØ§Øª", 38: "Øµ", 39: "Ø§Ù„Ø²Ù…Ø±", 40: "ØºØ§ÙØ±",
            41: "ÙØµÙ„Øª", 42: "Ø§Ù„Ø´ÙˆØ±Ù‰", 43: "Ø§Ù„Ø²Ø®Ø±Ù", 44: "Ø§Ù„Ø¯Ø®Ø§Ù†", 45: "Ø§Ù„Ø¬Ø§Ø«ÙŠØ©",
            46: "Ø§Ù„Ø£Ø­Ù‚Ø§Ù", 47: "Ù…Ø­Ù…Ø¯", 48: "Ø§Ù„ÙØªØ­", 49: "Ø§Ù„Ø­Ø¬Ø±Ø§Øª", 50: "Ù‚",
            51: "Ø§Ù„Ø°Ø§Ø±ÙŠØ§Øª", 52: "Ø§Ù„Ø·ÙˆØ±", 53: "Ø§Ù„Ù†Ø¬Ù…", 54: "Ø§Ù„Ù‚Ù…Ø±", 55: "Ø§Ù„Ø±Ø­Ù…Ù†",
            56: "Ø§Ù„ÙˆØ§Ù‚Ø¹Ø©", 57: "Ø§Ù„Ø­Ø¯ÙŠØ¯", 58: "Ø§Ù„Ù…Ø¬Ø§Ø¯Ù„Ø©", 59: "Ø§Ù„Ø­Ø´Ø±", 60: "Ø§Ù„Ù…Ù…ØªØ­Ù†Ø©",
            61: "Ø§Ù„ØµÙ", 62: "Ø§Ù„Ø¬Ù…Ø¹Ø©", 63: "Ø§Ù„Ù…Ù†Ø§ÙÙ‚ÙˆÙ†", 64: "Ø§Ù„ØªØºØ§Ø¨Ù†", 65: "Ø§Ù„Ø·Ù„Ø§Ù‚",
            66: "Ø§Ù„ØªØ­Ø±ÙŠÙ…", 67: "Ø§Ù„Ù…Ù„Ùƒ", 68: "Ø§Ù„Ù‚Ù„Ù…", 69: "Ø§Ù„Ø­Ø§Ù‚Ø©", 70: "Ø§Ù„Ù…Ø¹Ø§Ø±Ø¬",
            71: "Ù†ÙˆØ­", 72: "Ø§Ù„Ø¬Ù†", 73: "Ø§Ù„Ù…Ø²Ù…Ù„", 74: "Ø§Ù„Ù…Ø¯Ø«Ø±", 75: "Ø§Ù„Ù‚ÙŠØ§Ù…Ø©",
            76: "Ø§Ù„Ø¥Ù†Ø³Ø§Ù†", 77: "Ø§Ù„Ù…Ø±Ø³Ù„Ø§Øª", 78: "Ø§Ù„Ù†Ø¨Ø£", 79: "Ø§Ù„Ù†Ø§Ø²Ø¹Ø§Øª", 80: "Ø¹Ø¨Ø³",
            81: "Ø§Ù„ØªÙƒÙˆÙŠØ±", 82: "Ø§Ù„Ø§Ù†ÙØ·Ø§Ø±", 83: "Ø§Ù„Ù…Ø·ÙÙÙŠÙ†", 84: "Ø§Ù„Ø§Ù†Ø´Ù‚Ø§Ù‚", 85: "Ø§Ù„Ø¨Ø±ÙˆØ¬",
            86: "Ø§Ù„Ø·Ø§Ø±Ù‚", 87: "Ø§Ù„Ø£Ø¹Ù„Ù‰", 88: "Ø§Ù„ØºØ§Ø´ÙŠØ©", 89: "Ø§Ù„ÙØ¬Ø±", 90: "Ø§Ù„Ø¨Ù„Ø¯",
            91: "Ø§Ù„Ø´Ù…Ø³", 92: "Ø§Ù„Ù„ÙŠÙ„", 93: "Ø§Ù„Ø¶Ø­Ù‰", 94: "Ø§Ù„Ø´Ø±Ø­", 95: "Ø§Ù„ØªÙŠÙ†",
            96: "Ø§Ù„Ø¹Ù„Ù‚", 97: "Ø§Ù„Ù‚Ø¯Ø±", 98: "Ø§Ù„Ø¨ÙŠÙ†Ø©", 99: "Ø§Ù„Ø²Ù„Ø²Ù„Ø©", 100: "Ø§Ù„Ø¹Ø§Ø¯ÙŠØ§Øª",
            101: "Ø§Ù„Ù‚Ø§Ø±Ø¹Ø©", 102: "Ø§Ù„ØªÙƒØ§Ø«Ø±", 103: "Ø§Ù„Ø¹ØµØ±", 104: "Ø§Ù„Ù‡Ù…Ø²Ø©", 105: "Ø§Ù„ÙÙŠÙ„",
            106: "Ù‚Ø±ÙŠØ´", 107: "Ø§Ù„Ù…Ø§Ø¹ÙˆÙ†", 108: "Ø§Ù„ÙƒÙˆØ«Ø±", 109: "Ø§Ù„ÙƒØ§ÙØ±ÙˆÙ†", 110: "Ø§Ù„Ù†ØµØ±",
            111: "Ø§Ù„Ù…Ø³Ø¯", 112: "Ø§Ù„Ø¥Ø®Ù„Ø§Øµ", 113: "Ø§Ù„ÙÙ„Ù‚", 114: "Ø§Ù„Ù†Ø§Ø³"
        }

    def _init_surah_verses(self):
        return {
            1: 7, 2: 286, 3: 200, 4: 176, 5: 120, 6: 165, 7: 206, 8: 75, 9: 129, 10: 109,
            11: 123, 12: 111, 13: 43, 14: 52, 15: 99, 16: 128, 17: 111, 18: 110, 19: 98, 20: 135,
            21: 112, 22: 78, 23: 118, 24: 64, 25: 77, 26: 227, 27: 93, 28: 88, 29: 69, 30: 60,
            31: 34, 32: 30, 33: 73, 34: 54, 35: 45, 36: 83, 37: 182, 38: 88, 39: 75, 40: 85,
            41: 54, 42: 53, 43: 89, 44: 59, 45: 37, 46: 35, 47: 38, 48: 29, 49: 18, 50: 45,
            51: 60, 52: 49, 53: 62, 54: 55, 55: 78, 56: 96, 57: 29, 58: 22, 59: 24, 60: 13,
            61: 14, 62: 11, 63: 11, 64: 18, 65: 12, 66: 12, 67: 30, 68: 52, 69: 52, 70: 44,
            71: 28, 72: 28, 73: 20, 74: 56, 75: 40, 76: 31, 77: 50, 78: 40, 79: 46, 80: 42,
            81: 29, 82: 19, 83: 36, 84: 25, 85: 22, 86: 17, 87: 19, 88: 26, 89: 30, 90: 20,
            91: 15, 92: 21, 93: 11, 94: 8, 95: 8, 96: 19, 97: 5, 98: 8, 99: 8, 100: 11,
            101: 11, 102: 8, 103: 3, 104: 9, 105: 5, 106: 4, 107: 7, 108: 3, 109: 6, 110: 3,
            111: 5, 112: 4, 113: 5, 114: 6
        }
    
    def _normalize_arabic(self, text):
        if not text: return ""
        text = re.sub(r'[Ù‹-Ù’Ù°]', '', text)
        text = re.sub(r'[Ø¥Ø£Ø¢Ø§]', 'Ø§', text)
        text = re.sub(r'[Ø¤]', 'Ùˆ', text)
        text = re.sub(r'[Ø¦]', 'ÙŠ', text)
        text = re.sub(r'[Ø©]', 'Ù‡', text)
        text = re.sub(r'[Ù‰]', 'ÙŠ', text)
        return re.sub(r'\s+', ' ', text).strip().lower()

    def search_quran(self, query, page=1, per_page=10):
        query = query.strip()
        if not query or len(query) < 2: return self._empty_result(query)
        
        if ':' in query or re.match(r'^\d+\s+\d+$', query):
            verse_result = self._search_by_verse_number(query)
            if verse_result: return verse_result
            
        results = self._search_text_advanced(query)
        if results: return self._paginate_results(results, query, page, per_page)
        return self._empty_result(query)

    def _search_by_verse_number(self, query):
        try:
            query = query.replace(':', ' ').replace('-', ' ')
            parts = query.split()
            if len(parts) >= 2:
                surah_num = int(parts[0].strip())
                ayah_num = int(parts[1].strip())
                if 1 <= surah_num <= 114:
                    max_ayah = self._surah_verses.get(surah_num, 286)
                    if 1 <= ayah_num <= max_ayah:
                        verse_data = self._get_verse_with_uthmani(surah_num, ayah_num)
                        if verse_data:
                            return {
                                'results': [{
                                    'surah': surah_num, 'ayah': ayah_num,
                                    'text': verse_data['text'],
                                    'surah_name': verse_data['surah_name'],
                                    'surah_english_name': verse_data.get('surah_english', ''),
                                    'juz': verse_data.get('juz', ''), 'page': verse_data.get('page', '')
                                }],
                                'total': 1, 'page': 1, 'total_pages': 1,
                                'query': f"{surah_num}:{ayah_num}", 'has_more': False, 'search_type': 'verse_number'
                            }
        except: pass
        return None

    def _search_text_advanced(self, query):
        results = []
        try:
            import urllib.parse
            clean_query = self._normalize_arabic(query) or query.strip()
            encoded_query = urllib.parse.quote(clean_query)
            search_url = f"{self.base_url}/search/{encoded_query}/all/quran-simple-clean"  
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}
            resp = requests.get(search_url, timeout=15, headers=headers)
            if resp.status_code == 200:
                data = resp.json()
                if data.get('status') == 'OK':
                    matches = data.get('data', {}).get('matches', [])
                    for match in matches:
                        try:
                            surah_num = match['surah']['number']
                            ayah_num = match['numberInSurah']
                            text = match.get('text', '')
                            results.append({
                                'surah': surah_num, 'ayah': ayah_num, 'text': text,
                                'surah_name': match['surah']['name'],
                                'surah_english_name': match['surah'].get('englishName', ''),
                                'juz': match.get('juz', ''), 'page': match.get('page', ''),
                            })
                        except: continue
        except Exception as e:
            logger.error(f"Search error: {e}")
        results.sort(key=lambda x: (x['surah'], x['ayah']))
        return results

    def _paginate_results(self, results, query, page, per_page, search_type='text'):
        unique_results = []
        seen = set()
        for r in results:
            key = f"{r['surah']}:{r['ayah']}"
            if key not in seen:
                seen.add(key)
                unique_results.append(r)
        total = len(unique_results)
        total_pages = max(1, (total + per_page - 1) // per_page) if total else 0
        start = (page - 1) * per_page
        end = start + per_page
        return {
            'results': unique_results[start:end], 'total': total, 'page': page,
            'total_pages': total_pages, 'query': query,
            'has_more': page < total_pages, 'search_type': search_type
        }

    def _empty_result(self, query):
        return {'results': [], 'total': 0, 'page': 1, 'total_pages': 0, 'query': query, 'has_more': False, 'search_type': 'empty'}

    def _get_verse_with_uthmani(self, surah, ayah):
        # Try quran.com first (better Uthmani)
        try:
            url = f"{self.qurancom_api}/quran/verses/uthmani"
            params = {'chapter_number': surah, 'verse_key': f"{surah}:{ayah}"}
            resp = requests.get(url, params=params, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                verse = data['verses'][0]
                text_uthmani = verse['text_uthmani']
                chapters_url = f"{self.qurancom_api}/chapters/{surah}"
                chap_resp = requests.get(chapters_url, timeout=10)
                if chap_resp.status_code == 200:
                    chap_data = chap_resp.json()['chapter']
                    return {
                        'text': text_uthmani,
                        'surah_name': chap_data['name_arabic'],
                        'surah_english': chap_data['name_simple'],
                        'juz': verse.get('juz_number'),
                        'page': verse.get('page_number')
                    }
        except: pass
        
        # Fallback to alquran.cloud
        try:
            url = f"{self.base_url}/ayah/{surah}:{ayah}/ar.alafasy"
            resp = requests.get(url, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                if data.get('code') == 200 and 'data' in data:
                    v = data['data']
                    return {
                        'text': v.get('text', ''),
                        'surah_name': v['surah'].get('name', f'Ø³ÙˆØ±Ø© {surah}'),
                        'surah_english': v['surah'].get('englishName', ''),
                        'juz': v.get('juz', ''), 'page': v.get('page', '')
                    }
        except: pass
        return None

    def get_ayah_with_tafsir(self, surah: int, ayah: int) -> Optional[Dict]:
        try:
            verse_data = self._get_verse_with_uthmani(surah, ayah)
            if not verse_data: return None
            tafasir = self._get_tafasir_from_api(surah, ayah)
            return {
                'text': verse_data['text'], 
                'surah_name': verse_data['surah_name'],
                'surah': surah,
                'ayah': ayah,
                'surah_english': verse_data.get('surah_english', ''),
                'juz': verse_data.get('juz', ''), 'page': verse_data.get('page', ''),
                **tafasir
            }
        except: return None

    def _get_tafasir_from_api(self, surah, ayah):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ù…Ù† quran.com API"""
        tafasir_list = []
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
        
        # Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù…Ù‡Ø§
        tafsir_sources = {
            'ØªÙØ³ÙŠØ± Ø§Ù„Ø¬Ù„Ø§Ù„ÙŠÙ†': 169,
            'Ø§Ù„ØªÙØ³ÙŠØ± Ø§Ù„Ù…ÙŠØ³Ø±': 171,
            'ØªÙØ³ÙŠØ± Ø§Ù„Ø³Ø¹Ø¯ÙŠ': 170,
            'ØªÙØ³ÙŠØ± Ø§Ø¨Ù† ÙƒØ«ÙŠØ±': 168,
            'ØªÙØ³ÙŠØ± Ø§Ù„Ø·Ø¨Ø±ÙŠ': 167,
            'ØªÙØ³ÙŠØ± Ø§Ù„Ù‚Ø±Ø·Ø¨ÙŠ': 164
        }
        
        for tafsir_name, tafsir_id in tafsir_sources.items():
            try:
                # Ø§Ø³ØªØ®Ø¯Ø§Ù… API Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ù† quran.com
                url = f"https://api.qurancdn.com/api/qdc/tafsirs/{tafsir_id}/by_ayah/{surah}:{ayah}"
                resp = requests.get(url, timeout=10, headers=headers)
                
                if resp.status_code == 200:
                    data = resp.json()
                    tafsir_text = data.get("tafsir", {}).get("text", "")
                    
                    if tafsir_text:
                        # ØªÙ†Ø¸ÙŠÙ HTML
                        tafsir_text = re.sub(r'<[^>]+>', '', tafsir_text).strip()
                        tafasir_list.append({
                            'name': tafsir_name,
                            'id': tafsir_id,
                            'text': tafsir_text
                        })
            except Exception as e:
                logger.debug(f"Failed to fetch {tafsir_name}: {e}")
                continue
        
        return {'tafasir': tafasir_list}

    def get_random_ayah_strict(self):
        for _ in range(10):
            surah = random.randint(1, 114)
            count = self._surah_verses.get(surah, 286)
            ayah = random.randint(1, count)
            if anti_dup.add_quran(surah, ayah):
                res = self.get_ayah_with_tafsir(surah, ayah)
                if res: return res
                anti_dup.recent_quran.discard(f"{surah}:{ayah}")
            else:
                anti_dup.clear_quran()
        return None

    def _get_surah_name(self, surah_num: int) -> str:
        return self._surah_names.get(surah_num, f"Ø§Ù„Ø³ÙˆØ±Ø© {surah_num}")

# Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù† Ù‡Ù†Ø§ - Ø¨Ø¹Ø¯ ØªØ¹Ø±ÙŠÙ Ø§Ù„ÙƒÙ„Ø§Ø³ Ù…Ø¨Ø§Ø´Ø±Ø©
quran_api = QuranAPI()

# ==========================================
# Reply Keyboards (Advanced)
# ==========================================
# Keyboard Helper Functions
# ==========================================

def get_main_kb(uid, is_admin: bool = False):
    """Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø¨ÙˆØª"""
    keyboard = [
        [types.KeyboardButton(text="Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª")],
        [types.KeyboardButton(text="Ø­Ø¯ÙŠØ« Ø´Ø±ÙŠÙ"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…")],
        [types.KeyboardButton(text="Ø§Ù„Ù…Ø³Ø¨Ø­Ø©"), types.KeyboardButton(text="Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ©")],
        [types.KeyboardButton(text="ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§")]
    ]
    
    # Ø¥Ø¶Ø§ÙØ© Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
    if is_admin:
        keyboard.append([types.KeyboardButton(text="Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…")])
    
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def ensure_keyboard(message: types.Message, is_admin: bool = False):
    """Ø¯Ø§Ù„Ø© Ù„Ø¶Ù…Ø§Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¨Ø¹Ø¯ Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ©"""
    return get_main_kb(message.from_user.id, is_admin)

def get_common_service_btns(is_admin=False):
    """
    Ø£Ø²Ø±Ø§Ø± Ù…Ø´ØªØ±ÙƒØ© (ØªÙˆØ§ØµÙ„ ÙÙ‚Ø· Ø§Ù„Ø¢Ù† Ø¨Ø¹Ø¯ ÙØµÙ„ Ø²Ø± Ø§Ù„Ø¥Ø¶Ø§ÙØ©)
    """
    db = get_db()
    
    # Ø²Ø± ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§
    system_btns = db.get_system_buttons(for_admin=False)
    
    # ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø²Ø± "ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§" Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„ÙØ±Ø¹ÙŠØ©
    # ÙˆÙ†Ø¹ÙŠØ¯ ÙÙ‚Ø· Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø®ØµØµØ© Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª
    
    custom_btns = db.get_root_buttons()
    result_btns = []
    
    for _, btn_name in custom_btns:
         result_btns.append(types.KeyboardButton(text=btn_name))
         
    return result_btns

def get_afaq_kb(user_id=None):
    """
    Ù‚Ø§Ø¦Ù…Ø© Ø¨ÙˆØª Ø¢ÙØ§Ù‚ (Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¹Ø§Ù…)
    """
    db = get_db()
    
    keyboard = []
    seen = set()

    def add_btn(text: str) -> bool:
        if text in seen:
            return False
        seen.add(text)
        return True
    
    # 1. Ø²Ø± Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø£ÙˆÙ„Ø§Ù‹ Ø¯Ø§Ø¦Ù…Ø§Ù‹
    if add_btn("Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø¢ÙØ§Ù‚ Ù„Ù„Ù‚Ù†ÙˆØ§Øª"):
        keyboard.append([types.KeyboardButton(text="Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø¢ÙØ§Ù‚ Ù„Ù„Ù‚Ù†ÙˆØ§Øª")])
    
    # 2. Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£Ø®Ø±Ù‰ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ø¥Ù† ÙˆØ¬Ø¯Øª)
    system_btns = db.get_system_buttons(for_admin=False)
    rows_map = defaultdict(list)
    
    for btn_key, btn_name, icon, btn_order in system_btns:
        # ØªØ®Ø·ÙŠ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø­Ø°ÙˆÙØ© (Ù…Ø§Ø¹Ø¯Ø§ contact Ùˆ add_bot_help)
        if btn_key in ["quran", "azkar", "tasbih", "hadith"]:
            continue
        # ØªØ®Ø·ÙŠ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª ÙˆØ§Ù„ÙˆØ±Ø¯
        if any(k in btn_key.lower() for k in ['alarm', 'wird']) or any(n in btn_name for n in ['Ù…Ù†Ø¨Ù‡', 'ÙˆØ±Ø¯']):
            continue
        # ØªØ®Ø·ÙŠ Ø²Ø± Ø¢ÙØ§Ù‚ Ù†ÙØ³Ù‡
        if btn_key == 'afaq_bot' or btn_name in ['Ø¨ÙˆØª Ø¢ÙØ§Ù‚', 'ğŸ“¢ Ø¨ÙˆØª Ø¢ÙØ§Ù‚']:
            continue
            
        display_name = btn_name
        if add_btn(display_name):
            rows_map[btn_order].append(types.KeyboardButton(text=display_name))

    for order in sorted(rows_map.keys()):
        keyboard.append(rows_map[order])
    
    # 3. Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø®ØµØµØ©
    custom_btns = db.get_root_buttons()
    for btn_id, btn_name in custom_btns:
        if "ØªÙˆØ§ØµÙ„" in btn_name or "Ø§ØªØµÙ„" in btn_name or "contact" in btn_name.lower():
            continue
        if add_btn(btn_name):
            keyboard.append([types.KeyboardButton(text=btn_name)])
        

    # 4. Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø®Ø¯Ù…Ø©
    if add_btn("Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù†Ø´Ø± Ø¢ÙØ§Ù‚"):
        keyboard.append([types.KeyboardButton(text="Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù†Ø´Ø± Ø¢ÙØ§Ù‚")])
    
    # 5. Ø²Ø± Ø§Ù„ØªÙˆØ§ØµÙ„ Ø¯Ø§Ø¦Ù…Ø§Ù‹ ÙÙŠ Ø§Ù„Ø£Ø®ÙŠØ±
    common = get_common_service_btns()
    if common:
        common_text = common[0].text
        if add_btn(common_text):
            keyboard.append(common)
    
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_admin_kb():
    """Ø¯Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¨Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø¬Ø¯ÙŠØ¯Ø©"""
    keyboard = [[types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_admin_afaq_kb():
    """Ø¯Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¨Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø¢ÙØ§Ù‚ Ø¬Ø¯ÙŠØ¯Ø©"""
    keyboard = [[types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_admin_alarms_kb():
    """Ø¯Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¨Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©"""
    keyboard = [[types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_admin_wird_kb():
    """Ø¯Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¨Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ÙˆØ±Ø¯ Ø¬Ø¯ÙŠØ¯Ø©"""
    keyboard = [[types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_admin_interface_kb():
    """Ø¯Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¨Ù„ÙˆØ­Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø¬Ø¯ÙŠØ¯Ø©"""
    keyboard = [[types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_admin_community_kb():
    """Ø¯Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - Ø³ØªØ³ØªØ¨Ø¯Ù„ Ø¨Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¬ØªÙ…Ø¹ Ø¬Ø¯ÙŠØ¯Ø©"""
    keyboard = [[types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_quran_menu_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª ÙˆØ§Ù„Ù…ØµØ§Ø­Ù")],
        [types.KeyboardButton(text="Ø¢ÙŠØ§Øª"), types.KeyboardButton(text="Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†")],
        [types.KeyboardButton(text="Ø®ØªÙ…Ø© Ù‚Ø±Ø¢Ù†ÙŠØ©")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_azkar_menu_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø£Ø°ÙƒØ§Ø± Ø§Ù„ØµØ¨Ø§Ø­"), types.KeyboardButton(text="Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ù…Ø³Ø§Ø¡")],
        [types.KeyboardButton(text="Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ù†ÙˆÙ…"), types.KeyboardButton(text="Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©")],
        [types.KeyboardButton(text="Ø£Ø¯Ø¹ÙŠØ© Ù…Ù†ÙˆØ¹Ø©"), types.KeyboardButton(text="ØªØ³Ø§Ø¨ÙŠØ­")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_khatma_menu_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©")],
        [types.KeyboardButton(text="Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ…")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_target_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø§Ù„ÙƒÙ„"), types.KeyboardButton(text="Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")],
        [types.KeyboardButton(text="Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"), types.KeyboardButton(text="Ø§Ù„Ù‚Ù†ÙˆØ§Øª")],
        [types.KeyboardButton(text="Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_bc_target_kb():
    """Keyboard for broadcast target selection"""
    keyboard = [
        [types.KeyboardButton(text="Ø§Ù„ÙƒÙ„"), types.KeyboardButton(text="Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")],
        [types.KeyboardButton(text="Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"), types.KeyboardButton(text="Ø§Ù„Ù‚Ù†ÙˆØ§Øª")],
        [types.KeyboardButton(text="Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_schedule_type_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©")],
        [types.KeyboardButton(text="ÙŠÙˆÙ…ÙŠØ© (ÙƒÙ„ ÙŠÙˆÙ…)")],
        [types.KeyboardButton(text="Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© (Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹)")],
        [types.KeyboardButton(text="Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_duration_kb():
    keyboard = [
        [types.KeyboardButton(text="ÙŠÙˆÙ…"), types.KeyboardButton(text="Ø£Ø³Ø¨ÙˆØ¹")],
        [types.KeyboardButton(text="Ø´Ù‡Ø±"), types.KeyboardButton(text="Ø³Ù†Ø©")],
        [types.KeyboardButton(text="Ø¯Ø§Ø¦Ù… (Ø¨Ø¯ÙˆÙ† Ù†Ù‡Ø§ÙŠØ©)")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_weekdays_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø§Ù„Ø£Ø­Ø¯"), types.KeyboardButton(text="Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†")],
        [types.KeyboardButton(text="Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡"), types.KeyboardButton(text="Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡")],
        [types.KeyboardButton(text="Ø§Ù„Ø®Ù…ÙŠØ³"), types.KeyboardButton(text="Ø§Ù„Ø¬Ù…Ø¹Ø©")],
        [types.KeyboardButton(text="Ø§Ù„Ø³Ø¨Øª")],
        [types.KeyboardButton(text="ØªØ£ÙƒÙŠØ¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ÙŠØ§Ù…")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_cancel_kb():
    # Ø²Ø± "Ø¥Ù„ØºØ§Ø¡"
    return types.ReplyKeyboardMarkup(keyboard=[[types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]], resize_keyboard=True, one_time_keyboard=True)

def get_back_kb():
    # Ø²Ø± "Ø¥Ù„ØºØ§Ø¡" (Ù„Ù„ØªÙˆØ§ÙÙ‚)
    return types.ReplyKeyboardMarkup(keyboard=[[types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]], resize_keyboard=True, one_time_keyboard=True)

def get_test_kb():
    return types.ReplyKeyboardMarkup(
        keyboard=[
            [types.KeyboardButton(text="Ø¥Ø±Ø³Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ")],
            [types.KeyboardButton(text="ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„")],
            [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

def get_validation_kb():
    """ÙƒÙŠØ¨ÙˆØ±Ø¯ Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙˆØ§Ù„ØªØ£ÙƒÙŠØ¯"""
    return types.ReplyKeyboardMarkup(
        keyboard=[
            [types.KeyboardButton(text="Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ©")],
            [types.KeyboardButton(text="ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©")],
            [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø£Ù…Ø±")]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

def get_system_buttons_edit_kb():
    keyboard = [
        [types.KeyboardButton(text="ØªØºÙŠÙŠØ± Ø§Ø³Ù… Ø§Ù„Ø²Ø±")],
        [types.KeyboardButton(text="ØªØºÙŠÙŠØ± Ø§Ù„ØªØ±ØªÙŠØ¨")],
        [types.KeyboardButton(text="Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡")],
        [types.KeyboardButton(text="ØªØºÙŠÙŠØ± Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_custom_buttons_manage_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø¬Ø¯ÙŠØ¯")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ø²Ø±")],
        [types.KeyboardButton(text="Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø²Ø±Ø§Ø±")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_data_add_type_kb():
    keyboard = [
        [types.KeyboardButton(text="Ù†Øµ ÙÙ‚Ø·")],
        [types.KeyboardButton(text="ØµÙˆØ±Ø© + Ù†Øµ")],
        [types.KeyboardButton(text="ØµÙˆØª + Ù†Øµ")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_delete_msg_options_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ù…Ø­Ø¯Ø¯Ø©")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ø¢Ø®Ø± Ø±Ø³Ø§Ø¦Ù„")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True, one_time_keyboard=True)

def get_admin_management_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ù…Ø´Ø±Ù")],
        [types.KeyboardButton(text="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

def get_azkar_manage_kb():
    keyboard = [
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ø°ÙƒØ± Ø¬Ø¯ÙŠØ¯")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ø°ÙƒØ±")],
        [types.KeyboardButton(text="Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø°ÙƒØ§Ø±")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø¢ÙØ§Ù‚")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

async def check_service_maintenance(message: types.Message, service="afaq"):
    if get_db().is_admin(message.from_user.id): return False
    config_key = f"{service}_maintenance"
    if get_db().get_config(config_key) == '1':
        name_map = {"afaq": "Ø¢ÙØ§Ù‚", "wird": "Ø§Ù„ÙˆØ±Ø¯", "alarms": "Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª"}
        s_name = name_map.get(service, service)
        await message.answer(f"âš ï¸ <b>Ø®Ø¯Ù…Ø© {s_name} ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.</b>\nÙ†Ø¹ØªØ°Ø± Ø¹Ù† Ø§Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.", parse_mode="HTML")
        return True
    return False

# ==========================================
# Subscription Check Middleware
# ==========================================
class SubscriptionMiddleware:
    def __init__(self, required_channel):
        self.required_channel = required_channel
    
    async def __call__(self, handler, event, data):
        if not self.required_channel:
            return await handler(event, data)
        
        if isinstance(event, types.Message):
            user_id = event.from_user.id
            
            # ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ
            db = get_db()
            if db.is_admin(user_id) or user_id == ADMIN_ID:
                return await handler(event, data)
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
            try:
                member = await event.bot.get_chat_member(self.required_channel, user_id)
                if member.status in ['left', 'kicked']:
                    await event.answer(f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© {self.required_channel} Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.")
                    return None
            except Exception as e:
                logger.error(f"Subscription check error: {e}")
                return await handler(event, data)
                
        return await handler(event, data)

# ==========================================
# Block Check Middleware
# ==========================================
class BlockCheckMiddleware:
    async def __call__(self, handler, event, data):
        if isinstance(event, types.Message):
            db = get_db()
            if db.is_user_blocked(event.from_user.id):
                await event.answer("â›” Ø£Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")
                return None
        return await handler(event, data)

# ==========================================
# Helpers for Timezone and Dates
# ==========================================
def calculate_end_date(start_date: str, duration: str) -> Optional[str]:
    """Ø­Ø³Ø§Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¯Ø©"""
    try:
        start = datetime.strptime(start_date, "%Y-%m-%d")
        
        if duration == "ÙŠÙˆÙ…":
            end = start + timedelta(days=1)
        elif duration == "Ø£Ø³Ø¨ÙˆØ¹":
            end = start + timedelta(weeks=1)
        elif duration == "Ø´Ù‡Ø±":
            end = start + timedelta(days=30)
        elif duration == "Ø³Ù†Ø©":
            end = start + timedelta(days=365)
        elif duration == "Ø¯Ø§Ø¦Ù… (Ø¨Ø¯ÙˆÙ† Ù†Ù‡Ø§ÙŠØ©)":
            return None
        else:
            return None
            
        return end.strftime("%Y-%m-%d")
    except Exception as e:
        logger.error(f"Calculate end date error: {e}")
        return None

# ==========================================
# Handlers
# ==========================================

@router.message(F.text == "Ø¥Ù„ØºØ§Ø¡")
async def universal_cancel_handler(message: types.Message, state: FSMContext):
    await state.clear()
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø±Ø¯ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„Ø©
    data = await state.get_data()
    if hasattr(message, 'state') and message.state and 'quran' in str(message.state):
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡", reply_markup=get_quran_menu_kb())
    else:
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.")

@router.message(Command("start"))
async def cmd_start(message: types.Message):
    db = get_db()
    is_admin = db.is_admin(message.from_user.id)
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙƒÙ€ active
    db.add_user(message.from_user.id, message.from_user.username)
    
    welcome_msg = db.get_welcome_message()
    if not welcome_msg:
        welcome_msg = f"""
<b>Ù…Ø±Ø­Ø¨Ø§Ù‹ {message.from_user.first_name}</b>

Ø§Ù„Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©:
Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… ÙˆØªÙ„Ø§ÙˆØ§ØªÙ‡
Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ©
Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù†Ø¨ÙˆÙŠØ©
Ø§Ù„Ù…Ø³Ø¨Ø­Ø© Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©

<b>Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ø¯Ù†Ø§Ù‡</b>
"""
    else:
        welcome_msg = welcome_msg.format(name=message.from_user.first_name)
    
    await message.answer(welcome_msg, reply_markup=get_main_kb(message.from_user.id, is_admin), parse_mode="HTML")

# ØªÙ… Ø­Ø°Ù handler Ø¨ÙˆØª Ø¢ÙØ§Ù‚ - Ø§Ù„Ø£Ø²Ø±Ø§Ø± ØªØ¸Ù‡Ø± Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

# ==========================================
# Handlers Ù„Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
# ==========================================

@router.message(F.text.in_(["Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…"]))
async def btn_quran(message: types.Message):
    text = "<b>Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…</b>\n\nØ§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø©:"
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ")],
        [types.KeyboardButton(text="Ø§Ù„Ø®ØªÙ…Ø©"), types.KeyboardButton(text="Ø¢ÙŠØ§Øª")],
        [types.KeyboardButton(text="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†"), types.KeyboardButton(text="Ø§Ù„ØªÙØ§Ø³ÙŠØ±")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text.in_(["Ø­Ø¯ÙŠØ« Ø´Ø±ÙŠÙ", "Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø´Ø±ÙŠÙ"]))
async def btn_hadith(message: types.Message):
    text = (
        "<b>Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù†Ø¨ÙˆÙŠØ© Ø§Ù„Ø´Ø±ÙŠÙØ©</b>\n\n"
        "<b>ØªØ­Øª Ø§Ù„Ø¹Ù…Ù„ - ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ø­Ø§Ù„ÙŠØ§Ù‹</b>\n\n"
        "Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¥Ù† Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡"
    )
    db = get_db()
    is_admin = db.is_admin(message.from_user.id)
    await message.answer(text, reply_markup=get_main_kb(message.from_user.id, is_admin), parse_mode="HTML")

@router.message(F.text.in_(["Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ©", "Ø§Ù„Ø£Ø°ÙƒØ§Ø±", "Ø£Ø°ÙƒØ§Ø±"]))
async def btn_azkar(message: types.Message):
    """Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ© - Ù…Ø¹Ø·Ù„ Ù…Ø¤Ù‚ØªØ§Ù‹"""
    text = """<b>Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ©</b>

Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø³Ù… Ù…Ø¹Ø·Ù„ Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù„ØµÙŠØ§Ù†Ø©

Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰:
ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­ØªÙˆÙ‰
Ø¥Ø¶Ø§ÙØ© Ù…ÙŠØ²Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡

ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø§Ù‚ÙŠ Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¨ÙˆØª
Ø³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù‚Ø³Ù… Ù‚Ø±ÙŠØ¨Ø§Ù‹"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# ØªÙ… Ø­Ø°Ù handler Ù‚Ø¯ÙŠÙ… - Ø§Ù„Ø¢Ù† ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹ ÙÙŠ handler ÙˆØ§Ø­Ø¯ Ø£Ø¯Ù†Ø§Ù‡

@router.callback_query(F.data == "back_to_main")
async def cb_back_to_main(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù€ inline"""
    await state.clear()
    await callback.message.delete()
    await cmd_start(callback.message)
    await callback.answer()

@router.callback_query(F.data == "close_msg")
async def cb_close_message(callback: types.CallbackQuery):
    """Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©"""
    try:
        await callback.message.delete()
    except:
        pass
    await callback.answer()

# ==========================================
# Callback Handlers Ù„Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ
# ==========================================

@router.callback_query(F.data.startswith("listen_reciter_"))
async def cb_listen_reciter(callback: types.CallbackQuery):
    """Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³ÙˆØ± Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ù‚Ø§Ø±Ø¦"""
    reciter_id = int(callback.data.split("_")[2])
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø±Ø¦
    reciter = conn.execute(
        "SELECT name, description FROM reciters WHERE id=?",
        (reciter_id,)
    ).fetchone()
    
    if not reciter:
        await callback.answer("âŒ Ø§Ù„Ù‚Ø§Ø±Ø¦ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
        return
    
    reciter_name, reciter_desc = reciter
    
    # Ø¬Ù„Ø¨ Ø§Ù„Ø³ÙˆØ± Ø§Ù„Ù…ØªØ§Ø­Ø©
    surahs = conn.execute("""
        SELECT surah_number, file_id, duration
        FROM quran_audio
        WHERE reciter_id=?
        ORDER BY surah_number
    """, (reciter_id,)).fetchall()
    
    conn.close()
    
    if not surahs:
        await callback.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ„Ø§ÙˆØ§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ø±Ø¦", show_alert=True)
        return
    
    # Ù‚Ø§Ø¦Ù…Ø© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø³ÙˆØ± (114 Ø³ÙˆØ±Ø©)
    surah_names = [
        "Ø§Ù„ÙØ§ØªØ­Ø©", "Ø§Ù„Ø¨Ù‚Ø±Ø©", "Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†", "Ø§Ù„Ù†Ø³Ø§Ø¡", "Ø§Ù„Ù…Ø§Ø¦Ø¯Ø©", "Ø§Ù„Ø£Ù†Ø¹Ø§Ù…", "Ø§Ù„Ø£Ø¹Ø±Ø§Ù", "Ø§Ù„Ø£Ù†ÙØ§Ù„",
        "Ø§Ù„ØªÙˆØ¨Ø©", "ÙŠÙˆÙ†Ø³", "Ù‡ÙˆØ¯", "ÙŠÙˆØ³Ù", "Ø§Ù„Ø±Ø¹Ø¯", "Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…", "Ø§Ù„Ø­Ø¬Ø±", "Ø§Ù„Ù†Ø­Ù„", "Ø§Ù„Ø¥Ø³Ø±Ø§Ø¡",
        "Ø§Ù„ÙƒÙ‡Ù", "Ù…Ø±ÙŠÙ…", "Ø·Ù‡", "Ø§Ù„Ø£Ù†Ø¨ÙŠØ§Ø¡", "Ø§Ù„Ø­Ø¬", "Ø§Ù„Ù…Ø¤Ù…Ù†ÙˆÙ†", "Ø§Ù„Ù†ÙˆØ±", "Ø§Ù„ÙØ±Ù‚Ø§Ù†", "Ø§Ù„Ø´Ø¹Ø±Ø§Ø¡",
        "Ø§Ù„Ù†Ù…Ù„", "Ø§Ù„Ù‚ØµØµ", "Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª", "Ø§Ù„Ø±ÙˆÙ…", "Ù„Ù‚Ù…Ø§Ù†", "Ø§Ù„Ø³Ø¬Ø¯Ø©", "Ø§Ù„Ø£Ø­Ø²Ø§Ø¨", "Ø³Ø¨Ø£", "ÙØ§Ø·Ø±",
        "ÙŠØ³", "Ø§Ù„ØµØ§ÙØ§Øª", "Øµ", "Ø§Ù„Ø²Ù…Ø±", "ØºØ§ÙØ±", "ÙØµÙ„Øª", "Ø§Ù„Ø´ÙˆØ±Ù‰", "Ø§Ù„Ø²Ø®Ø±Ù", "Ø§Ù„Ø¯Ø®Ø§Ù†", "Ø§Ù„Ø¬Ø§Ø«ÙŠØ©",
        "Ø§Ù„Ø£Ø­Ù‚Ø§Ù", "Ù…Ø­Ù…Ø¯", "Ø§Ù„ÙØªØ­", "Ø§Ù„Ø­Ø¬Ø±Ø§Øª", "Ù‚", "Ø§Ù„Ø°Ø§Ø±ÙŠØ§Øª", "Ø§Ù„Ø·ÙˆØ±", "Ø§Ù„Ù†Ø¬Ù…", "Ø§Ù„Ù‚Ù…Ø±",
        "Ø§Ù„Ø±Ø­Ù…Ù†", "Ø§Ù„ÙˆØ§Ù‚Ø¹Ø©", "Ø§Ù„Ø­Ø¯ÙŠØ¯", "Ø§Ù„Ù…Ø¬Ø§Ø¯Ù„Ø©", "Ø§Ù„Ø­Ø´Ø±", "Ø§Ù„Ù…Ù…ØªØ­Ù†Ø©", "Ø§Ù„ØµÙ", "Ø§Ù„Ø¬Ù…Ø¹Ø©",
        "Ø§Ù„Ù…Ù†Ø§ÙÙ‚ÙˆÙ†", "Ø§Ù„ØªØºØ§Ø¨Ù†", "Ø§Ù„Ø·Ù„Ø§Ù‚", "Ø§Ù„ØªØ­Ø±ÙŠÙ…", "Ø§Ù„Ù…Ù„Ùƒ", "Ø§Ù„Ù‚Ù„Ù…", "Ø§Ù„Ø­Ø§Ù‚Ø©", "Ø§Ù„Ù…Ø¹Ø§Ø±Ø¬",
        "Ù†ÙˆØ­", "Ø§Ù„Ø¬Ù†", "Ø§Ù„Ù…Ø²Ù…Ù„", "Ø§Ù„Ù…Ø¯Ø«Ø±", "Ø§Ù„Ù‚ÙŠØ§Ù…Ø©", "Ø§Ù„Ø¥Ù†Ø³Ø§Ù†", "Ø§Ù„Ù…Ø±Ø³Ù„Ø§Øª", "Ø§Ù„Ù†Ø¨Ø£", "Ø§Ù„Ù†Ø§Ø²Ø¹Ø§Øª",
        "Ø¹Ø¨Ø³", "Ø§Ù„ØªÙƒÙˆÙŠØ±", "Ø§Ù„Ø§Ù†ÙØ·Ø§Ø±", "Ø§Ù„Ù…Ø·ÙÙÙŠÙ†", "Ø§Ù„Ø§Ù†Ø´Ù‚Ø§Ù‚", "Ø§Ù„Ø¨Ø±ÙˆØ¬", "Ø§Ù„Ø·Ø§Ø±Ù‚", "Ø§Ù„Ø£Ø¹Ù„Ù‰",
        "Ø§Ù„ØºØ§Ø´ÙŠØ©", "Ø§Ù„ÙØ¬Ø±", "Ø§Ù„Ø¨Ù„Ø¯", "Ø§Ù„Ø´Ù…Ø³", "Ø§Ù„Ù„ÙŠÙ„", "Ø§Ù„Ø¶Ø­Ù‰", "Ø§Ù„Ø´Ø±Ø­", "Ø§Ù„ØªÙŠÙ†", "Ø§Ù„Ø¹Ù„Ù‚",
        "Ø§Ù„Ù‚Ø¯Ø±", "Ø§Ù„Ø¨ÙŠÙ†Ø©", "Ø§Ù„Ø²Ù„Ø²Ù„Ø©", "Ø§Ù„Ø¹Ø§Ø¯ÙŠØ§Øª", "Ø§Ù„Ù‚Ø§Ø±Ø¹Ø©", "Ø§Ù„ØªÙƒØ§Ø«Ø±", "Ø§Ù„Ø¹ØµØ±", "Ø§Ù„Ù‡Ù…Ø²Ø©",
        "Ø§Ù„ÙÙŠÙ„", "Ù‚Ø±ÙŠØ´", "Ø§Ù„Ù…Ø§Ø¹ÙˆÙ†", "Ø§Ù„ÙƒÙˆØ«Ø±", "Ø§Ù„ÙƒØ§ÙØ±ÙˆÙ†", "Ø§Ù„Ù†ØµØ±", "Ø§Ù„Ù…Ø³Ø¯", "Ø§Ù„Ø¥Ø®Ù„Ø§Øµ",
        "Ø§Ù„ÙÙ„Ù‚", "Ø§Ù„Ù†Ø§Ø³"
    ]
    
    text = f"""ğŸ™ï¸ <b>{reciter_name}</b>

ğŸ“– Ø§Ù„Ø³ÙˆØ± Ø§Ù„Ù…ØªØ§Ø­Ø©: <code>{len(surahs)}</code>

Ø§Ø®ØªØ± Ø³ÙˆØ±Ø© Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹:

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³ÙˆØ± Ø¥Ù„Ù‰ 100 Ø³ÙˆØ±Ø© ÙÙ‚Ø·
    display_surahs = surahs[:100]
    
    keyboard = []
    row = []
    
    for idx, (surah_num, file_id, duration) in enumerate(display_surahs, 1):
        surah_name = surah_names[surah_num - 1] if 1 <= surah_num <= 114 else f"Ø³ÙˆØ±Ø© {surah_num}"
        
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø³Ù…Ø§Ø¡ Ù…Ø®ØªØµØ±Ø© Ù„Ù„Ø³ÙˆØ± Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
        if len(surah_name) > 8:
            display_name = f"{surah_num}"
        else:
            display_name = f"{surah_num}. {surah_name}"
        
        row.append(InlineKeyboardButton(
            text=display_name,
            callback_data=f"play_audio_{reciter_id}_{surah_num}"
        ))
        
        # ÙƒÙ„ 3 Ø£Ø²Ø±Ø§Ø±ØŒ Ø£Ø¶Ù ØµÙ Ø¬Ø¯ÙŠØ¯
        if len(row) == 3:
            keyboard.append(row)
            row = []
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¥Ù† ÙˆØ¬Ø¯
    if row:
        keyboard.append(row)
    
    # Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø³ÙˆØ±
    if len(surahs) > 100:
        text += f"\nğŸ’¡ ÙŠØªÙ… Ø¹Ø±Ø¶ Ø£ÙˆÙ„ 100 Ø³ÙˆØ±Ø© Ù…Ù† {len(surahs)}"
    
    keyboard.append([InlineKeyboardButton(text="â—€ï¸ Ø±Ø¬ÙˆØ¹", callback_data="back_quran_audio")])
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("play_audio_"))
async def cb_play_audio(callback: types.CallbackQuery):
    """ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ø§ÙˆØ© Ø§Ù„ØµÙˆØªÙŠØ©"""
    parts = callback.data.split("_")
    reciter_id = int(parts[2])
    surah_number = int(parts[3])
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ
    audio_data = conn.execute("""
        SELECT qa.file_id, r.name
        FROM quran_audio qa
        JOIN reciters r ON qa.reciter_id = r.id
        WHERE qa.reciter_id=? AND qa.surah_number=?
    """, (reciter_id, surah_number)).fetchone()
    
    conn.close()
    
    if not audio_data:
        await callback.answer("âŒ Ø§Ù„ØªÙ„Ø§ÙˆØ© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©", show_alert=True)
        return
    
    file_id, reciter_name = audio_data
    
    # Ù‚Ø§Ø¦Ù…Ø© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø³ÙˆØ±
    surah_names = [
        "Ø§Ù„ÙØ§ØªØ­Ø©", "Ø§Ù„Ø¨Ù‚Ø±Ø©", "Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†", "Ø§Ù„Ù†Ø³Ø§Ø¡", "Ø§Ù„Ù…Ø§Ø¦Ø¯Ø©", "Ø§Ù„Ø£Ù†Ø¹Ø§Ù…", "Ø§Ù„Ø£Ø¹Ø±Ø§Ù", "Ø§Ù„Ø£Ù†ÙØ§Ù„",
        "Ø§Ù„ØªÙˆØ¨Ø©", "ÙŠÙˆÙ†Ø³", "Ù‡ÙˆØ¯", "ÙŠÙˆØ³Ù", "Ø§Ù„Ø±Ø¹Ø¯", "Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…", "Ø§Ù„Ø­Ø¬Ø±", "Ø§Ù„Ù†Ø­Ù„", "Ø§Ù„Ø¥Ø³Ø±Ø§Ø¡",
        "Ø§Ù„ÙƒÙ‡Ù", "Ù…Ø±ÙŠÙ…", "Ø·Ù‡", "Ø§Ù„Ø£Ù†Ø¨ÙŠØ§Ø¡", "Ø§Ù„Ø­Ø¬", "Ø§Ù„Ù…Ø¤Ù…Ù†ÙˆÙ†", "Ø§Ù„Ù†ÙˆØ±", "Ø§Ù„ÙØ±Ù‚Ø§Ù†", "Ø§Ù„Ø´Ø¹Ø±Ø§Ø¡",
        "Ø§Ù„Ù†Ù…Ù„", "Ø§Ù„Ù‚ØµØµ", "Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª", "Ø§Ù„Ø±ÙˆÙ…", "Ù„Ù‚Ù…Ø§Ù†", "Ø§Ù„Ø³Ø¬Ø¯Ø©", "Ø§Ù„Ø£Ø­Ø²Ø§Ø¨", "Ø³Ø¨Ø£", "ÙØ§Ø·Ø±",
        "ÙŠØ³", "Ø§Ù„ØµØ§ÙØ§Øª", "Øµ", "Ø§Ù„Ø²Ù…Ø±", "ØºØ§ÙØ±", "ÙØµÙ„Øª", "Ø§Ù„Ø´ÙˆØ±Ù‰", "Ø§Ù„Ø²Ø®Ø±Ù", "Ø§Ù„Ø¯Ø®Ø§Ù†", "Ø§Ù„Ø¬Ø§Ø«ÙŠØ©",
        "Ø§Ù„Ø£Ø­Ù‚Ø§Ù", "Ù…Ø­Ù…Ø¯", "Ø§Ù„ÙØªØ­", "Ø§Ù„Ø­Ø¬Ø±Ø§Øª", "Ù‚", "Ø§Ù„Ø°Ø§Ø±ÙŠØ§Øª", "Ø§Ù„Ø·ÙˆØ±", "Ø§Ù„Ù†Ø¬Ù…", "Ø§Ù„Ù‚Ù…Ø±",
        "Ø§Ù„Ø±Ø­Ù…Ù†", "Ø§Ù„ÙˆØ§Ù‚Ø¹Ø©", "Ø§Ù„Ø­Ø¯ÙŠØ¯", "Ø§Ù„Ù…Ø¬Ø§Ø¯Ù„Ø©", "Ø§Ù„Ø­Ø´Ø±", "Ø§Ù„Ù…Ù…ØªØ­Ù†Ø©", "Ø§Ù„ØµÙ", "Ø§Ù„Ø¬Ù…Ø¹Ø©",
        "Ø§Ù„Ù…Ù†Ø§ÙÙ‚ÙˆÙ†", "Ø§Ù„ØªØºØ§Ø¨Ù†", "Ø§Ù„Ø·Ù„Ø§Ù‚", "Ø§Ù„ØªØ­Ø±ÙŠÙ…", "Ø§Ù„Ù…Ù„Ùƒ", "Ø§Ù„Ù‚Ù„Ù…", "Ø§Ù„Ø­Ø§Ù‚Ø©", "Ø§Ù„Ù…Ø¹Ø§Ø±Ø¬",
        "Ù†ÙˆØ­", "Ø§Ù„Ø¬Ù†", "Ø§Ù„Ù…Ø²Ù…Ù„", "Ø§Ù„Ù…Ø¯Ø«Ø±", "Ø§Ù„Ù‚ÙŠØ§Ù…Ø©", "Ø§Ù„Ø¥Ù†Ø³Ø§Ù†", "Ø§Ù„Ù…Ø±Ø³Ù„Ø§Øª", "Ø§Ù„Ù†Ø¨Ø£", "Ø§Ù„Ù†Ø§Ø²Ø¹Ø§Øª",
        "Ø¹Ø¨Ø³", "Ø§Ù„ØªÙƒÙˆÙŠØ±", "Ø§Ù„Ø§Ù†ÙØ·Ø§Ø±", "Ø§Ù„Ù…Ø·ÙÙÙŠÙ†", "Ø§Ù„Ø§Ù†Ø´Ù‚Ø§Ù‚", "Ø§Ù„Ø¨Ø±ÙˆØ¬", "Ø§Ù„Ø·Ø§Ø±Ù‚", "Ø§Ù„Ø£Ø¹Ù„Ù‰",
        "Ø§Ù„ØºØ§Ø´ÙŠØ©", "Ø§Ù„ÙØ¬Ø±", "Ø§Ù„Ø¨Ù„Ø¯", "Ø§Ù„Ø´Ù…Ø³", "Ø§Ù„Ù„ÙŠÙ„", "Ø§Ù„Ø¶Ø­Ù‰", "Ø§Ù„Ø´Ø±Ø­", "Ø§Ù„ØªÙŠÙ†", "Ø§Ù„Ø¹Ù„Ù‚",
        "Ø§Ù„Ù‚Ø¯Ø±", "Ø§Ù„Ø¨ÙŠÙ†Ø©", "Ø§Ù„Ø²Ù„Ø²Ù„Ø©", "Ø§Ù„Ø¹Ø§Ø¯ÙŠØ§Øª", "Ø§Ù„Ù‚Ø§Ø±Ø¹Ø©", "Ø§Ù„ØªÙƒØ§Ø«Ø±", "Ø§Ù„Ø¹ØµØ±", "Ø§Ù„Ù‡Ù…Ø²Ø©",
        "Ø§Ù„ÙÙŠÙ„", "Ù‚Ø±ÙŠØ´", "Ø§Ù„Ù…Ø§Ø¹ÙˆÙ†", "Ø§Ù„ÙƒÙˆØ«Ø±", "Ø§Ù„ÙƒØ§ÙØ±ÙˆÙ†", "Ø§Ù„Ù†ØµØ±", "Ø§Ù„Ù…Ø³Ø¯", "Ø§Ù„Ø¥Ø®Ù„Ø§Øµ",
        "Ø§Ù„ÙÙ„Ù‚", "Ø§Ù„Ù†Ø§Ø³"
    ]
    
    surah_name = surah_names[surah_number - 1] if 1 <= surah_number <= 114 else f"Ø³ÙˆØ±Ø© {surah_number}"
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ
    try:
        await callback.message.answer_audio(
            audio=file_id,
            caption=f"ğŸ™ï¸ <b>{reciter_name}</b>\nğŸ“– Ø³ÙˆØ±Ø© {surah_name}",
            parse_mode="HTML"
        )
        await callback.answer("âœ… Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„...")
    except Exception as e:
        logger.error(f"Error playing audio: {e}")
        await callback.answer("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ø§ÙˆØ©", show_alert=True)

@router.callback_query(F.data == "back_quran_audio")
async def cb_back_quran_audio(callback: types.CallbackQuery):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡"""
    db = get_db()
    conn = db.get_connection()
    
    reciters = conn.execute("""
        SELECT r.id, COALESCE(r.name_ar, r.reciter_key, 'Ù‚Ø§Ø±Ø¦'), r.description,
               COUNT(qa.id) as audio_count
        FROM reciters r
        INNER JOIN quran_audio qa ON r.id = qa.reciter_id
        GROUP BY r.id
        ORDER BY COALESCE(r.name_ar, r.reciter_key)
    """).fetchall()
    
    conn.close()
    
    text = f"""ğŸ§ <b>Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… - ØµÙˆØªÙŠ</b>

ğŸ“Š Ù…ØªÙˆÙØ±: <code>{len(reciters)}</code> Ù‚Ø§Ø±Ø¦

Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø§Ø±Ø¦ Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹:

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    keyboard = []
    for rec_id, name, desc, audio_count in reciters:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ™ï¸ {name} ({audio_count} Ø³ÙˆØ±Ø©)",
            callback_data=f"listen_reciter_{rec_id}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="â—€ï¸ Ø±Ø¬ÙˆØ¹", callback_data="back_main")])
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data == "back_main")
async def cb_back_main(callback: types.CallbackQuery):
    """Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    try:
        await callback.message.delete()
    except:
        pass
    await callback.answer()

# ==========================================
# Callback Handlers Ù„Ù„Ø­Ø°Ù (Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ)
# ==========================================

@router.callback_query(F.data.startswith("confirm_delete_rec_"))
async def cb_confirm_delete_reciter(callback: types.CallbackQuery):
    """ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ù‚Ø§Ø±Ø¦"""
    reciter_id = int(callback.data.split("_")[3])
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø±Ø¦
    reciter = conn.execute(
        "SELECT name, (SELECT COUNT(*) FROM quran_audio WHERE reciter_id=?) as count FROM reciters WHERE id=?",
        (reciter_id, reciter_id)
    ).fetchone()
    
    if not reciter:
        await callback.answer("âŒ Ø§Ù„Ù‚Ø§Ø±Ø¦ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
        conn.close()
        return
    
    reciter_name, audio_count = reciter
    
    # Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ø£ÙˆÙ„Ø§Ù‹
    conn.execute("DELETE FROM quran_audio WHERE reciter_id=?", (reciter_id,))
    
    # Ø«Ù… Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ø±Ø¦
    conn.execute("DELETE FROM reciters WHERE id=?", (reciter_id,))
    
    conn.commit()
    conn.close()
    
    await callback.message.edit_text(
        f"âœ… <b>ØªÙ… Ø§Ù„Ø­Ø°Ù Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
        f"ğŸ—‘ï¸ Ø§Ù„Ù‚Ø§Ø±Ø¦: {reciter_name}\n"
        f"ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ø§Ù„Ù…Ø­Ø°ÙˆÙØ©: {audio_count}",
        parse_mode="HTML"
    )
    await callback.answer("âœ… ØªÙ… Ø§Ù„Ø­Ø°Ù")

@router.callback_query(F.data.startswith("confirm_del_audio_"))
async def cb_confirm_delete_audio(callback: types.CallbackQuery):
    """ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù ØªÙ„Ø§ÙˆØ©"""
    audio_id = int(callback.data.split("_")[3])
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙ„Ø§ÙˆØ©
    audio = conn.execute("""
        SELECT r.name, qa.surah_number
        FROM quran_audio qa
        JOIN reciters r ON qa.reciter_id = r.id
        WHERE qa.id=?
    """, (audio_id,)).fetchone()
    
    if not audio:
        await callback.answer("âŒ Ø§Ù„ØªÙ„Ø§ÙˆØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©", show_alert=True)
        conn.close()
        return
    
    reciter_name, surah_number = audio
    
    # Ø­Ø°Ù Ø§Ù„ØªÙ„Ø§ÙˆØ©
    conn.execute("DELETE FROM quran_audio WHERE id=?", (audio_id,))
    conn.commit()
    conn.close()
    
    await callback.message.edit_text(
        f"âœ… <b>ØªÙ… Ø­Ø°Ù Ø§Ù„ØªÙ„Ø§ÙˆØ© Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
        f"ğŸ™ï¸ Ø§Ù„Ù‚Ø§Ø±Ø¦: {reciter_name}\n"
        f"ğŸ“– Ø§Ù„Ø³ÙˆØ±Ø©: {surah_number}",
        parse_mode="HTML"
    )
    await callback.answer("âœ… ØªÙ… Ø§Ù„Ø­Ø°Ù")

@router.callback_query(F.data.startswith("confirm_del_rec_audios_"))
async def cb_confirm_delete_reciter_audios(callback: types.CallbackQuery):
    """ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø§Ø±Ø¦"""
    reciter_id = int(callback.data.split("_")[4])
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø±Ø¦
    reciter = conn.execute(
        "SELECT name_ar FROM reciters WHERE id=?", (reciter_id,)
    ).fetchone()
    
    if not reciter:
        await callback.answer("âŒ Ø§Ù„Ù‚Ø§Ø±Ø¦ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
        conn.close()
        return
    
    reciter_name = reciter[0]
    
    # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø°Ù
    count = conn.execute(
        "SELECT COUNT(*) FROM quran_audio WHERE reciter_id=?", (reciter_id,)
    ).fetchone()[0]
    
    # Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª
    conn.execute("DELETE FROM quran_audio WHERE reciter_id=?", (reciter_id,))
    conn.commit()
    conn.close()
    
    await callback.message.edit_text(
        f"âœ… <b>ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
        f"ğŸ™ï¸ Ø§Ù„Ù‚Ø§Ø±Ø¦: {reciter_name}\n"
        f"ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ø§Ù„Ù…Ø­Ø°ÙˆÙØ©: {count}",
        parse_mode="HTML"
    )
    await callback.answer("âœ… ØªÙ… Ø§Ù„Ø­Ø°Ù")

@router.callback_query(F.data == "cancel")
async def cb_cancel_action(callback: types.CallbackQuery):
    """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"""
    try:
        await callback.message.delete()
    except:
        pass
    await callback.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡")

# ==========================================
# Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù€ Callback Handlers
# ==========================================

@router.message(F.text.in_(["ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"]))
async def btn_contact(message: types.Message, state: FSMContext):
    """Ø²Ø± ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"""
    text = (
        "<b>ğŸ“¬ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§</b>\n\n"
        "Ù†Ø³Ø¹Ø¯ Ø¨ØªÙ„Ù‚ÙŠ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒÙ… ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§ØªÙƒÙ… ğŸ’¬\n\n"
        "ğŸ“ Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø§Ù„Ø¢Ù† ÙˆØ³Ù†Ø±Ø¯ Ø¹Ù„ÙŠÙƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª"
    )
    await message.answer(text, parse_mode="HTML", reply_markup=get_cancel_kb())
    await state.set_state(Form.contact_msg)

@router.message(Form.contact_msg)
async def process_contact_message(message: types.Message, state: FSMContext):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙˆØ§ØµÙ„"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await cmd_start(message)
        return
    
    # Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    db = get_db()
    conn = db.conn
    
    try:
        # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
        content_type = "text"
        content = message.text or message.caption or ""
        file_id = None
        
        if message.photo:
            content_type = "photo"
            file_id = message.photo[-1].file_id
        elif message.video:
            content_type = "video"
            file_id = message.video.file_id
        elif message.document:
            content_type = "document"
            file_id = message.document.file_id
        elif message.voice:
            content_type = "voice"
            file_id = message.voice.file_id
        
        conn.execute("""
            INSERT INTO contact_messages 
            (from_user_id, from_username, message_id, content_type, content, file_id, sent_at, is_replied)
            VALUES (?, ?, ?, ?, ?, ?, datetime('now'), 0)
        """, (
            message.from_user.id,
            message.from_user.username,
            message.message_id,
            content_type,
            content,
            file_id
        ))
        conn.commit()
        
        await message.answer(
            "âœ… <b>ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
            "Ø´ÙƒØ±Ø§Ù‹ Ù„ØªÙˆØ§ØµÙ„Ùƒ Ù…Ø¹Ù†Ø§ØŒ Ø³Ù†Ø±Ø¯ Ø¹Ù„ÙŠÙƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª ğŸ’š",
            parse_mode="HTML"
        )
        
        # Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†
        admins = db.get_admins()
        for admin_id in admins:
            try:
                await message.bot.send_message(
                    admin_id,
                    f"ğŸ“¬ <b>Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù†:</b>\n"
                    f"â€¢ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {message.from_user.full_name or 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}\n"
                    f"â€¢ ID: <code>{message.from_user.id}</code>\n"
                    f"â€¢ Ø§Ù„Ù†Øµ: {content[:100]}...\n\n"
                    f"Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰: Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… â† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©",
                    parse_mode="HTML"
                )
            except:
                pass
                
    except Exception as e:
        logger.error(f"Error saving contact message: {e}")
        await message.answer("âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
    
    await state.clear()
    await cmd_start(message)

@router.message(F.text.in_(["Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª"]))
async def btn_add_bot_help(message: types.Message, state: FSMContext):
    """Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"""
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª
    bot_info = await message.bot.get_me()
    bot_username = bot_info.username
    
    text = f"""
<b>Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</b>

Ø§Ø³Ù… Ø§Ù„Ø¨ÙˆØª: @{bot_username}

<b>Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª Ù„Ù‚Ù†Ø§Ø©:</b>

1. Ø§ÙØªØ­ Ù‚Ù†Ø§ØªÙƒ
2. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©
3. Ø§Ø®ØªØ± Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†
4. Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù
5. Ø§Ø¨Ø­Ø« Ø¹Ù†: <code>@{bot_username}</code>
6. ÙØ¹Ù‘Ù„ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù†Ø´Ø±
7. Ø§Ø­ÙØ¸

<b>Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:</b>

1. Ø§ÙØªØ­ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ
2. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
3. Ø¥Ø¶Ø§ÙØ© Ø£Ø¹Ø¶Ø§Ø¡
4. Ø§Ø¨Ø­Ø« Ø¹Ù†: <code>@{bot_username}</code>
5. Ø£Ø¶Ù Ø§Ù„Ø¨ÙˆØª
6. Ø§Ù…Ù†Ø­ ØµÙ„Ø§Ø­ÙŠØ© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„

<b>Ù…Ù„Ø§Ø­Ø¸Ø©:</b>
Ø§Ù„Ø¨ÙˆØª ÙŠØ­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø± Ù„ÙŠØ¹Ù…Ù„
ÙŠØ¯Ø¹Ù… Ø§Ù„Ø¥Ø°Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠØ©
"""
    
    # Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø³Ø±ÙŠØ¹Ø©
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù‚Ù†Ø§Ø©",
                url=f"https://t.me/{bot_username}?startchannel=true&admin=post_messages"
            )
        ],
        [
            InlineKeyboardButton(
                text="Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©",
                url=f"https://t.me/{bot_username}?startgroup=true&admin=post_messages"
            )
        ],
        [
            InlineKeyboardButton(
                text="Ø¥ØºÙ„Ø§Ù‚",
                callback_data="close_msg"
            )
        ]
    ])
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text.in_(["Ø§Ù„Ù…Ø³Ø¨Ø­Ø©", "Ø§Ù„ØªØ³Ø¨ÙŠØ­"]))
async def btn_tasbih(message: types.Message, state: FSMContext):
    text = (
        "<b>Ø§Ù„Ù…Ø³Ø¨Ø­Ø© Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©</b>\n\n"
        "Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ³Ø¨ÙŠØ­:"
    )
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©"), types.KeyboardButton(text="Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# ==========================================
# Handlers Ø§Ù„Ù…Ø³Ø¨Ø­Ø© Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©
# ==========================================

@router.message(F.text == "Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©")
async def btn_tasbih_salah(message: types.Message, state: FSMContext):
    """ØªØ³Ø¨ÙŠØ­ Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø© Ø§Ù„Ù…Ø£Ø«ÙˆØ±"""
    
    hadith_text = """
<b>Ø§Ù„Ù…Ø³Ø¨Ø­Ø© Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©</b>


<b>ğŸ•Œ Ø£Ø°ÙƒØ§Ø± Ø¯Ø¨Ø± Ø§Ù„ØµÙ„Ø§Ø©</b>

<b>ğŸ“– Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø´Ø±ÙŠÙ:</b>
Ø¹Ù† Ø£Ø¨ÙŠ Ù‡Ø±ÙŠØ±Ø© Ø±Ø¶ÙŠ Ø§Ù„Ù„Ù‡ Ø¹Ù†Ù‡ Ù‚Ø§Ù„ Ø±Ø³ÙˆÙ„ Ø§Ù„Ù„Ù‡ ï·º:
"Ù…Ù† Ø³Ø¨Ù‘Ø­ Ø§Ù„Ù„Ù‡ ÙÙŠ Ø¯Ø¨Ø± ÙƒÙ„ ØµÙ„Ø§Ø© Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙˆØ­Ù…Ø¯ Ø§Ù„Ù„Ù‡ Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙˆÙƒØ¨Ù‘Ø± Ø§Ù„Ù„Ù‡ Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙØªÙ„Ùƒ ØªØ³Ø¹Ø© ÙˆØªØ³Ø¹ÙˆÙ†ØŒ ÙˆÙ‚Ø§Ù„ ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø§Ø¦Ø©: Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±ØŒ ØºÙÙØ±Øª Ø®Ø·Ø§ÙŠØ§Ù‡ ÙˆØ¥Ù† ÙƒØ§Ù†Øª Ù…Ø«Ù„ Ø²Ø¨Ø¯ Ø§Ù„Ø¨Ø­Ø±"

<b>Ø§Ù„Ø±Ø§ÙˆÙŠ:</b> Ø£Ø¨Ùˆ Ù‡Ø±ÙŠØ±Ø© Ø±Ø¶ÙŠ Ø§Ù„Ù„Ù‡ Ø¹Ù†Ù‡
<b>Ø§Ù„Ù…ØµØ¯Ø±:</b> ØµØ­ÙŠØ­ Ù…Ø³Ù„Ù… (597)
<b>Ø§Ù„Ø­ÙƒÙ…:</b> Ø­Ø¯ÙŠØ« ØµØ­ÙŠØ­
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¨ÙŠØ­", callback_data="tasbih_salah_start")],
        [InlineKeyboardButton(text="Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©", callback_data="tasbih_salah_info")]
    ])
    
    await message.answer(hadith_text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "tasbih_salah_info")
async def cb_tasbih_salah_info(callback: types.CallbackQuery):
    """Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† ØªØ³Ø¨ÙŠØ­ Ø§Ù„ØµÙ„Ø§Ø©"""
    
    info_text = """
<b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©</b>

<b>Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø£Ø«ÙˆØ±:</b>
â€¢ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ (33 Ù…Ø±Ø©)
â€¢ Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ (33 Ù…Ø±Ø©)
â€¢ Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø± (33 Ù…Ø±Ø©)
â€¢ ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø©: Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±

<b>Ø§Ù„ÙˆÙ‚Øª:</b>
â€¢ ÙŠÙÙ‚Ø§Ù„ Ø¨Ø¹Ø¯ ÙƒÙ„ ØµÙ„Ø§Ø© Ù…ÙØ±ÙˆØ¶Ø©
â€¢ ÙŠØ³ØªØ­Ø¨ Ù‚ÙˆÙ„Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø³Ù„Ø§Ù…

<b>Ù†ØµÙŠØ­Ø©:</b>
Ø§Ø³ØªØ®Ø¯Ù… Ø£ØµØ§Ø¨Ø¹ ÙŠØ¯Ùƒ Ø§Ù„ÙŠÙ…Ù†Ù‰ Ù„Ù„Ø¹Ø¯ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø³Ø¨Ø­Ø© Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¨ÙŠØ­", callback_data="tasbih_salah_start")],
        [InlineKeyboardButton(text="Ø¥ØºÙ„Ø§Ù‚", callback_data="close_msg")]
    ])
    
    await callback.message.edit_text(info_text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "tasbih_salah_start")
async def cb_tasbih_salah_start(callback: types.CallbackQuery, state: FSMContext):
    """Ø¨Ø¯Ø¡ ØªØ³Ø¨ÙŠØ­ Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©"""
    
    await state.update_data(
        tasbih_type="salah",
        stage=1,  # 1=ØªØ³Ø¨ÙŠØ­ØŒ 2=Ø­Ù…Ø¯ØŒ 3=ØªÙƒØ¨ÙŠØ±ØŒ 4=ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø©
        count=0,
        total=0
    )
    
    await update_tasbih_display(callback.message, state, edit=True)
    await callback.answer()

@router.message(F.text == "Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡")
async def btn_tasbih_free(message: types.Message, state: FSMContext):
    """ØªØ³Ø¨ÙŠØ­ Ø­Ø± - Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø°ÙƒØ±"""
    
    text = """
<b>Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡</b>

Ø§Ø®ØªØ± Ø§Ù„Ø°ÙƒØ± Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯:
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_tasbih"),
         InlineKeyboardButton(text="Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡", callback_data="tasbih_free_hamd")],
        [InlineKeyboardButton(text="Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±", callback_data="tasbih_free_takbir"),
         InlineKeyboardButton(text="Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_tahlil")],
        [InlineKeyboardButton(text="Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_istighfar"),
         InlineKeyboardButton(text="Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ ï·º", callback_data="tasbih_free_salawat")]
    ])
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "tasbih_free_info")
async def cb_tasbih_free_info(callback: types.CallbackQuery):
    """Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ø­Ø±Ø©"""
    
    info_text = """
ğŸ“š <b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø£Ø°ÙƒØ§Ø±</b>

ğŸŒŸ <b>Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡:</b>
â€¢ ØªÙ†Ø²ÙŠÙ‡ Ø§Ù„Ù„Ù‡ Ø¹Ù† ÙƒÙ„ Ù†Ù‚Øµ
â€¢ Ù…Ù† Ø£Ø­Ø¨ Ø§Ù„ÙƒÙ„Ø§Ù… Ø¥Ù„Ù‰ Ø§Ù„Ù„Ù‡

ğŸ™ <b>Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡:</b>
â€¢ Ø´ÙƒØ± Ø§Ù„Ù„Ù‡ Ø¹Ù„Ù‰ Ù†Ø¹Ù…Ù‡
â€¢ Ø®ÙŠØ± Ø§Ù„Ø¯Ø¹Ø§Ø¡ Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡

ğŸ“¢ <b>Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±:</b>
â€¢ Ø¥Ø«Ø¨Ø§Øª Ø¹Ø¸Ù…Ø© Ø§Ù„Ù„Ù‡
â€¢ ØªÙƒØ¨ÙŠØ±Ø© Ø§Ù„Ø¥Ø­Ø±Ø§Ù… ÙÙŠ Ø§Ù„ØµÙ„Ø§Ø©

âœ¨ <b>Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡:</b>
â€¢ Ø£Ø¹Ø¸Ù… ÙƒÙ„Ù…Ø© ÙÙŠ Ø§Ù„Ø¥Ø³Ù„Ø§Ù…
â€¢ Ù…ÙØªØ§Ø­ Ø§Ù„Ø¬Ù†Ø©

ğŸ¤² <b>Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡:</b>
â€¢ Ø·Ù„Ø¨ Ø§Ù„Ù…ØºÙØ±Ø© Ù…Ù† Ø§Ù„Ù„Ù‡
â€¢ Ø³ÙŠØ¯ Ø§Ù„Ø§Ø³ØªØºÙØ§Ø±

ğŸ’š <b>Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ ï·º:</b>
â€¢ ÙØ¶Ù„Ù‡Ø§ Ø¹Ø¸ÙŠÙ…
â€¢ ØªÙƒÙÙ‘Ø± Ø§Ù„Ø°Ù†ÙˆØ¨ ÙˆØªÙØ±Ø¬ Ø§Ù„ÙƒØ±Ø¨Ø§Øª

ğŸ’¡ <b>Ù†ØµÙŠØ­Ø©:</b>
ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ¯ Ù‡Ø¯Ù (33ØŒ 100ØŒ Ø£Ùˆ Ø£ÙŠ Ø¹Ø¯Ø¯ ØªØ±ÙŠØ¯Ù‡)
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø±Ø¬ÙˆØ¹", callback_data="tasbih_free_back")],
        [InlineKeyboardButton(text="Ø¥ØºÙ„Ø§Ù‚", callback_data="close_msg")]
    ])
    
    await callback.message.edit_text(info_text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "tasbih_free_back")
async def cb_tasbih_free_back(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø°ÙƒØ§Ø±"""
    
    text = """
ğŸ“¿ <b>Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡</b>

Ø§Ø®ØªØ± Ø§Ù„Ø°ÙƒØ± Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯:
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_tasbih")],
        [InlineKeyboardButton(text="Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡", callback_data="tasbih_free_hamd")],
        [InlineKeyboardButton(text="Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±", callback_data="tasbih_free_takbir")],
        [InlineKeyboardButton(text="Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_tahlil")],
        [InlineKeyboardButton(text="Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_istighfar")],
        [InlineKeyboardButton(text="Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ ï·º", callback_data="tasbih_free_salawat")],
        [InlineKeyboardButton(text="Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="tasbih_free_info")]
    ])
    
    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()

@router.callback_query(F.data.startswith("tasbih_free_"))
async def cb_tasbih_free_start(callback: types.CallbackQuery, state: FSMContext):
    """Ø¨Ø¯Ø¡ ØªØ³Ø¨ÙŠØ­ Ø­Ø±"""
    
    if callback.data == "tasbih_free_info" or callback.data == "tasbih_free_back":
        return
    
    dhikr_type = callback.data.replace("tasbih_free_", "")
    
    dhikr_map = {
        "tasbih": {"text": "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡", "emoji": ""},
        "hamd": {"text": "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡", "emoji": ""},
        "takbir": {"text": "Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±", "emoji": ""},
        "tahlil": {"text": "Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡", "emoji": ""},
        "istighfar": {"text": "Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡", "emoji": ""},
        "salawat": {"text": "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ Ø¹Ù„Ù‰ Ù…Ø­Ù…Ø¯", "emoji": ""}
    }
    
    if dhikr_type not in dhikr_map:
        return
    
    dhikr_info = dhikr_map[dhikr_type]
    
    await state.update_data(
        tasbih_type="free",
        dhikr_type=dhikr_type,
        dhikr_text=dhikr_info["text"],
        dhikr_emoji=dhikr_info["emoji"],
        count=0
    )
    
    await update_free_tasbih_display(callback.message, state, edit=True)
    await callback.answer()

async def update_tasbih_display(message, state: FSMContext, edit=False):
    """ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ ØªØ³Ø¨ÙŠØ­ Ø§Ù„ØµÙ„Ø§Ø©"""
    
    data = await state.get_data()
    stage = data.get("stage", 1)
    count = data.get("count", 0)
    total = data.get("total", 0)
    
    stage_info = {
        1: {"text": "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡", "emoji": "", "target": 33},
        2: {"text": "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡", "emoji": "", "target": 33},
        3: {"text": "Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±", "emoji": "", "target": 33},
        4: {"text": "Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±", "emoji": "", "target": 1}
    }
    
    current = stage_info[stage]
    
    # Ø¨Ù†Ø§Ø¡ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù…
    progress = "â–°" * count + "â–±" * (current["target"] - count)
    
    if stage <= 3:
        text = f"""

  ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©</b>  


{current['emoji']} <b>{current['text']}</b>

ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: <code>{count}</code> / <code>{current['target']}</code>
{progress}

ğŸ“ˆ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{total}</code> / <code>99</code>



Ø§Ù„Ù…Ø±Ø§Ø­Ù„:
{'âœ…' if stage > 1 else 'â³'} Ø§Ù„ØªØ³Ø¨ÙŠØ­ (33)
{'âœ…' if stage > 2 else 'â³'} Ø§Ù„Ø­Ù…Ø¯ (33)
{'âœ…' if stage > 3 else 'â³'} Ø§Ù„ØªÙƒØ¨ÙŠØ± (33)
{'â³'} ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø© (1)
"""
    else:
        text = f"""

  ğŸ“¿ <b>ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø©</b>  


{current['emoji']} <b>Ù‚Ù„ Ø§Ù„Ø¢Ù†:</b>

"{current['text']}"



ğŸ“ˆ Ø£ØªÙ…Ù…Øª: <code>99</code> Ø°ÙƒØ±Ø§Ù‹

ğŸ’š Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ø¨Ø¹Ø¯ Ù‚ÙˆÙ„Ù‡Ø§
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"{current['emoji']} +1", callback_data="tasbih_salah_inc")],
        [InlineKeyboardButton(text="Ø¥Ø¹Ø§Ø¯Ø©", callback_data="tasbih_salah_reset"),
         InlineKeyboardButton(text="Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="tasbih_salah_info")],
        [InlineKeyboardButton(text="Ø¥Ù†Ù‡Ø§Ø¡", callback_data="tasbih_salah_end")]
    ])
    
    if edit:
        try:
            await message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        except:
            await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    else:
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

async def update_free_tasbih_display(message, state: FSMContext, edit=False):
    """ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„ØªØ³Ø¨ÙŠØ­ Ø§Ù„Ø­Ø±"""
    
    data = await state.get_data()
    count = data.get("count", 0)
    dhikr_text = data.get("dhikr_text", "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡")
    dhikr_emoji = data.get("dhikr_emoji", "âœ¨")
    
    # Ø§Ù‚ØªØ±Ø§Ø­ Ø£Ù‡Ø¯Ø§Ù
    suggested_targets = [33, 100, 1000]
    next_target = None
    for target in suggested_targets:
        if count < target:
            next_target = target
            break
    
    text = f"""

  ğŸ“¿ <b>Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡</b>  


{dhikr_emoji} <b>{dhikr_text}</b>

ğŸ“Š Ø§Ù„Ø¹Ø¯Ø¯: <code>{count}</code>
"""
    
    if next_target:
        remaining = next_target - count
        progress_percent = (count / next_target) * 100
        progress_bar = "â–°" * int(progress_percent // 10) + "â–±" * (10 - int(progress_percent // 10))
        text += f"""
ğŸ¯ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ØªØ§Ù„ÙŠ: <code>{next_target}</code>
ğŸ“‰ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <code>{remaining}</code>
{progress_bar} <code>{progress_percent:.0f}%</code>
"""
    
    if count >= 33:
        text += f"\nâœ¨ Ù…Ø§ Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡! Ø£ÙƒÙ…Ù„Øª {count} Ø°ÙƒØ±"
    if count >= 100:
        text += f"\nğŸŒŸ Ø¨Ø§Ø±Ùƒ Ø§Ù„Ù„Ù‡ ÙÙŠÙƒ! ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ù…Ø¦Ø©"
    if count >= 1000:
        text += f"\nğŸ† Ø§Ù„Ù„Ù‡Ù… Ø¨Ø§Ø±Ùƒ! Ø£Ù„Ù Ø°ÙƒØ±!"
    
    text += "\n\n"
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"{dhikr_emoji} +1", callback_data="tasbih_free_inc"),
         InlineKeyboardButton(text="+10", callback_data="tasbih_free_inc10")],
        [InlineKeyboardButton(text="Ø¥Ø¹Ø§Ø¯Ø©", callback_data="tasbih_free_reset"),
         InlineKeyboardButton(text="ØªØºÙŠÙŠØ± Ø§Ù„Ø°ÙƒØ±", callback_data="tasbih_free_back")],
        [InlineKeyboardButton(text="Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="tasbih_free_info"),
         InlineKeyboardButton(text="Ø¥Ù†Ù‡Ø§Ø¡", callback_data="tasbih_free_end")]
    ])
    
    if edit:
        try:
            await message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
        except:
            await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    else:
        await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "tasbih_salah_inc")
async def cb_tasbih_salah_inc(callback: types.CallbackQuery, state: FSMContext):
    """Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø§Ø¯ ØªØ³Ø¨ÙŠØ­ Ø§Ù„ØµÙ„Ø§Ø©"""
    
    data = await state.get_data()
    stage = data.get("stage", 1)
    count = data.get("count", 0)
    total = data.get("total", 0)
    
    count += 1
    total += 1
    
    stage_targets = {1: 33, 2: 33, 3: 33, 4: 1}
    
    if count >= stage_targets[stage]:
        if stage < 4:
            # Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
            await state.update_data(stage=stage + 1, count=0, total=total)
            await update_tasbih_display(callback.message, state, edit=True)
            await callback.answer(f"âœ… Ø£ØªÙ…Ù…Øª Ø§Ù„Ù…Ø±Ø­Ù„Ø© {stage}!", show_alert=False)
        else:
            # Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ØªØ³Ø¨ÙŠØ­
            text = """

  âœ… <b>ØªÙ… Ø¨Ø­Ù…Ø¯ Ø§Ù„Ù„Ù‡!</b>  


ğŸ‰ <b>Ø£ØªÙ…Ù…Øª Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©</b>

ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>100</code> Ø°ÙƒØ±

ğŸ’š <b>ÙØ¶Ù„ Ù‡Ø°Ø§ Ø§Ù„Ø°ÙƒØ±:</b>
"ØºÙÙØ±Øª Ø®Ø·Ø§ÙŠØ§Ù‡ ÙˆØ¥Ù† ÙƒØ§Ù†Øª Ù…Ø«Ù„ Ø²Ø¨Ø¯ Ø§Ù„Ø¨Ø­Ø±"

ğŸ¤² <b>ØªÙ‚Ø¨Ù„ Ø§Ù„Ù„Ù‡ Ù…Ù†Ùƒ ÙˆØ¬Ø¹Ù„Ù‡ ÙÙŠ Ù…ÙŠØ²Ø§Ù† Ø­Ø³Ù†Ø§ØªÙƒ</b>


"""
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Ø¥Ø¹Ø§Ø¯Ø©", callback_data="tasbih_salah_start")],
                [InlineKeyboardButton(text="Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡", callback_data="tasbih_goto_free")],
                [InlineKeyboardButton(text="Ø¥Ù†Ù‡Ø§Ø¡", callback_data="close_msg")]
            ])
            
            await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
            await state.clear()
            await callback.answer("âœ… ØªÙ… Ø¨Ø­Ù…Ø¯ Ø§Ù„Ù„Ù‡!", show_alert=True)
    else:
        await state.update_data(count=count, total=total)
        await update_tasbih_display(callback.message, state, edit=True)
        await callback.answer()

@router.callback_query(F.data == "tasbih_free_inc")
async def cb_tasbih_free_inc(callback: types.CallbackQuery, state: FSMContext):
    """Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ³Ø¨ÙŠØ­ Ø§Ù„Ø­Ø±"""
    
    data = await state.get_data()
    count = data.get("count", 0)
    
    count += 1
    await state.update_data(count=count)
    
    await update_free_tasbih_display(callback.message, state, edit=True)
    await callback.answer()

@router.callback_query(F.data == "tasbih_free_inc10")
async def cb_tasbih_free_inc10(callback: types.CallbackQuery, state: FSMContext):
    """Ø²ÙŠØ§Ø¯Ø© 10 Ù„Ù„Ø¹Ø¯Ø§Ø¯"""
    
    data = await state.get_data()
    count = data.get("count", 0)
    
    count += 10
    await state.update_data(count=count)
    
    await update_free_tasbih_display(callback.message, state, edit=True)
    await callback.answer("+10 âœ¨")

@router.callback_query(F.data == "tasbih_salah_reset")
async def cb_tasbih_salah_reset(callback: types.CallbackQuery, state: FSMContext):
    """Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ø¨ÙŠØ­ Ø§Ù„ØµÙ„Ø§Ø©"""
    
    await state.update_data(stage=1, count=0, total=0)
    await update_tasbih_display(callback.message, state, edit=True)
    await callback.answer("ğŸ”„ ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ø¨ÙŠØ­")

@router.callback_query(F.data == "tasbih_free_reset")
async def cb_tasbih_free_reset(callback: types.CallbackQuery, state: FSMContext):
    """Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ø¨ÙŠØ­ Ø§Ù„Ø­Ø±"""
    
    await state.update_data(count=0)
    await update_free_tasbih_display(callback.message, state, edit=True)
    await callback.answer("ğŸ”„ ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¹Ø¯Ø§Ø¯")

@router.callback_query(F.data == "tasbih_salah_end")
async def cb_tasbih_salah_end(callback: types.CallbackQuery, state: FSMContext):
    """Ø¥Ù†Ù‡Ø§Ø¡ ØªØ³Ø¨ÙŠØ­ Ø§Ù„ØµÙ„Ø§Ø©"""
    
    data = await state.get_data()
    total = data.get("total", 0)
    
    await callback.message.delete()
    await state.clear()
    await callback.answer(f"ØªÙ… Ø­ÙØ¸ {total} Ø°ÙƒØ± âœ…")

@router.callback_query(F.data == "tasbih_free_end")
async def cb_tasbih_free_end(callback: types.CallbackQuery, state: FSMContext):
    """Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ³Ø¨ÙŠØ­ Ø§Ù„Ø­Ø±"""
    
    data = await state.get_data()
    count = data.get("count", 0)
    dhikr_text = data.get("dhikr_text", "")
    
    await callback.message.delete()
    await state.clear()
    await callback.answer(f"ØªÙ… Ø­ÙØ¸ {count} Ù…Ù† {dhikr_text} âœ…")

@router.callback_query(F.data == "tasbih_goto_free")
async def cb_tasbih_goto_free(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØªØ³Ø¨ÙŠØ­ Ø§Ù„Ø­Ø±"""
    
    text = """
ğŸ“¿ <b>Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡</b>

Ø§Ø®ØªØ± Ø§Ù„Ø°ÙƒØ± Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯:
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_tasbih")],
        [InlineKeyboardButton(text="Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡", callback_data="tasbih_free_hamd")],
        [InlineKeyboardButton(text="Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±", callback_data="tasbih_free_takbir")],
        [InlineKeyboardButton(text="Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_tahlil")],
        [InlineKeyboardButton(text="Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡", callback_data="tasbih_free_istighfar")],
        [InlineKeyboardButton(text="Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ ï·º", callback_data="tasbih_free_salawat")],
        [InlineKeyboardButton(text="Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="tasbih_free_info")]
    ])
    
    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await state.clear()

# ==========================================
# Handlers Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø© (Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø°ÙƒØ§Ø±)
# ==========================================

@router.message(F.text.in_(["Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©", "Ø£Ø°ÙƒØ§Ø± Ø§Ù„ØµÙ„Ø§Ø©"]))
async def btn_azkar_salah(message: types.Message, state: FSMContext):
    """Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø© Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø°ÙƒØ§Ø±"""
    
    hadith_text = """
ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø© Ø§Ù„Ù…Ø£Ø«ÙˆØ±Ø©</b>

ğŸ“– <b>Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø´Ø±ÙŠÙ:</b>
Ø¹Ù† Ø±Ø³ÙˆÙ„ Ø§Ù„Ù„Ù‡ ï·º: <b>Ù…Ù† Ø³Ø¨Ù‘Ø­ Ø§Ù„Ù„Ù‡ ÙÙŠ Ø¯ÙØ¨ÙØ± ÙƒÙ„ ØµÙ„Ø§Ø© Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙˆØ­Ù…Ø¯ Ø§Ù„Ù„Ù‡ Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙˆÙƒØ¨Ù‘Ø± Ø§Ù„Ù„Ù‡ Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙØªÙ„Ùƒ ØªØ³Ø¹Ø© ÙˆØªØ³Ø¹ÙˆÙ†ØŒ ÙˆÙ‚Ø§Ù„ ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø©: Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±ØŒ ØºÙÙØ±Øª Ø®Ø·Ø§ÙŠØ§Ù‡ ÙˆØ¥Ù† ÙƒØ§Ù†Øª Ù…Ø«Ù„ Ø²Ø¨Ø¯ Ø§Ù„Ø¨Ø­Ø±.</b>

âœ… <b>Ø­ÙƒÙ… Ø§Ù„Ù…Ø­Ø¯Ø«:</b> [ØµØ­ÙŠØ­]
ğŸ‘¤ <b>Ø§Ù„Ø±Ø§ÙˆÙŠ:</b> Ø£Ø¨Ùˆ Ù‡Ø±ÙŠØ±Ø© Ø±Ø¶ÙŠ Ø§Ù„Ù„Ù‡ Ø¹Ù†Ù‡
ğŸ“š <b>Ø§Ù„Ù…ØµØ¯Ø±:</b> ØµØ­ÙŠØ­ Ù…Ø³Ù„Ù… (597)



ğŸ¯ <b>Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†:</b>
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¨ÙŠØ­", callback_data="tasbih_salah_start")],
        [InlineKeyboardButton(text="Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="tasbih_salah_info")],
        [InlineKeyboardButton(text="Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙƒÙ†Øµ", callback_data="azkar_salah_text")]
    ])
    
    await message.answer(hadith_text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "azkar_salah_text")
async def cb_azkar_salah_text(callback: types.CallbackQuery):
    """Ø¹Ø±Ø¶ Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø© ÙƒÙ†Øµ"""
    
    text = """
ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©</b>

1ï¸âƒ£ <b>Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡</b> (33 Ù…Ø±Ø©)

2ï¸âƒ£ <b>Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡</b> (33 Ù…Ø±Ø©)

3ï¸âƒ£ <b>Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±</b> (33 Ù…Ø±Ø©)

4ï¸âƒ£ <b>ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø©:</b>
Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±



ğŸ“š <b>Ø£Ø°ÙƒØ§Ø± Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø©:</b>

â€¢ Ø£Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ (3 Ù…Ø±Ø§Øª)
â€¢ Ø§Ù„Ù„Ù‡Ù… Ø£Ù†Øª Ø§Ù„Ø³Ù„Ø§Ù… ÙˆÙ…Ù†Ùƒ Ø§Ù„Ø³Ù„Ø§Ù… ØªØ¨Ø§Ø±ÙƒØª ÙŠØ§ Ø°Ø§ Ø§Ù„Ø¬Ù„Ø§Ù„ ÙˆØ§Ù„Ø¥ÙƒØ±Ø§Ù…
â€¢ Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±...
â€¢ Ø¢ÙŠØ© Ø§Ù„ÙƒØ±Ø³ÙŠ

âœ¨ <b>ÙŠØ³ØªØ­Ø¨ Ù‚Ø±Ø§Ø¡Ø©:</b>
â€¢ Ø³ÙˆØ±Ø© Ø§Ù„Ø¥Ø®Ù„Ø§Øµ (3 Ù…Ø±Ø§Øª)
â€¢ Ø³ÙˆØ±Ø© Ø§Ù„ÙÙ„Ù‚ (3 Ù…Ø±Ø§Øª)
â€¢ Ø³ÙˆØ±Ø© Ø§Ù„Ù†Ø§Ø³ (3 Ù…Ø±Ø§Øª)
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¨ÙŠØ­", callback_data="tasbih_salah_start")],
        [InlineKeyboardButton(text="Ø±Ø¬ÙˆØ¹", callback_data="azkar_salah_back")]
    ])
    
    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")

@router.callback_query(F.data == "azkar_salah_back")
async def cb_azkar_salah_back(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø£Ø°ÙƒØ§Ø± Ø§Ù„ØµÙ„Ø§Ø©"""
    
    hadith_text = """
ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØµÙ„Ø§Ø© Ø§Ù„Ù…Ø£Ø«ÙˆØ±Ø©</b>

ğŸ“– <b>Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø´Ø±ÙŠÙ:</b>
Ø¹Ù† Ø±Ø³ÙˆÙ„ Ø§Ù„Ù„Ù‡ ï·º: <b>Ù…Ù† Ø³Ø¨Ù‘Ø­ Ø§Ù„Ù„Ù‡ ÙÙŠ Ø¯ÙØ¨ÙØ± ÙƒÙ„ ØµÙ„Ø§Ø© Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙˆØ­Ù…Ø¯ Ø§Ù„Ù„Ù‡ Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙˆÙƒØ¨Ù‘Ø± Ø§Ù„Ù„Ù‡ Ø«Ù„Ø§Ø«Ø§Ù‹ ÙˆØ«Ù„Ø§Ø«ÙŠÙ†ØŒ ÙØªÙ„Ùƒ ØªØ³Ø¹Ø© ÙˆØªØ³Ø¹ÙˆÙ†ØŒ ÙˆÙ‚Ø§Ù„ ØªÙ…Ø§Ù… Ø§Ù„Ù…Ø¦Ø©: Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±ØŒ ØºÙÙØ±Øª Ø®Ø·Ø§ÙŠØ§Ù‡ ÙˆØ¥Ù† ÙƒØ§Ù†Øª Ù…Ø«Ù„ Ø²Ø¨Ø¯ Ø§Ù„Ø¨Ø­Ø±.</b>

âœ… <b>Ø­ÙƒÙ… Ø§Ù„Ù…Ø­Ø¯Ø«:</b> [ØµØ­ÙŠØ­]
ğŸ‘¤ <b>Ø§Ù„Ø±Ø§ÙˆÙŠ:</b> Ø£Ø¨Ùˆ Ù‡Ø±ÙŠØ±Ø© Ø±Ø¶ÙŠ Ø§Ù„Ù„Ù‡ Ø¹Ù†Ù‡
ğŸ“š <b>Ø§Ù„Ù…ØµØ¯Ø±:</b> ØµØ­ÙŠØ­ Ù…Ø³Ù„Ù… (597)



ğŸ¯ <b>Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†:</b>
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¨ÙŠØ­", callback_data="tasbih_salah_start")],
        [InlineKeyboardButton(text="Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="tasbih_salah_info")],
        [InlineKeyboardButton(text="Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙƒÙ†Øµ", callback_data="azkar_salah_text")]
    ])
    
    await callback.message.edit_text(hadith_text, reply_markup=keyboard, parse_mode="HTML")
    await callback.answer()

# ==========================================
# Handlers Ø§Ù„Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø­ØµÙ† Ø§Ù„Ù…Ø³Ù„Ù…
# ==========================================

@router.message(F.text == "Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ø§Ø³ØªÙŠÙ‚Ø§Ø¸")
async def btn_azkar_istiqaz(message: types.Message):
    text = """
ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ø§Ø³ØªÙŠÙ‚Ø§Ø¸ Ù…Ù† Ø§Ù„Ù†ÙˆÙ…</b>

1ï¸âƒ£ <b>Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø³ØªÙŠÙ‚Ø§Ø¸:</b>
Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ø£Ø­ÙŠØ§Ù†Ø§ Ø¨Ø¹Ø¯ Ù…Ø§ Ø£Ù…Ø§ØªÙ†Ø§ ÙˆØ¥Ù„ÙŠÙ‡ Ø§Ù„Ù†Ø´ÙˆØ±

2ï¸âƒ£ <b>Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„Ø¹ÙŠÙ†ÙŠÙ†:</b>
Ø§Ù„Ø­Ù…Ø¯Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ø¹Ø§ÙØ§Ù†ÙŠ ÙÙŠ Ø¬Ø³Ø¯ÙŠ ÙˆØ±Ø¯ Ø¹Ù„ÙŠ Ø±ÙˆØ­ÙŠ ÙˆØ£Ø°Ù† Ù„ÙŠ Ø¨Ø°ÙƒØ±Ù‡

3ï¸âƒ£ <b>Ø¹Ù†Ø¯ Ù…Ø³Ø­ Ø§Ù„ÙˆØ¬Ù‡:</b>
Ø§Ù„Ù„Ù‡Ù… Ø¥Ù†ÙŠ Ø£Ø³Ø£Ù„Ùƒ Ø®ÙŠØ± Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ… ÙˆØ®ÙŠØ± Ù…Ø§ ÙÙŠÙ‡ØŒ ÙˆØ£Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø´Ø±Ù‡ ÙˆØ´Ø± Ù…Ø§ ÙÙŠÙ‡

4ï¸âƒ£ <b>Ù‚Ø±Ø§Ø¡Ø© Ø¢Ø®Ø± 10 Ø¢ÙŠØ§Øª Ù…Ù† Ø³ÙˆØ±Ø© Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†:</b>
Ø¥ÙÙ†ÙÙ‘ ÙÙÙŠ Ø®ÙÙ„Ù’Ù‚Ù Ø§Ù„Ø³ÙÙ‘Ù…ÙØ§ÙˆÙØ§ØªÙ ÙˆÙØ§Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù...

âœ¨ <b>Ø§Ù„ÙØ¶Ù„:</b>
Ù…Ù† Ù‚Ø§Ù„Ù‡Ø§ Ø­ÙŠÙ† ÙŠØ³ØªÙŠÙ‚Ø¸ Ø«Ø¨Ù‘Øª Ø§Ù„Ù„Ù‡ Ù‚Ù„Ø¨Ù‡ ÙˆØ£Ø¹Ø§Ù†Ù‡ Ø¹Ù„Ù‰ Ù‚ÙŠØ§Ù… ÙŠÙˆÙ…Ù‡
"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "Ø£Ø°ÙƒØ§Ø± Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ù†Ø²Ù„")
async def btn_azkar_home(message: types.Message):
    text = """
ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø¯Ø®ÙˆÙ„ ÙˆØ®Ø±ÙˆØ¬ Ø§Ù„Ù…Ù†Ø²Ù„</b>

ğŸ  <b>Ø¹Ù†Ø¯ Ø§Ù„Ø¯Ø®ÙˆÙ„:</b>
Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ ÙˆÙ„Ø¬Ù†Ø§ØŒ ÙˆØ¨Ø³Ù… Ø§Ù„Ù„Ù‡ Ø®Ø±Ø¬Ù†Ø§ØŒ ÙˆØ¹Ù„Ù‰ Ø§Ù„Ù„Ù‡ Ø±Ø¨Ù†Ø§ ØªÙˆÙƒÙ„Ù†Ø§

Ø§Ù„Ù„Ù‡Ù… Ø¥Ù†ÙŠ Ø£Ø³Ø£Ù„Ùƒ Ø®ÙŠØ± Ø§Ù„Ù…ÙˆÙ„Ø¬ ÙˆØ®ÙŠØ± Ø§Ù„Ù…Ø®Ø±Ø¬ØŒ Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ ÙˆÙ„Ø¬Ù†Ø§ØŒ ÙˆØ¨Ø³Ù… Ø§Ù„Ù„Ù‡ Ø®Ø±Ø¬Ù†Ø§ØŒ ÙˆØ¹Ù„Ù‰ Ø§Ù„Ù„Ù‡ Ø±Ø¨Ù†Ø§ ØªÙˆÙƒÙ„Ù†Ø§

ğŸšª <b>Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬:</b>
Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ØŒ ØªÙˆÙƒÙ„Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù‡ØŒ Ù„Ø§ Ø­ÙˆÙ„ ÙˆÙ„Ø§ Ù‚ÙˆØ© Ø¥Ù„Ø§ Ø¨Ø§Ù„Ù„Ù‡

âœ¨ <b>Ø§Ù„ÙØ¶Ù„:</b>
Ù‚Ø§Ù„ Ø±Ø³ÙˆÙ„ Ø§Ù„Ù„Ù‡ ï·º: Â«Ø¥Ø°Ø§ Ø®Ø±Ø¬ Ø§Ù„Ø±Ø¬Ù„ Ù…Ù† Ø¨ÙŠØªÙ‡ ÙÙ‚Ø§Ù„: Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ØŒ ØªÙˆÙƒÙ„Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù‡ØŒ Ù„Ø§ Ø­ÙˆÙ„ ÙˆÙ„Ø§ Ù‚ÙˆØ© Ø¥Ù„Ø§ Ø¨Ø§Ù„Ù„Ù‡ØŒ ÙŠÙÙ‚Ø§Ù„ Ù„Ù‡: ÙƒÙÙÙŠØª ÙˆÙˆÙÙ‚ÙŠØª ÙˆÙ‡ÙØ¯ÙŠØªØŒ ÙØªØªÙ†Ø­Ù‰ Ù„Ù‡ Ø§Ù„Ø´ÙŠØ§Ø·ÙŠÙ†Â»

ğŸ“š <b>Ø§Ù„Ù…ØµØ¯Ø±:</b> Ø³Ù†Ù† Ø£Ø¨ÙŠ Ø¯Ø§ÙˆØ¯
"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ø³ÙØ±")
async def btn_azkar_travel(message: types.Message):
    text = """
ğŸ“¿ <b>Ø£Ø°ÙƒØ§Ø± Ø§Ù„Ø³ÙØ±</b>

âœˆï¸ <b>Ø¯Ø¹Ø§Ø¡ Ø§Ù„Ø³ÙØ±:</b>
Ø³ÙØ¨Ù’Ø­ÙØ§Ù†Ù Ø§Ù„ÙÙ‘Ø°ÙÙŠ Ø³ÙØ®ÙÙ‘Ø±Ù Ù„ÙÙ†ÙØ§ Ù‡ÙØ°ÙØ§ ÙˆÙÙ…ÙØ§ ÙƒÙÙ†ÙÙ‘Ø§ Ù„ÙÙ‡Ù Ù…ÙÙ‚Ù’Ø±ÙÙ†ÙÙŠÙ†Ù * ÙˆÙØ¥ÙÙ†ÙÙ‘Ø§ Ø¥ÙÙ„ÙÙ‰ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ Ù„ÙÙ…ÙÙ†Ù‚ÙÙ„ÙØ¨ÙÙˆÙ†Ù

Ø§Ù„Ù„Ù‡Ù… Ø¥Ù†Ø§ Ù†Ø³Ø£Ù„Ùƒ ÙÙŠ Ø³ÙØ±Ù†Ø§ Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø± ÙˆØ§Ù„ØªÙ‚ÙˆÙ‰ØŒ ÙˆÙ…Ù† Ø§Ù„Ø¹Ù…Ù„ Ù…Ø§ ØªØ±Ø¶Ù‰ØŒ Ø§Ù„Ù„Ù‡Ù… Ù‡ÙˆÙ‘Ù† Ø¹Ù„ÙŠÙ†Ø§ Ø³ÙØ±Ù†Ø§ Ù‡Ø°Ø§ ÙˆØ§Ø·ÙˆÙ Ø¹Ù†Ù‘Ø§ Ø¨ÙØ¹Ø¯Ù‡ØŒ Ø§Ù„Ù„Ù‡Ù… Ø£Ù†Øª Ø§Ù„ØµØ§Ø­Ø¨ ÙÙŠ Ø§Ù„Ø³ÙØ±ØŒ ÙˆØ§Ù„Ø®Ù„ÙŠÙØ© ÙÙŠ Ø§Ù„Ø£Ù‡Ù„

ğŸš— <b>Ø¹Ù†Ø¯ Ø§Ù„Ø±ÙƒÙˆØ¨:</b>
Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ØŒ Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±ØŒ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ø°ÙŠ Ø³Ø®Ø± Ù„Ù†Ø§ Ù‡Ø°Ø§ ÙˆÙ…Ø§ ÙƒÙ†Ø§ Ù„Ù‡ Ù…Ù‚Ø±Ù†ÙŠÙ† ÙˆØ¥Ù†Ø§ Ø¥Ù„Ù‰ Ø±Ø¨Ù†Ø§ Ù„Ù…Ù†Ù‚Ù„Ø¨ÙˆÙ†

ğŸ¨ <b>Ø¯Ø¹Ø§Ø¡ Ù†Ø²ÙˆÙ„ Ø§Ù„Ù…Ù†Ø²Ù„:</b>
Ø£Ø¹ÙˆØ° Ø¨ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù„Ù‡ Ø§Ù„ØªØ§Ù…Ø§Øª Ù…Ù† Ø´Ø± Ù…Ø§ Ø®Ù„Ù‚

ğŸ”™ <b>Ø¹Ù†Ø¯ Ø§Ù„Ø±Ø¬ÙˆØ¹:</b>
Ø¢ÙŠØ¨ÙˆÙ†ØŒ ØªØ§Ø¦Ø¨ÙˆÙ†ØŒ Ø¹Ø§Ø¨Ø¯ÙˆÙ†ØŒ Ù„Ø±Ø¨Ù†Ø§ Ø­Ø§Ù…Ø¯ÙˆÙ†

âœ¨ <b>Ø§Ù„ÙØ¶Ù„:</b>
Ù…Ù† Ù‚Ø§Ù„ Ø¯Ø¹Ø§Ø¡ Ø§Ù„Ø³ÙØ± Ù„Ù… ÙŠØ¶Ø±Ù‡ ÙÙŠ Ø³ÙØ±Ù‡ Ø´ÙŠØ¡
"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "Ø£Ø¯Ø¹ÙŠØ© Ø§Ù„Ù‚Ø±Ø¢Ù†")
async def btn_duas_quran(message: types.Message):
    text = """
ğŸ“¿ <b>Ø£Ø¯Ø¹ÙŠØ© Ù…Ù† Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…</b>

1ï¸âƒ£ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ Ø¢ØªÙÙ†ÙØ§ ÙÙÙŠ Ø§Ù„Ø¯ÙÙ‘Ù†Ù’ÙŠÙØ§ Ø­ÙØ³ÙÙ†ÙØ©Ù‹ ÙˆÙÙÙÙŠ Ø§Ù„Ù’Ø¢Ø®ÙØ±ÙØ©Ù Ø­ÙØ³ÙÙ†ÙØ©Ù‹ ÙˆÙÙ‚ÙÙ†ÙØ§ Ø¹ÙØ°ÙØ§Ø¨Ù Ø§Ù„Ù†ÙÙ‘Ø§Ø±Ù

2ï¸âƒ£ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ Ù„ÙØ§ ØªÙØ²ÙØºÙ’ Ù‚ÙÙ„ÙÙˆØ¨ÙÙ†ÙØ§ Ø¨ÙØ¹Ù’Ø¯Ù Ø¥ÙØ°Ù’ Ù‡ÙØ¯ÙÙŠÙ’ØªÙÙ†ÙØ§ ÙˆÙÙ‡ÙØ¨Ù’ Ù„ÙÙ†ÙØ§ Ù…ÙÙ† Ù„ÙÙ‘Ø¯ÙÙ†ÙƒÙ Ø±ÙØ­Ù’Ù…ÙØ©Ù‹ Ø¥ÙÙ†ÙÙ‘ÙƒÙ Ø£ÙÙ†ØªÙ Ø§Ù„Ù’ÙˆÙÙ‡ÙÙ‘Ø§Ø¨Ù

3ï¸âƒ£ Ø±ÙØ¨ÙÙ‘ Ø§Ø´Ù’Ø±ÙØ­Ù’ Ù„ÙÙŠ ØµÙØ¯Ù’Ø±ÙÙŠ * ÙˆÙÙŠÙØ³ÙÙ‘Ø±Ù’ Ù„ÙÙŠ Ø£ÙÙ…Ù’Ø±ÙÙŠ

4ï¸âƒ£ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ Ø§ØºÙ’ÙÙØ±Ù’ Ù„ÙÙ†ÙØ§ Ø°ÙÙ†ÙÙˆØ¨ÙÙ†ÙØ§ ÙˆÙØ¥ÙØ³Ù’Ø±ÙØ§ÙÙÙ†ÙØ§ ÙÙÙŠ Ø£ÙÙ…Ù’Ø±ÙÙ†ÙØ§ ÙˆÙØ«ÙØ¨ÙÙ‘ØªÙ’ Ø£ÙÙ‚Ù’Ø¯ÙØ§Ù…ÙÙ†ÙØ§ ÙˆÙØ§Ù†ØµÙØ±Ù’Ù†ÙØ§ Ø¹ÙÙ„ÙÙ‰ Ø§Ù„Ù’Ù‚ÙÙˆÙ’Ù…Ù Ø§Ù„Ù’ÙƒÙØ§ÙÙØ±ÙÙŠÙ†Ù

5ï¸âƒ£ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ Ø¸ÙÙ„ÙÙ…Ù’Ù†ÙØ§ Ø£ÙÙ†ÙÙØ³ÙÙ†ÙØ§ ÙˆÙØ¥ÙÙ† Ù„ÙÙ‘Ù…Ù’ ØªÙØºÙ’ÙÙØ±Ù’ Ù„ÙÙ†ÙØ§ ÙˆÙØªÙØ±Ù’Ø­ÙÙ…Ù’Ù†ÙØ§ Ù„ÙÙ†ÙÙƒÙÙˆÙ†ÙÙ†ÙÙ‘ Ù…ÙÙ†Ù Ø§Ù„Ù’Ø®ÙØ§Ø³ÙØ±ÙÙŠÙ†Ù

6ï¸âƒ£ Ø±ÙØ¨ÙÙ‘ Ø§Ø¬Ù’Ø¹ÙÙ„Ù’Ù†ÙÙŠ Ù…ÙÙ‚ÙÙŠÙ…Ù Ø§Ù„ØµÙÙ‘Ù„ÙØ§Ø©Ù ÙˆÙÙ…ÙÙ† Ø°ÙØ±ÙÙ‘ÙŠÙÙ‘ØªÙÙŠ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ ÙˆÙØªÙÙ‚ÙØ¨ÙÙ‘Ù„Ù’ Ø¯ÙØ¹ÙØ§Ø¡Ù

7ï¸âƒ£ Ø±ÙØ¨ÙÙ‘Ù†ÙØ§ Ù‡ÙØ¨Ù’ Ù„ÙÙ†ÙØ§ Ù…ÙÙ†Ù’ Ø£ÙØ²Ù’ÙˆÙØ§Ø¬ÙÙ†ÙØ§ ÙˆÙØ°ÙØ±ÙÙ‘ÙŠÙÙ‘Ø§ØªÙÙ†ÙØ§ Ù‚ÙØ±ÙÙ‘Ø©Ù Ø£ÙØ¹Ù’ÙŠÙÙ†Ù ÙˆÙØ§Ø¬Ù’Ø¹ÙÙ„Ù’Ù†ÙØ§ Ù„ÙÙ„Ù’Ù…ÙØªÙÙ‘Ù‚ÙÙŠÙ†Ù Ø¥ÙÙ…ÙØ§Ù…Ù‹Ø§

8ï¸âƒ£ Ø±ÙØ¨ÙÙ‘ Ø£ÙÙˆÙ’Ø²ÙØ¹Ù’Ù†ÙÙŠ Ø£ÙÙ†Ù’ Ø£ÙØ´Ù’ÙƒÙØ±Ù Ù†ÙØ¹Ù’Ù…ÙØªÙÙƒÙ Ø§Ù„ÙÙ‘ØªÙÙŠ Ø£ÙÙ†Ù’Ø¹ÙÙ…Ù’ØªÙ Ø¹ÙÙ„ÙÙŠÙÙ‘ ÙˆÙØ¹ÙÙ„ÙÙ‰Ù° ÙˆÙØ§Ù„ÙØ¯ÙÙŠÙÙ‘

âœ¨ Ù‡Ø°Ù‡ Ù…Ù† Ø£Ø¹Ø¸Ù… Ø§Ù„Ø£Ø¯Ø¹ÙŠØ© Ù„Ø£Ù†Ù‡Ø§ Ù…Ù† ÙƒÙ„Ø§Ù… Ø§Ù„Ù„Ù‡ ØªØ¹Ø§Ù„Ù‰
"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# ==========================================
# Ø§Ù„Ø®ØªÙ…Ø© - Ù†Ø¸Ø§Ù… Ù…ØªØ·ÙˆØ±
# ==========================================

@router.message(F.text.in_(["Ø§Ù„Ø®ØªÙ…Ø©", "Ø®ØªÙ…Ø© Ù‚Ø±Ø¢Ù†ÙŠØ©", "ğŸ“– Ø§Ù„Ø®ØªÙ…Ø©"]))
async def btn_khatma_menu(message: types.Message, state: FSMContext):
    """Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®ØªÙ…Ø©"""
    await state.clear()  # Ù…Ø³Ø­ Ø£ÙŠ state Ø³Ø§Ø¨Ù‚
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="ğŸ“Š Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©")],
        [types.KeyboardButton(text="ğŸ“… Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ…")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    text = """
<b>ğŸ“– Ø®ØªÙ…Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…</b>

Ø§Ø®ØªØ± Ù…Ø§ ØªØ±ÙŠØ¯:

â€¢ ğŸ“Š <b>Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©:</b> Ø§Ø­Ø³Ø¨ ÙƒÙ… ØªØ­ØªØ§Ø¬ Ù„Ù„Ø®ØªÙ…
â€¢ ğŸ“… <b>Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ…:</b> Ø®Ø·Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ø®ØªÙ…
"""
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text.in_(["ğŸ“Š Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©", "Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©"]))
async def btn_calc_khatma(message: types.Message, state: FSMContext):
    """Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©"""
    
    text = """

  ğŸ“Š <b>Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©</b>  


ğŸ“– <b>Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 604 ØµÙØ­Ø©</b>

ğŸ”¢ <b>Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ØªÙŠ ØªÙ‚Ø±Ø£Ù‡Ø§ ÙŠÙˆÙ…ÙŠØ§Ù‹:</b>

Ù…Ø«Ø§Ù„: <code>10</code> (Ø³ÙŠØ¹Ù†ÙŠ 10 ØµÙØ­Ø§Øª ÙÙŠ Ø§Ù„ÙŠÙˆÙ…)

ğŸ’¡ <b>Ù†ØµØ§Ø¦Ø­:</b>
â€¢ 4 ØµÙØ­Ø§Øª = Ø®ØªÙ…Ø© ÙƒÙ„ 5 Ø£Ø´Ù‡Ø± (151 ÙŠÙˆÙ…)
â€¢ 10 ØµÙØ­Ø§Øª = Ø®ØªÙ…Ø© ÙƒÙ„ Ø´Ù‡Ø±ÙŠÙ† (60 ÙŠÙˆÙ…)  
â€¢ 20 ØµÙØ­Ø§Øª = Ø®ØªÙ…Ø© ÙƒÙ„ Ø´Ù‡Ø± (30 ÙŠÙˆÙ…)


"""
    
    await message.answer(text, parse_mode="HTML", reply_markup=get_cancel_kb())
    await state.set_state(Form.khatma_calc_pages)

@router.message(Form.khatma_calc_pages)
async def process_calc_khatma(message: types.Message, state: FSMContext):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©"""
    
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡", reply_markup=get_main_kb(message.from_user.id))
        return
    
    try:
        pages_per_day = int(message.text)
        
        if pages_per_day <= 0:
            await message.answer("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±")
            return
        
        if pages_per_day > 604:
            await message.answer("âš ï¸ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… 604 ØµÙØ­Ø© ÙÙ‚Ø·!")
            return
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯Ø©
        total_pages = 604
        days_needed = total_pages / pages_per_day
        months = days_needed / 30
        weeks = days_needed / 7
        
        # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø®ØªÙ…Ø§Øª ÙÙŠ Ø§Ù„Ø³Ù†Ø©
        khatmas_per_year = 365 / days_needed
        
        # Ù†ØµØ§Ø¦Ø­ Ù…Ø®ØµØµØ©
        if pages_per_day < 4:
            advice = "ğŸ¢ <b>ÙˆØªÙŠØ±Ø© Ø¨Ø·ÙŠØ¦Ø©:</b> Ù…Ù…ØªØ§Ø²Ø© Ù„Ù„ØªØ¯Ø¨Ø± Ø§Ù„Ø¹Ù…ÙŠÙ‚ ÙˆØ§Ù„ØªØ£Ù…Ù„ ÙÙŠ Ø§Ù„Ø¢ÙŠØ§Øª"
            emoji = "ğŸ¢"
        elif pages_per_day < 10:
            advice = "ğŸš¶ <b>ÙˆØªÙŠØ±Ø© Ù…ØªÙˆØ³Ø·Ø©:</b> ØªÙˆØ§Ø²Ù† Ø¬ÙŠØ¯ Ø¨ÙŠÙ† Ø§Ù„ØªØ¯Ø¨Ø± ÙˆØ§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ©"
            emoji = "ğŸš¶"
        elif pages_per_day < 20:
            advice = "ğŸƒ <b>ÙˆØªÙŠØ±Ø© Ù†Ø´Ø·Ø©:</b> Ø±Ø§Ø¦Ø¹! ØªØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ ØµÙ„Ø© Ù‚ÙˆÙŠØ© Ø¨Ø§Ù„Ù‚Ø±Ø¢Ù†"
            emoji = "ğŸƒ"
        else:
            advice = "ğŸš€ <b>ÙˆØªÙŠØ±Ø© Ø³Ø±ÙŠØ¹Ø©:</b> Ù…Ø°Ù‡Ù„! Ù„ÙƒÙ† Ù„Ø§ ØªÙ†Ø³Ù Ø§Ù„ØªØ¯Ø¨Ø±"
            emoji = "ğŸš€"
        
        # Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ‚Øª
        suggested_times = []
        if pages_per_day <= 4:
            suggested_times = ["Ø¨Ø¹Ø¯ ØµÙ„Ø§Ø© Ø§Ù„ÙØ¬Ø± (ØµÙØ­ØªØ§Ù†)", "Ù‚Ø¨Ù„ Ø§Ù„Ù†ÙˆÙ… (ØµÙØ­ØªØ§Ù†)"]
        elif pages_per_day <= 10:
            suggested_times = ["Ø¨Ø¹Ø¯ Ø§Ù„ÙØ¬Ø± (4 ØµÙØ­Ø§Øª)", "Ø¨Ø¹Ø¯ Ø§Ù„Ø¹ØµØ± (3 ØµÙØ­Ø§Øª)", "Ù‚Ø¨Ù„ Ø§Ù„Ù†ÙˆÙ… (3 ØµÙØ­Ø§Øª)"]
        else:
            suggested_times = ["Ù…ÙˆØ²Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„ØµÙ„ÙˆØ§Øª Ø§Ù„Ø®Ù…Ø³", "Ø¬Ù„Ø³Ø© ÙˆØ§Ø­Ø¯Ø© Ù…ÙƒØ«ÙØ©"]
        
        text = f"""

  âœ¨ <b>Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø­Ø³Ø§Ø¨</b> âœ¨  


{emoji} <b>Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©:</b> <code>{pages_per_day}</code> ØµÙØ­Ø©

ğŸ“Š <b>Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©:</b>
â€¢ ğŸ“… <b>{days_needed:.1f}</b> ÙŠÙˆÙ…
â€¢ ğŸ“† <b>{weeks:.1f}</b> Ø£Ø³Ø¨ÙˆØ¹
â€¢ ğŸ—“ï¸ <b>{months:.1f}</b> Ø´Ù‡Ø±

ğŸŒŸ <b>ÙÙŠ Ø§Ù„Ø³Ù†Ø©:</b>
â€¢ Ø³ØªØªÙ…ÙƒÙ† Ù…Ù† Ø®ØªÙ… Ø§Ù„Ù‚Ø±Ø¢Ù† <b>{khatmas_per_year:.1f}</b> Ù…Ø±Ø©



ğŸ’¡ <b>Ù†ØµÙŠØ­Ø©:</b>
{advice}

â° <b>Ø£ÙˆÙ‚Ø§Øª Ù…Ù‚ØªØ±Ø­Ø©:</b>
"""
        
        for time in suggested_times:
            text += f"â€¢ {time}\n"
        
        text += f"""


ğŸ¯ <b>Ù†ØµØ§Ø¦Ø­ Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ©:</b>
âœ… Ø§Ø¨Ø¯Ø£ Ø¨ÙˆØªÙŠØ±Ø© Ù…Ø±ÙŠØ­Ø© Ø«Ù… Ø²Ø¯ ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹
âœ… Ø§Ø®ØªØ± ÙˆÙ‚ØªØ§Ù‹ Ø«Ø§Ø¨ØªØ§Ù‹ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©
âœ… Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØµØ­Ù Ø§Ù„ÙˆØ±Ù‚ÙŠ Ø£Ùˆ ØªØ·Ø¨ÙŠÙ‚ Ù…ÙˆØ«ÙˆÙ‚
âœ… Ø³Ø¬Ù„ ØªÙ‚Ø¯Ù…Ùƒ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù„ØªØ­ÙÙŠØ²

ğŸ¤² <b>Ø¯Ø¹Ø§Ø¡ Ø§Ù„Ø®ØªÙ…:</b>
"Ø§Ù„Ù„Ù‡Ù… Ø§Ø±Ø­Ù…Ù†ÙŠ Ø¨Ø§Ù„Ù‚Ø±Ø¢Ù†ØŒ ÙˆØ§Ø¬Ø¹Ù„Ù‡ Ù„ÙŠ Ø¥Ù…Ø§Ù…Ø§Ù‹ ÙˆÙ†ÙˆØ±Ø§Ù‹"


"""
        
        # Ø£Ø²Ø±Ø§Ø± ØªÙØ§Ø¹Ù„ÙŠØ©
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø£Ø®Ø±Ù‰", callback_data="calc_khatma_new")],
            [InlineKeyboardButton(text="Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ…", callback_data="khatma_30_start")],
            [InlineKeyboardButton(text="Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", callback_data="quran_search_start")]
        ])
        
        await message.answer(text, parse_mode="HTML", reply_markup=keyboard)
        await state.clear()
        
        # Ø­ÙØ¸ Ø§Ù„Ù†Ø´Ø§Ø·
        db = get_db()
        try:
            conn = db.get_connection()
            conn.execute(
                "INSERT INTO user_activity (user_id, activity_type, activity_details) VALUES (?, ?, ?)",
                (message.from_user.id, 'khatma_calc', f'{pages_per_day} pages/day')
            )
            conn.commit()
            conn.close()
        except:
            pass
        
    except ValueError:
        await message.answer("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ ÙÙ‚Ø·")

@router.callback_query(F.data == "calc_khatma_new")
async def cb_calc_khatma_new(callback: types.CallbackQuery, state: FSMContext):
    """Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ø®ØªÙ…Ø©"""
    await callback.message.delete()
    await btn_calc_khatma(callback.message, state)

@router.message(F.text == "ğŸ“… Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ…")
async def btn_khatma_30(message: types.Message, state: FSMContext):
    """Ø®Ø·Ø© Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ… Ù…Ø¹ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
    
    pages_per_day = 604 / 30  # Ø­ÙˆØ§Ù„ÙŠ 20 ØµÙØ­Ø©
    
    text = f"""

  ğŸ“… <b>Ø®ØªÙ…Ø© ÙÙŠ 30 ÙŠÙˆÙ…</b>  


ğŸ¯ <b>Ø§Ù„Ù‡Ø¯Ù:</b> Ø®ØªÙ… Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… ÙÙŠ Ø´Ù‡Ø± ÙˆØ§Ø­Ø¯

ğŸ“Š <b>Ø§Ù„ØªÙØ§ØµÙŠÙ„:</b>
â€¢ ğŸ“– Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙØ­Ø§Øª: <code>604</code> ØµÙØ­Ø©
â€¢ ğŸ“… Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù…: <code>30</code> ÙŠÙˆÙ…
â€¢ ğŸ“„ ØµÙØ­Ø§Øª ÙŠÙˆÙ…ÙŠØ©: <code>{pages_per_day:.0f}</code> ØµÙØ­Ø©

â° <b>ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµÙØ­Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙˆÙ…:</b>
â€¢ Ø¨Ø¹Ø¯ Ø§Ù„ÙØ¬Ø±: 4 ØµÙØ­Ø§Øª (Ø¬Ø²Ø¡)
â€¢ Ø¨Ø¹Ø¯ Ø§Ù„Ø¸Ù‡Ø±: 4 ØµÙØ­Ø§Øª
â€¢ Ø¨Ø¹Ø¯ Ø§Ù„Ø¹ØµØ±: 4 ØµÙØ­Ø§Øª
â€¢ Ø¨Ø¹Ø¯ Ø§Ù„Ù…ØºØ±Ø¨: 4 ØµÙØ­Ø§Øª
â€¢ Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ø´Ø§Ø¡: 4 ØµÙØ­Ø§Øª



ğŸ“ˆ <b>Ø®Ø·Ø© ØªÙØµÙŠÙ„ÙŠØ© Ø¨Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡:</b>

<b>Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø£ÙˆÙ„ (1-7):</b>
â€¢ Ø§Ù„ÙŠÙˆÙ… 1-2: Ø§Ù„Ø¬Ø²Ø¡ 1-2 (Ø§Ù„Ø¨Ù‚Ø±Ø©)
â€¢ Ø§Ù„ÙŠÙˆÙ… 3-4: Ø§Ù„Ø¬Ø²Ø¡ 3-4 (Ø§Ù„Ø¨Ù‚Ø±Ø©/Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†)
â€¢ Ø§Ù„ÙŠÙˆÙ… 5-6: Ø§Ù„Ø¬Ø²Ø¡ 5-6 (Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†/Ø§Ù„Ù†Ø³Ø§Ø¡)
â€¢ Ø§Ù„ÙŠÙˆÙ… 7: Ø§Ù„Ø¬Ø²Ø¡ 7 (Ø§Ù„Ù…Ø§Ø¦Ø¯Ø©)

<b>Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù†ÙŠ (8-14):</b>
â€¢ Ø§Ù„ÙŠÙˆÙ… 8-14: Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ 8-14 (Ø§Ù„Ø£Ù†Ø¹Ø§Ù…-Ø§Ù„Ø­Ø¬Ø±)

<b>Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø«Ø§Ù„Ø« (15-21):</b>
â€¢ Ø§Ù„ÙŠÙˆÙ… 15-21: Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ 15-21 (Ø§Ù„Ø¥Ø³Ø±Ø§Ø¡-Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØª)

<b>Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ø±Ø§Ø¨Ø¹ (22-30):</b>
â€¢ Ø§Ù„ÙŠÙˆÙ… 22-30: Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ 22-30 (Ø§Ù„Ø£Ø­Ø²Ø§Ø¨-Ø§Ù„Ù†Ø§Ø³)



ğŸ’¡ <b>Ù†ØµØ§Ø¦Ø­ Ø°Ù‡Ø¨ÙŠØ©:</b>
âœ… Ø§Ø¨Ø¯Ø£ Ø¨Ù†ÙŠØ© ØµØ§Ø¯Ù‚Ø©
âœ… Ø§Ø®ØªØ± Ù…ØµØ­ÙØ§Ù‹ ÙˆØ§Ø­Ø¯Ø§Ù‹ ÙˆØ§Ù„ØªØ²Ù… Ø¨Ù‡
âœ… Ø³Ø¬Ù„ ØªÙ‚Ø¯Ù…Ùƒ ÙŠÙˆÙ…ÙŠØ§Ù‹
âœ… Ù„Ø§ ØªÙ‚Ù„Ù‚ Ø¥Ù† ÙØ§ØªÙƒ ÙŠÙˆÙ…ØŒ Ø§Ù‚Ø¶Ù‡ ÙÙŠ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ØªØ§Ù„ÙŠ
âœ… Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„ØªØ¯Ø¨Ø± Ù„Ø§ Ø§Ù„Ø³Ø±Ø¹Ø© ÙÙ‚Ø·

ğŸ <b>ÙØ¶Ù„ Ø®ØªÙ… Ø§Ù„Ù‚Ø±Ø¢Ù†:</b>
Ù‚Ø§Ù„ Ø§Ù„Ù†Ø¨ÙŠ ï·º: "Ù…Ù† Ù‚Ø±Ø£ Ø­Ø±ÙØ§Ù‹ Ù…Ù† ÙƒØªØ§Ø¨ Ø§Ù„Ù„Ù‡ ÙÙ„Ù‡ Ø¨Ù‡ Ø­Ø³Ù†Ø©ØŒ ÙˆØ§Ù„Ø­Ø³Ù†Ø© Ø¨Ø¹Ø´Ø± Ø£Ù…Ø«Ø§Ù„Ù‡Ø§"

ğŸ¤² <b>Ø¯Ø¹Ø§Ø¡ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©:</b>
"Ø§Ù„Ù„Ù‡Ù… Ø§ÙØªØ­ Ø¹Ù„ÙŠÙ†Ø§ Ø­ÙƒÙ…ØªÙƒØŒ ÙˆØ§Ù†Ø´Ø± Ø¹Ù„ÙŠÙ†Ø§ Ø±Ø­Ù…ØªÙƒ"



ğŸ“± <b>Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø¢Ù†ØŸ</b>
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø®ØªÙ…Ø©", callback_data="khatma_30_confirm")],
        [InlineKeyboardButton(text="Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ù…Ø®ØµØµØ©", callback_data="calc_khatma_new")],
        [InlineKeyboardButton(text="Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", callback_data="quran_search_start")]
    ])
    
    await message.answer(text, parse_mode="HTML", reply_markup=keyboard)
    
    # Ø­ÙØ¸ Ø§Ù„Ù†Ø´Ø§Ø·
    db = get_db()
    try:
        conn = db.get_connection()
        conn.execute(
            "INSERT INTO user_activity (user_id, activity_type, activity_details) VALUES (?, ?, ?)",
            (message.from_user.id, 'khatma_30_view', '30-day plan')
        )
        conn.commit()
        conn.close()
    except:
        pass

@router.callback_query(F.data == "khatma_30_start")
async def cb_khatma_30_start(callback: types.CallbackQuery, state: FSMContext):
    """Ø¨Ø¯Ø¡ Ø®ØªÙ…Ø© 30 ÙŠÙˆÙ… Ù…Ù† callback"""
    await callback.message.delete()
    await btn_khatma_30(callback.message, state)

@router.callback_query(F.data == "khatma_30_confirm")
async def cb_khatma_30_confirm(callback: types.CallbackQuery, state: FSMContext):
    """ØªØ£ÙƒÙŠØ¯ Ø¨Ø¯Ø¡ Ø®ØªÙ…Ø© 30 ÙŠÙˆÙ…"""
    
    text = """
<b>ØªÙ…! Ø¨Ø§Ø±Ùƒ Ø§Ù„Ù„Ù‡ ÙÙŠÙƒ</b>

 Ø¨Ø¯Ø£Øª Ø±Ø­Ù„ØªÙƒ Ù„Ø®ØªÙ… Ø§Ù„Ù‚Ø±Ø¢Ù† ÙÙŠ 30 ÙŠÙˆÙ…

<b>ØªØ°ÙƒÙŠØ± ÙŠÙˆÙ…ÙŠ:</b>
Ø³ØªØ­ØªØ§Ø¬ Ù‚Ø±Ø§Ø¡Ø© 20 ØµÙØ­Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹

<b>Ø£Ù†Øª ØªØ³ØªØ·ÙŠØ¹!</b>
Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù† ÙˆØ³Ø¬Ù„ ØªÙ‚Ø¯Ù…Ùƒ ÙŠÙˆÙ…ÙŠØ§Ù‹

Ø¯Ø¹ÙˆØ§ØªÙ†Ø§ Ù„Ùƒ Ø¨Ø§Ù„ØªÙˆÙÙŠÙ‚ ÙˆØ§Ù„Ù‚Ø¨ÙˆÙ„
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_to_main")]
    ])
    
    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
    await callback.answer("ğŸŠ Ø¨Ø§Ø±Ùƒ Ø§Ù„Ù„Ù‡ ÙÙŠÙƒ!", show_alert=True)
    
    # Ø­ÙØ¸ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    db = get_db()
    try:
        conn = db.get_connection()
        conn.execute(
            "INSERT INTO user_activity (user_id, activity_type, activity_details) VALUES (?, ?, ?)",
            (callback.from_user.id, 'khatma_30_start', 'Started 30-day khatma')
        )
        conn.commit()
        conn.close()
    except:
        pass

# ==========================================
# Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… - Ù†Ø¸Ø§Ù… Ø°ÙƒÙŠ Ù…ØªØ·ÙˆØ±
# ==========================================

@router.message(F.text == "Ø§Ù„ØªÙØ§Ø³ÙŠØ±")
async def btn_tafseer(message: types.Message):
    """Ø²Ø± Ø§Ù„ØªÙØ§Ø³ÙŠØ± - Ø§Ù„Ø±Ø¨Ø· Ø¨Ù€ tafsir.app"""
    text = """
<b>Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù‚Ø±Ø¢Ù†ÙŠØ©</b>

ÙŠÙ…ÙƒÙ†Ùƒ Ù‚Ø±Ø§Ø¡Ø© ØªÙØ³ÙŠØ± Ø£ÙŠ Ø¢ÙŠØ© Ù…Ù† Ø®Ù„Ø§Ù„:

1ï¸âƒ£ <b>Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†</b> - Ø«Ù… Ø§Ø®ØªØ± Ø§Ù„Ø¢ÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ³ÙŠØ±Ù‡Ø§

2ï¸âƒ£ <b>Ø¢ÙŠØ§Øª</b> - Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ø¹ Ø§Ù„ØªÙØ³ÙŠØ±

3ï¸âƒ£ <b>Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø¨Ø§Ø´Ø±:</b>
<a href='https://tafsir.app'>tafsir.app</a> - Ù…ÙˆÙ‚Ø¹ Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙØ§Ø³ÙŠØ±

<b>Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù…ØªÙˆÙØ±Ø©:</b>
â€¢ ØªÙØ³ÙŠØ± Ø§Ù„Ø·Ø¨Ø±ÙŠ
â€¢ ØªÙØ³ÙŠØ± Ø§Ø¨Ù† ÙƒØ«ÙŠØ±
â€¢ ØªÙØ³ÙŠØ± Ø§Ù„Ø³Ø¹Ø¯ÙŠ
â€¢ ØªÙØ³ÙŠØ± Ø§Ù„Ø¨ØºÙˆÙŠ
â€¢ ØªÙØ³ÙŠØ± Ø§Ù„Ù‚Ø±Ø·Ø¨ÙŠ
â€¢ ÙˆØºÙŠØ±Ù‡Ø§ Ù…Ù† Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø§ÙØªØ­ Tafsir.app", url="https://tafsir.app")],
        [InlineKeyboardButton(text="Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©", callback_data="random_ayah_new")],
        [InlineKeyboardButton(text="Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", callback_data="quran_search_start")]
    ])
    
    await message.answer(text, parse_mode="HTML", reply_markup=keyboard, disable_web_page_preview=True)

@router.message(F.text.in_(["Ø¢ÙŠØ§Øª", "Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©"]))
async def btn_random_ayah(message: types.Message):
    """Ø¢ÙŠØ§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ø¹ ØªÙØ³ÙŠØ± ÙˆØ±Ø¨Ø· tafsir.app"""
    
    wait_msg = await message.answer("Ø¬Ø§Ø±ÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø¢ÙŠØ©...")
    
    try:
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
        ayah_data = quran_api.get_random_ayah_strict()
        
        if not ayah_data:
            await wait_msg.edit_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¢ÙŠØ©")
            return
        
        surah = ayah_data['surah']
        ayah = ayah_data['ayah']
        text = ayah_data['text']
        surah_name = ayah_data['surah_name']
        
        # Ø±ÙˆØ§Ø¨Ø· Ù…ÙÙŠØ¯Ø©
        tafsir_link = f"https://tafsir.app/{surah}/{ayah}"
        quran_link = f"https://quran.com/{surah}:{ayah}"
        
        # ØªÙƒÙˆÙŠÙ† Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        msg_text = f"""
<b>Ø¢ÙŠØ§Øª Ù…Ù† Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…</b>

<b>{surah_name}</b> - Ø§Ù„Ø¢ÙŠØ© {ayah}

<b>ï´¿ {text} ï´¾</b>

<a href='{tafsir_link}'>Ø§Ù‚Ø±Ø£ Ø§Ù„ØªÙØ³ÙŠØ± ÙÙŠ Tafsir.app</a>
"""
        
        # Ø£Ø²Ø±Ø§Ø± ØªÙØ§Ø¹Ù„ÙŠØ©
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="Ø§Ù„ØªÙØ³ÙŠØ±", callback_data=f"tafsir_ar_{surah}_{ayah}")
            ],
            [
                InlineKeyboardButton(text="Ø§Ø³ØªÙ…Ø§Ø¹", url=quran_link),
                InlineKeyboardButton(text="Ø¢ÙŠØ© Ø£Ø®Ø±Ù‰", callback_data="random_ayah_new")
            ],
            [
                InlineKeyboardButton(text="Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", callback_data="quran_search_start")
            ]
        ])
        
        await wait_msg.delete()
        await message.answer(msg_text, parse_mode="HTML", reply_markup=keyboard, disable_web_page_preview=True)
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø´Ø§Ø·
        try:
            db = get_db()
            conn = db.get_connection()
            conn.execute("INSERT INTO user_activity (user_id, activity_type) VALUES (?, ?)", 
                        (message.from_user.id, 'random_ayah'))
            conn.commit()
            conn.close()
        except:
            pass
            
    except Exception as e:
        logger.error(f"Random ayah error: {e}")
        await wait_msg.edit_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")

@router.callback_query(F.data == "random_ayah_new")
async def cb_random_ayah_new(callback: types.CallbackQuery):
    """Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø© - Ù…Ù† Ø²Ø±"""
    try:
        # Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ callback Ù…Ø¨ÙƒØ±Ø§Ù‹ Ù„ØªØ¬Ù†Ø¨ timeout
        try:
            await callback.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø¢ÙŠØ©...")
        except:
            pass  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø®Ø·Ø£ Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© callback
        
        db = get_db()
        random_ayah = db.get_random_ayah()
        
        if not random_ayah:
            await callback.message.answer("âŒ Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©")
            return
        
        surah, ayah, text_ar, surah_name = random_ayah
        
        quran_link = f"https://quran.com/{surah}:{ayah}"
        
        msg_text = f"""
ğŸ“– <b>Ø¢ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©</b>

<b>{surah_name}</b> - Ø§Ù„Ø¢ÙŠØ© {ayah}

<i>"{text_ar}"</i>

<a href="{quran_link}">ğŸ”— Ø§Ù‚Ø±Ø£ ÙÙŠ Quran.com</a>
"""
        
        # Ø£Ø²Ø±Ø§Ø± ØªÙØ§Ø¹Ù„ÙŠØ©
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="Ø§Ù„ØªÙØ³ÙŠØ±", callback_data=f"tafsir_ar_{surah}_{ayah}")
            ],
            [
                InlineKeyboardButton(text="Ø§Ø³ØªÙ…Ø§Ø¹", url=quran_link),
                InlineKeyboardButton(text="Ø¢ÙŠØ© Ø£Ø®Ø±Ù‰", callback_data="random_ayah_new")
            ],
            [
                InlineKeyboardButton(text="Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", callback_data="quran_search_start")
            ]
        ])
        
        await callback.message.edit_text(msg_text, parse_mode="HTML", reply_markup=keyboard, disable_web_page_preview=True)
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø´Ø§Ø·
        try:
            db = get_db()
            conn = db.get_connection()
            conn.execute("INSERT INTO user_activity (user_id, activity_type) VALUES (?, ?)", 
                        (callback.from_user.id, 'random_ayah'))
            conn.commit()
            conn.close()
        except:
            pass
            
    except Exception as e:
        logger.error(f"Random ayah callback error: {e}")
        try:
            await callback.message.answer("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
        except:
            pass

@router.callback_query(F.data.startswith("tafsir_full_"))
async def cb_tafsir_full(callback: types.CallbackQuery):
    """Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ³ÙŠØ± Ø§Ù„ÙƒØ§Ù…Ù„"""
    _, _, surah, ayah = callback.data.split("_")
    surah = int(surah)
    ayah = int(ayah)
    
    await callback.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙØ³ÙŠØ±...")
    
    try:
        tafsir_data = quran_api.get_ayah_with_tafsir(surah, ayah)
        
        if not tafsir_data or 'tafasir' not in tafsir_data:
            await callback.message.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªÙØ³ÙŠØ±")
            return
        
        # Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø©
        keyboard = []
        for tafsir in tafsir_data['tafasir'][:6]:  # Ø£ÙˆÙ„ 6 ØªÙØ§Ø³ÙŠØ±
            tafsir_id = tafsir.get('id', 0)
            tafsir_name = tafsir.get('name', 'ØªÙØ³ÙŠØ±')
            keyboard.append([InlineKeyboardButton(
                text=f"ğŸ“– {tafsir_name}", 
                callback_data=f"show_tafsir_{surah}_{ayah}_{tafsir_id}"
            )])
        
        keyboard.append([InlineKeyboardButton(text="Ø±Ø¬ÙˆØ¹", callback_data=f"back_to_ayah_{surah}_{ayah}")])
        
        await callback.message.edit_reply_markup(
            reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
        )
        
    except Exception as e:
        logger.error(f"Tafsir full error: {e}")
        await callback.answer("âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙØ³ÙŠØ±", show_alert=True)

@router.callback_query(F.data.startswith("show_tafsir_"))
async def cb_show_tafsir(callback: types.CallbackQuery):
    """Ø¹Ø±Ø¶ ØªÙØ³ÙŠØ± Ù…Ø­Ø¯Ø¯"""
    parts = callback.data.split("_")
    if len(parts) < 5:
        await callback.answer("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", show_alert=True)
        return
        
    surah = int(parts[2])
    ayah = int(parts[3])
    tafsir_id = int(parts[4])
    
    await callback.answer("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...")
    
    try:
        tafsir_data = quran_api.get_ayah_with_tafsir(surah, ayah)
        
        if not tafsir_data or 'tafasir' not in tafsir_data:
            await callback.message.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªÙØ³ÙŠØ±")
            return
        
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙØ³ÙŠØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
        selected_tafsir = None
        for tafsir in tafsir_data['tafasir']:
            if tafsir.get('id') == tafsir_id:
                selected_tafsir = tafsir
                break
        
        if not selected_tafsir or not selected_tafsir.get('text'):
            await callback.message.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Øµ Ø§Ù„ØªÙØ³ÙŠØ±")
            return
        
        tafsir_name = selected_tafsir.get('name', 'Ø§Ù„ØªÙØ³ÙŠØ±')
        tafsir_text = selected_tafsir['text']
        
        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡ (4096 Ø­Ø±Ù Ù„ÙƒÙ„ Ø±Ø³Ø§Ù„Ø©)
        max_length = 3500  # ØªØ±Ùƒ Ù…Ø³Ø§Ø­Ø© Ù„Ù„ØªÙ†Ø³ÙŠÙ‚
        
        surah_name = quran_api._surah_names.get(surah, f'Ø³ÙˆØ±Ø© {surah}')
        header = f"""

  ğŸ“– <b>{tafsir_name}</b>  


<b>{surah_name}</b> - Ø¢ÙŠØ© <code>{ayah}</code>



"""
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ù‚ØµÙŠØ±Ø§Ù‹
        if len(tafsir_text) <= max_length:
            full_text = header + tafsir_text + "\n\n"
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="ØªÙØ§Ø³ÙŠØ± Ø£Ø®Ø±Ù‰", callback_data=f"tafsir_full_{surah}_{ayah}")],
                [InlineKeyboardButton(text="Quran.com", url=f"https://quran.com/{surah}:{ayah}")]
            ])
            
            await callback.message.edit_text(full_text, parse_mode="HTML", reply_markup=keyboard)
        else:
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø§Ù„Ø·ÙˆÙŠÙ„
            parts_list = []
            current_part = ""
            
            sentences = tafsir_text.split('.')
            for sentence in sentences:
                if len(current_part) + len(sentence) < max_length:
                    current_part += sentence + "."
                else:
                    if current_part:
                        parts_list.append(current_part)
                    current_part = sentence + "."
            
            if current_part:
                parts_list.append(current_part)
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙˆÙ„
            first_text = header + parts_list[0] + f"\n\nğŸ“„ Ø§Ù„Ø¬Ø²Ø¡ 1 Ù…Ù† {len(parts_list)}"
            
            await callback.message.edit_text(first_text, parse_mode="HTML")
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©
            for i, part in enumerate(parts_list[1:], 2):
                part_text = f"ğŸ“„ Ø§Ù„Ø¬Ø²Ø¡ {i} Ù…Ù† {len(parts_list)}\n\n{part}"
                await callback.message.answer(part_text, parse_mode="HTML")
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="ØªÙØ§Ø³ÙŠØ± Ø£Ø®Ø±Ù‰", callback_data=f"tafsir_full_{surah}_{ayah}")],
                [InlineKeyboardButton(text="Quran.com", url=f"https://quran.com/{surah}:{ayah}")]
            ])
            
            await callback.message.answer("", reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"Show tafsir error: {e}")
        await callback.answer("âŒ Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ³ÙŠØ±", show_alert=True)

# ==========================================
# Tafsir with Ø§Ù„Ø¨Ø§Ø­Ø« Ø§Ù„Ù‚Ø±Ø¢Ù†ÙŠ Integration
# ==========================================

@router.callback_query(F.data.startswith("tafsir_ar_"))
async def cb_tafsir_arabic(callback: types.CallbackQuery):
    """Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±"""
    parts = callback.data.split("_")
    surah = int(parts[2])
    ayah = int(parts[3])
    
    # Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙØ§Ø³ÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø©
    tafsir_sources = [
        ('ØªÙØ³ÙŠØ± Ø§Ù„Ø¬Ù„Ø§Ù„ÙŠÙ†', 169),
        ('Ø§Ù„ØªÙØ³ÙŠØ± Ø§Ù„Ù…ÙŠØ³Ø±', 171),
        ('ØªÙØ³ÙŠØ± Ø§Ù„Ø³Ø¹Ø¯ÙŠ', 170),
        ('ØªÙØ³ÙŠØ± Ø§Ø¨Ù† ÙƒØ«ÙŠØ±', 168),
        ('ØªÙØ³ÙŠØ± Ø§Ù„Ø·Ø¨Ø±ÙŠ', 167),
        ('ØªÙØ³ÙŠØ± Ø§Ù„Ù‚Ø±Ø·Ø¨ÙŠ', 164)
    ]
    
    text = f"""
ğŸ“– <b>Ø§Ø®ØªØ± Ø§Ù„ØªÙØ³ÙŠØ±</b>

<b>Ø³ÙˆØ±Ø© {surah} - Ø¢ÙŠØ© {ayah}</b>

Ø§Ø®ØªØ± Ø§Ù„ØªÙØ³ÙŠØ± Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ù‚Ø±Ø§Ø¡ØªÙ‡:
"""
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙØ§Ø³ÙŠØ±
    keyboard_buttons = []
    for tafsir_name, tafsir_id in tafsir_sources:
        keyboard_buttons.append([
            InlineKeyboardButton(
                text=tafsir_name,
                callback_data=f"show_tafsir_{surah}_{ayah}_{tafsir_id}"
            )
        ])
    
    # Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨Ø§Ø­Ø« Ø§Ù„Ù‚Ø±Ø¢Ù†ÙŠ
    baheth_link = f"https://tafsir.app/{surah}/{ayah}"
    keyboard_buttons.append([
        InlineKeyboardButton(text="ğŸ”— ØªÙØ§Ø³ÙŠØ± Ø£Ø®Ø±Ù‰ (Ø§Ù„Ø¨Ø§Ø­Ø« Ø§Ù„Ù‚Ø±Ø¢Ù†ÙŠ)", url=baheth_link)
    ])
    keyboard_buttons.append([
        InlineKeyboardButton(text="â—€ï¸ Ø±Ø¬ÙˆØ¹", callback_data="random_ayah_new")
    ])
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)
    
    try:
        await callback.message.edit_text(text, parse_mode="HTML", reply_markup=keyboard, disable_web_page_preview=True)
    except:
        await callback.message.answer(text, parse_mode="HTML", reply_markup=keyboard, disable_web_page_preview=True)
    await callback.answer()

# ==========================================
# Quran Search System (Enhanced)
# ==========================================

@router.message(F.text.in_(["Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", "ğŸ” Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", "Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†"]))
async def btn_quran_search(message: types.Message, state: FSMContext):
    """Ø¨Ø­Ø« Ø°ÙƒÙŠ ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…"""
    
    await message.answer(
        "ğŸ” <b>Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…</b>\n\n"
        "Ø£Ø±Ø³Ù„ ÙƒÙ„Ù…Ø© Ø£Ùˆ Ø¬Ù…Ù„Ø© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù†Ù‡Ø§ ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†:\n\n"
        "ğŸ’¡ <b>Ø£Ù…Ø«Ù„Ø©:</b>\n"
        "â€¢ <code>Ø§Ù„Ø±Ø­Ù…Ù† Ø§Ù„Ø±Ø­ÙŠÙ…</code>\n"
        "â€¢ <code>Ø§Ù„ØµÙ„Ø§Ø©</code>\n"
        "â€¢ <code>Ø§Ù„Ø¬Ù†Ø©</code>\n"
        "â€¢ <code>2:255</code> (Ù„Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ø³ÙˆØ±Ø© ÙˆØ§Ù„Ø¢ÙŠØ©)\n\n"
        "âœ¨ Ø§Ù„Ø¨Ø­Ø« Ù…Ø¯Ø¹ÙˆÙ… Ø¨Ù€ Quran.com API",
        parse_mode="HTML",
        reply_markup=get_cancel_kb(),
        disable_web_page_preview=True
    )
    await state.set_state(Form.search_quran)

@router.message(Form.search_quran)
async def process_quran_search(message: types.Message, state: FSMContext):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ"""
    
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡", reply_markup=get_quran_menu_kb())
        return
    
    query = message.text.strip()
    
    if len(query) < 2:
        await message.answer("âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø£Ø·ÙˆÙ„ (Ø­Ø±ÙÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„)")
        return
    
    wait_msg = await message.answer("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…...")
    
    try:
        # Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… API
        results = quran_api.search_quran(query, page=1, per_page=10)
        
        if not results or not results.get('results'):
            await wait_msg.edit_text(
                f"âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬ Ù„Ù€: <b>{query}</b>\n\n"
                "ğŸ’¡ Ø¬Ø±Ø¨ ÙƒÙ„Ù…Ø§Øª Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡",
                parse_mode="HTML"
            )
            await state.clear()
            return
        
        # Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ Ø§Ù„Ø­Ø§Ù„Ø©
        await state.update_data(
            search_query=query,
            search_results=results['results'],
            current_page=0,
            total_results=results.get('total_count', len(results['results']))
        )
        
        # Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        await display_search_results(wait_msg, state, edit=True)
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø´Ø§Ø·
        try:
            db = get_db()
            conn = db.get_connection()
            conn.execute("INSERT INTO user_activity (user_id, activity_type) VALUES (?, ?)", 
                        (message.from_user.id, 'quran_search'))
            conn.commit()
            conn.close()
        except:
            pass
        
    except Exception as e:
        logger.error(f"Search error: {e}")
        await wait_msg.edit_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
        await state.clear()

async def display_search_results(message, state: FSMContext, edit=False):
    """Ø¹Ø±Ø¶ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø´ÙƒÙ„ Ø°ÙƒÙŠ Ù…Ø¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙØ³ÙŠØ±"""
    
    data = await state.get_data()
    results = data.get('search_results', [])
    current_page = data.get('current_page', 0)
    query = data.get('search_query', '')
    total_results = data.get('total_results', len(results))
    
    if not results:
        return
    
    # Ø¹Ø±Ø¶ ØµÙØ­Ø© ÙˆØ§Ø­Ø¯Ø© (3 Ù†ØªØ§Ø¦Ø¬)
    start_idx = current_page * 3
    end_idx = min(start_idx + 3, len(results))
    page_results = results[start_idx:end_idx]
    
    text = f"""
<b>ğŸ” Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«</b>

ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: <b>{query}</b>
ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {total_results} | Ø§Ù„ØµÙØ­Ø© {current_page + 1}

"""
    
    # Ø£Ø²Ø±Ø§Ø± Ù„ÙƒÙ„ Ù†ØªÙŠØ¬Ø©
    result_buttons = []
    
    for idx, result in enumerate(page_results, start=start_idx + 1):
        surah = result.get('surah', 0)
        ayah = result.get('ayah', 0)
        text_ayah = result.get('text', '')
        surah_name = result.get('surah_name', f'Ø³ÙˆØ±Ø© {surah}')
        
        # Ø¹Ø±Ø¶ Ø§Ù„Ø¢ÙŠØ© Ø¨Ø§Ù„Ø­Ø±ÙƒØ§Øª ÙˆØ¨ÙŠÙ† Ù‚ÙˆØ³ÙŠÙ† ÙˆØ¨Ø§Ù„Ø®Ø· Ø§Ù„Ø¹Ø±ÙŠØ¶
        display_text = f"<b>ï´¿ {text_ayah} ï´¾</b>"
        if len(text_ayah) > 150:
            display_text = f"<b>ï´¿ {text_ayah[:150]}... ï´¾</b>"
        
        text += f"""
ğŸ“– <b>{surah_name}</b> - Ø§Ù„Ø¢ÙŠØ© {ayah}

{display_text}

"""
        
        # Ø²Ø± Ø§Ù„ØªÙØ³ÙŠØ± Ù„ÙƒÙ„ Ø¢ÙŠØ©
        result_buttons.append([
            InlineKeyboardButton(text=f"ğŸ“– Ø§Ù„ØªÙØ³ÙŠØ± - Ø¢ÙŠØ© {ayah}", callback_data=f"tafsir_ar_{surah}_{ayah}")
        ])
    
    # Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„
    keyboard = result_buttons.copy()
    nav_buttons = []
    
    if current_page > 0:
        nav_buttons.append(InlineKeyboardButton(text="Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data="search_prev"))
    
    if end_idx < len(results):
        nav_buttons.append(InlineKeyboardButton(text="Ø§Ù„ØªØ§Ù„ÙŠ", callback_data="search_next"))
    
    if nav_buttons:
        keyboard.append(nav_buttons)
    
    # Ø£Ø²Ø±Ø§Ø± Ø¥Ø¶Ø§ÙÙŠØ©
    keyboard.append([
        InlineKeyboardButton(text="Ø¨Ø­Ø« Ø¬Ø¯ÙŠØ¯", callback_data="search_new"),
        InlineKeyboardButton(text="Ø¥Ù†Ù‡Ø§Ø¡", callback_data="search_end")
    ])
    
    reply_markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
    
    if edit:
        try:
            await message.edit_text(text, parse_mode="HTML", reply_markup=reply_markup, disable_web_page_preview=True)
        except:
            await message.answer(text, parse_mode="HTML", reply_markup=reply_markup, disable_web_page_preview=True)
    else:
        await message.answer(text, parse_mode="HTML", reply_markup=reply_markup, disable_web_page_preview=True)

@router.callback_query(F.data == "search_next")
async def cb_search_next(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„ØµÙØ­Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ø¨Ø­Ø«"""
    data = await state.get_data()
    current_page = data.get('current_page', 0)
    await state.update_data(current_page=current_page + 1)
    await display_search_results(callback.message, state, edit=True)
    await callback.answer()

@router.callback_query(F.data == "search_prev")
async def cb_search_prev(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù…Ù† Ø§Ù„Ø¨Ø­Ø«"""
    data = await state.get_data()
    current_page = data.get('current_page', 0)
    await state.update_data(current_page=max(0, current_page - 1))
    await display_search_results(callback.message, state, edit=True)
    await callback.answer()

@router.callback_query(F.data == "search_new")
async def cb_search_new(callback: types.CallbackQuery, state: FSMContext):
    """Ø¨Ø­Ø« Ø¬Ø¯ÙŠØ¯"""
    await callback.message.delete()
    await state.clear()
    await btn_quran_search(callback.message, state)

@router.callback_query(F.data == "search_end")
async def cb_search_end(callback: types.CallbackQuery, state: FSMContext):
    """Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«"""
    await callback.message.delete()
    await state.clear()
    await callback.answer("ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« âœ…")

@router.callback_query(F.data == "quran_search_start")
async def cb_quran_search_start(callback: types.CallbackQuery, state: FSMContext):
    """Ø¨Ø¯Ø¡ Ø§Ù„Ø¨Ø­Ø« Ù…Ù† callback"""
    await callback.message.delete()
    await btn_quran_search(callback.message, state)

# ==========================================
# Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„ÙƒØ§Ù…Ù„
# ==========================================

@router.message(F.text.in_(["ğŸ™ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ", "Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ", "ğŸ“– Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ"]))
async def btn_quran_audio(message: types.Message):
    """Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ - Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†"""
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...")
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø±Ø§Ø¡ Ø§Ù„Ø°ÙŠÙ† Ù„Ø¯ÙŠÙ‡Ù… ØªÙ„Ø§ÙˆØ§Øª
    reciters = conn.execute("""
        SELECT r.id, COALESCE(r.name_ar, r.reciter_key, 'Ù‚Ø§Ø±Ø¦'), r.description,
               COUNT(qa.id) as audio_count
        FROM reciters r
        INNER JOIN quran_audio qa ON r.id = qa.reciter_id
        GROUP BY r.id
        ORDER BY r.name_ar
    """).fetchall()
    
    conn.close()
    
    if not reciters:
        await wait_msg.delete()
        await message.answer(
            "ğŸ§ <b>Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… - ØµÙˆØªÙŠ</b>\n\n"
            "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ„Ø§ÙˆØ§Øª Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹\n\n"
            "ğŸ’¡ ÙŠØªÙ… Ø§Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø¥Ø¶Ø§ÙØ© ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¥Ù† Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡",
            parse_mode="HTML"
        )
        return
    
    text = f"""ğŸ§ <b>Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… - ØµÙˆØªÙŠ</b>

ğŸ“Š Ù…ØªÙˆÙØ±: <code>{len(reciters)}</code> Ù‚Ø§Ø±Ø¦

Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø§Ø±Ø¦ Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹:

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    keyboard = []
    for rec_id, name, desc, audio_count in reciters:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ™ï¸ {name} ({audio_count} Ø³ÙˆØ±Ø©)",
            callback_data=f"listen_reciter_{rec_id}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="â—€ï¸ Ø±Ø¬ÙˆØ¹", callback_data="back_main")])
    
    await wait_msg.delete()
    await message.answer(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )

# ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ handlers Ø§Ù„Ù‚Ø±Ø§Ø¡ - Ø§Ù„Ù…ÙŠØ²Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±

# ==========================================
# Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
# ==========================================

@router.message(F.text.in_(["Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…"]))
async def btn_admin_panel(message: types.Message, state: FSMContext):
    """Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† - Ø²Ø± "Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" ÙÙ‚Ø·ØŒ Ø£Ù…Ø§ "Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" ÙÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ ÙÙŠ handler Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø§Ù„Ù…ÙˆØ­Ø¯"""
    await state.clear()  # Ù…Ø³Ø­ Ø£ÙŠ state Ù†Ø´Ø·
    
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø©"), types.KeyboardButton(text="ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª")],
        [types.KeyboardButton(text="ğŸ“… Ø¬Ø¯ÙˆÙ„Ø© Ø±Ø³Ø§Ù„Ø©"), types.KeyboardButton(text="ğŸ“¬ Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ø±Ø¯Ø©")],
        [types.KeyboardButton(text="ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†"), types.KeyboardButton(text="ğŸ“£ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª")],
        [types.KeyboardButton(text="ğŸ™ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ"), types.KeyboardButton(text="ğŸ›¡ï¸ Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")],
        [types.KeyboardButton(text="ğŸ¯ Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(
        "<b>Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…</b>\n\nØ§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø©:",
        reply_markup=keyboard,
        parse_mode="HTML"
    )

# ==========================================
# Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© - Ù…ÙØµÙ„ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
# ==========================================

@router.message(F.text.in_(["Ø¥Ø°Ø§Ø¹Ø©", "ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø©"]))
async def btn_broadcast_menu(message: types.Message, state: FSMContext):
    """Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„ÙƒÙ„"), types.KeyboardButton(text="Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†")],
        [types.KeyboardButton(text="Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù‚Ù†ÙˆØ§Øª"), types.KeyboardButton(text="Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…")]
    ], resize_keyboard=True)
    
    await message.answer(
        "<b>Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©</b>\n\n"
        "Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©:",
        reply_markup=keyboard,
        parse_mode="HTML"
    )

@router.message(F.text.in_(["Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„ÙƒÙ„", "ğŸ“¢ Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„ÙƒÙ„"]))
async def btn_broadcast_all(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    
    await state.update_data(bc_service='all', bc_target='all')
    await message.answer(
        "ğŸ“¢ <b>Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹</b>\n\n"
        "Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¢Ù†:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.bc_content)

@router.message(F.text.in_(["Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", "ğŸ‘¤ Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†"]))
async def btn_broadcast_users(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    
    await state.update_data(bc_service='all', bc_target='users')
    await message.answer(
        "ğŸ‘¤ <b>Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</b>\n\n"
        "Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¢Ù†:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.bc_content)

@router.message(F.text.in_(["Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù‚Ù†ÙˆØ§Øª", "ğŸ“£ Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù‚Ù†ÙˆØ§Øª"]))
async def btn_broadcast_channels(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    
    await state.update_data(bc_service='all', bc_target='channels')
    await message.answer(
        "ğŸ“£ <b>Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù‚Ù†ÙˆØ§Øª</b>\n\n"
        "Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¢Ù†:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.bc_content)

@router.message(F.text.in_(["Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", "ğŸ‘¥ Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"]))
async def btn_broadcast_groups(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    
    await state.update_data(bc_service='all', bc_target='groups')
    await message.answer(
        "ğŸ‘¥ <b>Ø¥Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</b>\n\n"
        "Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¢Ù†:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.bc_content)

@router.message(Form.bc_content)
async def process_broadcast_content(message: types.Message, state: FSMContext):
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        db = get_db()
        is_admin = db.is_admin(message.from_user.id)
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=get_main_kb(message.from_user.id, is_admin))
        return
    
    data = await state.get_data()
    target = data.get('bc_target')
    
    # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙŠÙ†
    db = get_db()
    ids = db.get_broadcast_targets(target, only_active=True)
    target_count = len(ids)
    
    # Ø­ÙØ¸ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© (Ø¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù„ÙØ§Øª)
    content_type = 'text'
    file_id = None
    text = message.text or message.caption or ""
    
    # âœ¨ Ø­ÙØ¸ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„Ù†ØµÙŠØ©
    entities = message.entities or message.caption_entities or []
    entities_json = None
    if entities:
        entities_list = []
        for entity in entities:
            entities_list.append({
                'type': entity.type,
                'offset': entity.offset,
                'length': entity.length,
                'url': entity.url if hasattr(entity, 'url') else None,
                'user': entity.user.id if hasattr(entity, 'user') and entity.user else None,
                'language': entity.language if hasattr(entity, 'language') else None,
            })
        entities_json = json.dumps(entities_list, ensure_ascii=False)
    
    # ğŸ‰ Ø­ÙØ¸ Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ù†ØµÙŠØ© (Message Effects)
    effect_id = message.effect_id if hasattr(message, 'effect_id') else None
    if effect_id:
        logger.info(f"âœ¨ Message has effect: {effect_id}")
    
    if message.photo:
        content_type = 'photo'
        file_id = message.photo[-1].file_id
    elif message.video:
        content_type = 'video'
        file_id = message.video.file_id
    elif message.audio:
        content_type = 'audio'
        file_id = message.audio.file_id
    elif message.voice:
        content_type = 'voice'
        file_id = message.voice.file_id
    elif message.document:
        content_type = 'document'
        file_id = message.document.file_id
        # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù (PDF, Word, Ø¥Ù„Ø®)
        if message.document.mime_type:
            logger.info(f"Document type: {message.document.mime_type}")
    elif message.animation:
        content_type = 'animation'
        file_id = message.animation.file_id
    elif message.sticker:
        content_type = 'sticker'
        file_id = message.sticker.file_id
    
    await state.update_data(
        bc_content_type=content_type,
        bc_file_id=file_id,
        bc_text=text,
        bc_target_count=target_count,
        bc_entities=entities_json,  # âœ¨ Ø­ÙØ¸ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª
        bc_effect_id=effect_id
    )
    
    # Ù…Ø¹Ø§ÙŠÙ†Ø©
    target_names = {
        'all': 'Ø§Ù„Ø¬Ù…ÙŠØ¹',
        'users': 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
        'groups': 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª',
        'channels': 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª'
    }
    preview_text = f"ğŸ“‹ <b>Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©:</b>\n\n"
    preview_text += f"ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: <code>{target_names.get(target, target)}</code>\n"
    preview_text += f"ğŸ‘¥ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙŠÙ†: <code>{target_count}</code>\n"
    preview_text += f"ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: <code>{content_type}</code>\n\n"
    preview_text += "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø£Ø¹Ù„Ø§Ù‡ â¬†ï¸\n\n"
    preview_text += "Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹ØŸ"
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø±Ø³Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ")],
        [types.KeyboardButton(text="ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ], resize_keyboard=True)
    
    await message.answer(preview_text, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(Form.bc_test)

@router.message(Form.bc_test)
async def process_broadcast_test(message: types.Message, state: FSMContext):
    data = await state.get_data()
    
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        db = get_db()
        is_admin = db.is_admin(message.from_user.id)
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=get_main_kb(message.from_user.id, is_admin))
        return
    
    if message.text == "Ø¥Ø±Ø³Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ":
        # Ø¥Ø±Ø³Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ Ù„Ù„Ù…Ø´Ø±Ù Ù†ÙØ³Ù‡
        content_type = data.get('bc_content_type')
        file_id = data.get('bc_file_id')
        text = data.get('bc_text')
        entities_json = data.get('bc_entities')
        effect_id = data.get('bc_effect_id')
        
        # âœ¨ ØªØ­ÙˆÙŠÙ„ entities Ù…Ù† JSON
        entities = []
        if entities_json:
            try:
                from aiogram.types import MessageEntity
                entities_data = json.loads(entities_json)
                logger.info(f"ğŸ“ Found {len(entities_data)} entities in message")
                for e in entities_data:
                    entity = MessageEntity(
                        type=e['type'],
                        offset=e['offset'],
                        length=e['length'],
                        url=e.get('url'),
                        user=e.get('user'),
                        language=e.get('language')
                    )
                    entities.append(entity)
                    logger.info(f"   - {e['type']} at {e['offset']}:{e['length']}")
            except Exception as e:
                logger.error(f"Error parsing entities: {e}")
        
        try:
            if content_type == 'text':
                await message.answer(text, entities=entities, message_effect_id=effect_id)
            elif content_type == 'photo':
                await message.answer_photo(file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
            elif content_type == 'video':
                await message.answer_video(file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
            elif content_type == 'audio':
                await message.answer_audio(file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
            elif content_type == 'voice':
                await message.answer_voice(file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
            elif content_type == 'document':
                await message.answer_document(file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
            elif content_type == 'animation':
                await message.answer_animation(file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
            elif content_type == 'sticker':
                await message.answer_sticker(file_id, message_effect_id=effect_id)
            
            await message.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ©")
        except Exception as e:
            await message.answer(f"âŒ Ø®Ø·Ø£: {e}")
        
        return
    
    if message.text == "ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„":
        # ğŸ”¥ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© - Ù†Ø¸Ø§Ù… Ù…ØªØ·ÙˆØ±
        target = data.get('bc_target')
        content_type = data.get('bc_content_type')
        file_id = data.get('bc_file_id')
        text = data.get('bc_text')
        entities_json = data.get('bc_entities')
        effect_id = data.get('bc_effect_id')
        
        # âœ¨ ØªØ­ÙˆÙŠÙ„ entities Ù…Ù† JSON
        entities = []
        if entities_json:
            try:
                from aiogram.types import MessageEntity
                entities_data = json.loads(entities_json)
                for e in entities_data:
                    entity = MessageEntity(
                        type=e['type'],
                        offset=e['offset'],
                        length=e['length'],
                        url=e.get('url'),
                        user=e.get('user'),
                        language=e.get('language')
                    )
                    entities.append(entity)
                logger.info(f"âœ¨ Broadcasting with {len(entities)} formatting entities")
            except Exception as e:
                logger.error(f"Error parsing entities: {e}")
        
        db = get_db()
        
        # ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø¯Ù‚Ø©
        ids = db.get_broadcast_targets(target, only_active=True)
        
        if not ids:
            await message.answer("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù‡Ø¯Ø§Ù Ù„Ù„Ø¥Ø±Ø³Ø§Ù„!\n\nØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø·ÙŠÙ†.")
            await state.clear()
            return
        
        # ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø©
        logger.info(f"ğŸš€ BROADCAST START: target={target}, ids={len(ids)}, type={content_type}")
        
        progress_msg = await message.answer(
            f"â³ <b>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ØªØ·ÙˆØ±...</b>\n\n"
            f"ğŸ“¤ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù: <code>{len(ids)}</code>\n"
            f"âœ… Ù†Ø¬Ø­: <code>0</code>\n"
            f"âŒ ÙØ´Ù„: <code>0</code>\n"
            f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: <code>0%</code>",
            parse_mode="HTML"
        )
        
        success = 0
        failed = 0
        failed_ids = []
        conn = db.get_connection()
        
        for i, uid in enumerate(ids):
            status = 'failed'
            try:
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª
                if content_type == 'text':
                    await bot.send_message(uid, text, entities=entities, message_effect_id=effect_id)
                elif content_type == 'photo':
                    await bot.send_photo(uid, file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
                elif content_type == 'video':
                    await bot.send_video(uid, file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
                elif content_type == 'audio':
                    await bot.send_audio(uid, file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
                elif content_type == 'voice':
                    await bot.send_voice(uid, file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
                elif content_type == 'document':
                    await bot.send_document(uid, file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
                elif content_type == 'animation':
                    await bot.send_animation(uid, file_id, caption=text, caption_entities=entities, message_effect_id=effect_id)
                elif content_type == 'sticker':
                    await bot.send_sticker(uid, file_id, message_effect_id=effect_id)
                
                success += 1
                status = 'success'
                logger.debug(f"âœ… Sent to {uid}")
                
                # âœ¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ - Ø¥Ø°Ø§ Ù†Ø¬Ø­ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ØŒ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…/Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                try:
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¯Ù (user vs chat)
                    if uid > 0:  # Ù…Ø³ØªØ®Ø¯Ù…
                        # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯
                        existing = conn.execute("SELECT user_id FROM users WHERE user_id=?", (uid,)).fetchone()
                        if not existing:
                            # ØªØ³Ø¬ÙŠÙ„ Ø¬Ø¯ÙŠØ¯
                            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                            conn.execute("""
                                INSERT INTO users (user_id, username, join_date, last_activity, status)
                                VALUES (?, ?, ?, ?, 'active')
                            """, (uid, None, now, now))
                            logger.info(f"âœ¨ AUTO-REGISTERED USER: {uid}")
                        else:
                            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ù„Ù†Ø´Ø·
                            conn.execute("""
                                UPDATE users 
                                SET status='active', last_activity=datetime('now')
                                WHERE user_id=?
                            """, (uid,))
                    else:  # Ù‚Ù†Ø§Ø© Ø£Ùˆ Ù…Ø¬Ù…ÙˆØ¹Ø© (ID Ø³Ø§Ù„Ø¨)
                        # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯
                        existing = conn.execute("SELECT chat_id FROM chats WHERE chat_id=?", (uid,)).fetchone()
                        if not existing:
                            # ØªØ³Ø¬ÙŠÙ„ Ø¬Ø¯ÙŠØ¯ - Ù†Ø­Ø§ÙˆÙ„ Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù†ÙˆØ¹ Ù…Ù† bot.get_chat
                            try:
                                chat_info = await bot.get_chat(uid)
                                chat_type = chat_info.type
                                chat_title = chat_info.title or "Unknown"
                                now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                conn.execute("""
                                    INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                                    VALUES (?, ?, ?, ?, ?, 'active')
                                """, (uid, chat_type, chat_title, now, now))
                                logger.info(f"âœ¨ AUTO-REGISTERED CHAT: {uid} ({chat_type}: {chat_title})")
                            except:
                                # Ø¥Ø°Ø§ ÙØ´Ù„ get_chatØŒ Ù†ÙØªØ±Ø¶ Ø£Ù†Ù‡ Ù…Ø¬Ù…ÙˆØ¹Ø©
                                now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                conn.execute("""
                                    INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                                    VALUES (?, 'group', 'Unknown Group', ?, ?, 'active')
                                """, (uid, now, now))
                                logger.info(f"âœ¨ AUTO-REGISTERED CHAT: {uid} (assumed group)")
                        else:
                            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ù„Ù†Ø´Ø·
                            conn.execute("""
                                UPDATE chats 
                                SET status='active', last_activity=datetime('now')
                                WHERE chat_id=?
                            """, (uid,))
                except Exception as reg_error:
                    logger.warning(f"âš ï¸ Auto-register failed for {uid}: {reg_error}")
                
            except Exception as e:
                failed += 1
                failed_ids.append(uid)
                logger.warning(f"âŒ Failed to {uid}: {e}")
                
                # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…/Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
                try:
                    if 'bot was blocked' in str(e).lower() or 'user is deactivated' in str(e).lower():
                        conn.execute("UPDATE users SET status='blocked' WHERE user_id=?", (uid,))
                    elif 'chat not found' in str(e).lower() or 'bot was kicked' in str(e).lower():
                        conn.execute("UPDATE chats SET status='inactive' WHERE chat_id=?", (uid,))
                except:
                    pass
            
            # Ø­ÙØ¸ ÙÙŠ broadcast_history
            try:
                conn.execute("""
                    INSERT INTO broadcast_history 
                    (target, status, sent_at, service) 
                    VALUES (?, ?, datetime('now'), 'manual')
                """, (uid, status))
            except:
                pass
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù… ÙƒÙ„ 5 Ø±Ø³Ø§Ø¦Ù„
            if (i + 1) % 5 == 0 or (i + 1) == len(ids):
                progress_percent = ((i + 1) / len(ids)) * 100
                try:
                    await progress_msg.edit_text(
                        f"â³ <b>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ØªØ·ÙˆØ±...</b>\n\n"
                        f"ğŸ“¤ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù: <code>{len(ids)}</code>\n"
                        f"âœ… Ù†Ø¬Ø­: <code>{success}</code>\n"
                        f"âŒ ÙØ´Ù„: <code>{failed}</code>\n"
                        f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: <code>{progress_percent:.1f}%</code>\n"
                        f"ğŸ”„ Ù…Ø¹Ø§Ù„Ø¬: <code>{i+1}/{len(ids)}</code>",
                        parse_mode="HTML"
                    )
                except:
                    pass
            
            await asyncio.sleep(0.05)  # ØªØ¬Ù†Ø¨ flood
        
        conn.commit()
        conn.close()
        
        # ğŸ“Š Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        stats = db.get_live_stats()
        
        # ğŸ“ˆ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„Ù…ØªØ·ÙˆØ±Ø©
        success_rate = (success / len(ids) * 100) if len(ids) > 0 else 0
        
        result_text = f"""
âœ… <b>Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š <b>Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:</b>
ğŸ‘¥ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙˆÙ†: <code>{len(ids)}</code>
âœ… Ù†Ø¬Ø­: <code>{success}</code> ({success_rate:.1f}%)
âŒ ÙØ´Ù„: <code>{failed}</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ˆ <b>Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©:</b>
ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: <code>{stats['users']['total'] if stats else 'N/A'}</code> (Ù†Ø´Ø·: <code>{stats['users']['active'] if stats else 'N/A'}</code>)
ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: <code>{stats['channels']['total'] if stats else 'N/A'}</code> (Ù†Ø´Ø·Ø©: <code>{stats['channels']['active'] if stats else 'N/A'}</code>)
ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: <code>{stats['groups']['total'] if stats else 'N/A'}</code> (Ù†Ø´Ø·Ø©: <code>{stats['groups']['active'] if stats else 'N/A'}</code>)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ¨ <b>Ù…ÙŠØ²Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ:</b>
ØªÙ… ØªØ³Ø¬ÙŠÙ„ ÙˆØªØ­Ø¯ÙŠØ« Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†/Ø§Ù„Ù‚Ù†ÙˆØ§Øª/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ø°ÙŠÙ† Ù†Ø¬Ø­ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù‡Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!
"""
        
        if failed > 0 and failed_ids:
            result_text += f"\nâš ï¸ <b>Ù…Ù„Ø§Ø­Ø¸Ø©:</b> {failed} Ù…Ù† Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ØºÙŠØ± Ù†Ø´Ø·Ø© Ø£Ùˆ Ø­Ø¸Ø±Øª Ø§Ù„Ø¨ÙˆØª"
        
        logger.info(f"ğŸ¯ BROADCAST COMPLETE: success={success}, failed={failed}, rate={success_rate:.1f}%")
        
        await progress_msg.edit_text(result_text, parse_mode="HTML")
        
        await state.clear()
        is_admin = db.is_admin(message.from_user.id)
        await message.answer("ØªÙ…!", reply_markup=get_main_kb(message.from_user.id, is_admin))

# ==========================================
# Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©
# ==========================================

@router.message(F.text.in_(["Ø¬Ø¯ÙˆÙ„Ø© Ø±Ø³Ø§Ù„Ø©", "ğŸ“… Ø¬Ø¯ÙˆÙ„Ø© Ø±Ø³Ø§Ù„Ø©"]))
async def btn_schedule(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    
    await message.answer(
        "ğŸ“… <b>Ø¬Ø¯ÙˆÙ„Ø© Ø±Ø³Ø§Ù„Ø©</b>\n\n"
        "Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©:",
        parse_mode="HTML",
        reply_markup=get_schedule_type_kb()
    )
    await state.set_state(Form.sch_select_type)

@router.message(Form.sch_select_type)
async def process_schedule_type(message: types.Message, state: FSMContext):
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    type_map = {
        "ÙŠÙˆÙ…ÙŠØ© (ÙƒÙ„ ÙŠÙˆÙ…)": "daily",
        "Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© (Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹)": "weekly",
        "Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·": "once"
    }
    
    schedule_type = type_map.get(message.text)
    if not schedule_type:
        await message.answer("âš ï¸ Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©", reply_markup=get_schedule_type_kb())
        return
    
    await state.update_data(sch_type=schedule_type)
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©ØŒ Ø§Ø·Ù„Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø£ÙˆÙ„Ø§Ù‹
    if schedule_type == 'once':
        await message.answer(
            "ğŸ“… <b>Ø£Ø¯Ø®Ù„ Ø§Ù„ØªØ§Ø±ÙŠØ®</b>\n\n"
            "Ø§Ù„ØµÙŠØºØ©: <code>YYYY-MM-DD</code>\n"
            "Ù…Ø«Ø§Ù„: <code>2026-02-10</code>\n\n"
            "ğŸ’¡ Ø£Ùˆ Ø§Ø¶ØºØ· /today Ù„ØªÙ†ÙÙŠØ°Ù‡ Ø§Ù„ÙŠÙˆÙ…",
            parse_mode="HTML",
            reply_markup=get_cancel_kb()
        )
        await state.set_state(Form.sch_once_date)
    else:
        # Ø·Ù„Ø¨ Ø§Ù„ÙˆÙ‚Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø±Ù‰
        await message.answer(
            "â° <b>Ø£Ø¯Ø®Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</b>\n\n"
            "Ø§Ù„ØµÙŠØºØ©: <code>HH:MM</code>\n"
            "Ù…Ø«Ø§Ù„: <code>09:00</code> Ø£Ùˆ <code>15:30</code>",
            parse_mode="HTML",
            reply_markup=get_cancel_kb()
        )
        await state.set_state(Form.sch_time)

@router.message(Form.sch_once_date)
async def process_once_date(message: types.Message, state: FSMContext):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙƒØªØ¨ /today
    if message.text == "/today":
        selected_date = datetime.now().strftime("%Y-%m-%d")
        await state.update_data(sch_once_date=selected_date)
        await message.answer(f"âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙŠÙˆÙ…: <code>{selected_date}</code>", parse_mode="HTML")
    else:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙŠØºØ© Ø§Ù„ØªØ§Ø±ÙŠØ®
        import re
        date_pattern = r'^\d{4}-\d{2}-\d{2}$'
        if not re.match(date_pattern, message.text):
            await message.answer("âš ï¸ ØµÙŠØºØ© Ø®Ø§Ø·Ø¦Ø©! Ø§Ø³ØªØ®Ø¯Ù…: YYYY-MM-DD\nÙ…Ø«Ø§Ù„: 2026-02-10")
            return
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ÙŠØ³ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ
        try:
            selected_date = datetime.strptime(message.text, "%Y-%m-%d")
            today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
            
            if selected_date.date() < today.date():
                await message.answer("âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¬Ø¯ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ! Ø§Ø®ØªØ± ØªØ§Ø±ÙŠØ®Ø§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„.")
                return
            
            await state.update_data(sch_once_date=message.text)
            await message.answer(f"âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØªØ§Ø±ÙŠØ®: <code>{message.text}</code>", parse_mode="HTML")
        
        except ValueError:
            await message.answer("âš ï¸ ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ­ÙŠØ­! ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚: YYYY-MM-DD")
            return
    
    # Ø§Ù„Ø¢Ù† Ø§Ø·Ù„Ø¨ Ø§Ù„ÙˆÙ‚Øª
    await message.answer(
        "â° <b>Ø£Ø¯Ø®Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</b>\n\n"
        "Ø§Ù„ØµÙŠØºØ©: <code>HH:MM</code>\n"
        "Ù…Ø«Ø§Ù„: <code>09:00</code> Ø£Ùˆ <code>15:30</code>",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.sch_time)

@router.message(Form.sch_time)
async def process_schedule_time(message: types.Message, state: FSMContext):
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙŠØºØ© Ø§Ù„ÙˆÙ‚Øª
    import re
    time_pattern = r'^([0-1]?[0-9]|2[0-3]):([0-5][0-9])$'
    if not re.match(time_pattern, message.text):
        await message.answer("âš ï¸ ØµÙŠØºØ© Ø®Ø§Ø·Ø¦Ø©! Ø§Ø³ØªØ®Ø¯Ù…: HH:MM\nÙ…Ø«Ø§Ù„: 09:00")
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ÙˆÙ‚Øª Ù„Ù… ÙŠÙ…Ø¶ÙŠ (Ù„Ù„Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù„ÙŠÙˆÙ…)
    data = await state.get_data()
    schedule_type = data.get('sch_type')
    once_date = data.get('sch_once_date')
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙˆØ§Ù„ÙŠÙˆÙ… Ù‡Ùˆ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ù…Ø­Ø¯Ø¯
    if schedule_type == 'once' and once_date:
        try:
            selected_datetime = datetime.strptime(f"{once_date} {message.text}", "%Y-%m-%d %H:%M")
            now = datetime.now()
            time_diff_seconds = (selected_datetime - now).total_seconds()
            
            if time_diff_seconds <= 0:
                time_diff = int(abs(time_diff_seconds) / 60)
                await message.answer(
                    f"âš ï¸ <b>Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¬Ø¯ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ!</b>\n\n"
                    f"Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: <code>{message.text}</code>\n"
                    f"Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: <code>{now.strftime('%H:%M')}</code>\n"
                    f"Ø§Ù„ÙØ±Ù‚: {time_diff} Ø¯Ù‚ÙŠÙ‚Ø© Ù…Ø¶Øª\n\n"
                    f"Ø§Ø®ØªØ± ÙˆÙ‚ØªØ§Ù‹ Ù„Ù… ÙŠÙ…Ø¶ÙŠ Ø¨Ø¹Ø¯.",
                    parse_mode="HTML"
                )
                return
            elif time_diff_seconds < 120:  # Ø£Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†
                await message.answer(
                    f"âš ï¸ <b>ØªØ­Ø°ÙŠØ±:</b> Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù‚Ø±ÙŠØ¨ Ø¬Ø¯Ø§Ù‹ ({int(time_diff_seconds/60)} Ø¯Ù‚ÙŠÙ‚Ø©)\n\n"
                    f"ÙŠÙÙ†ØµØ­ Ø¨Ø§Ø®ØªÙŠØ§Ø± ÙˆÙ‚Øª Ø£Ø¨Ø¹Ø¯ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©.",
                    parse_mode="HTML"
                )
        except ValueError:
            pass
    
    # Ù„Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©: ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙˆÙ‚Øª Ù‚Ø¯ Ù…Ø¶Ù‰ Ø§Ù„ÙŠÙˆÙ…
    elif schedule_type == 'daily':
        try:
            now = datetime.now()
            today_scheduled = datetime.strptime(f"{now.strftime('%Y-%m-%d')} {message.text}", "%Y-%m-%d %H:%M")
            
            if today_scheduled <= now:
                await message.answer(
                    f"ğŸ’¡ <b>Ù…Ù„Ø§Ø­Ø¸Ø©:</b> Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ <code>{message.text}</code> Ù‚Ø¯ Ù…Ø¶Ù‰ Ø§Ù„ÙŠÙˆÙ….\n\n"
                    f"Ø³ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªÙ†ÙÙŠØ° ØºØ¯Ø§Ù‹ ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª.",
                    parse_mode="HTML"
                )
        except ValueError:
            pass
    
    await state.update_data(sch_time=message.text)
    schedule_type = data.get('sch_type')
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£Ø³Ø¨ÙˆØ¹ÙŠØŒ Ø§Ø·Ù„Ø¨ Ø§Ù„Ø£ÙŠØ§Ù…
    if schedule_type == 'weekly':
        await message.answer(
            "ğŸ“… <b>Ø§Ø®ØªØ± Ø§Ù„Ø£ÙŠØ§Ù…</b>\n\n"
            "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø«Ù… Ø§Ø¶ØºØ· \"ØªØ£ÙƒÙŠØ¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ÙŠØ§Ù…\"",
            parse_mode="HTML",
            reply_markup=get_weekdays_kb()
        )
        await state.update_data(selected_days=[])
        await state.set_state(Form.sch_days_week)
    else:
        # Ø§Ø·Ù„Ø¨ Ø§Ù„Ù‡Ø¯Ù Ù…Ø¨Ø§Ø´Ø±Ø©
        await message.answer(
            "ğŸ¯ <b>Ø§Ø®ØªØ± Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù:</b>",
            parse_mode="HTML",
            reply_markup=get_bc_target_kb()
        )
        await state.set_state(Form.sch_target)

@router.message(Form.sch_days_week)
async def process_schedule_days(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    if message.text == "ØªØ£ÙƒÙŠØ¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ÙŠØ§Ù…":
        data = await state.get_data()
        days = data.get('selected_days', [])
        
        if not days:
            await message.answer("âš ï¸ Ù„Ù… ØªØ®ØªØ± Ø£ÙŠ ÙŠÙˆÙ…!")
            return
        
        await message.answer(
            f"âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø±: {', '.join(days)}\n\n"
            "ğŸ¯ <b>Ø§Ø®ØªØ± Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù:</b>",
            parse_mode="HTML",
            reply_markup=get_bc_target_kb()
        )
        await state.set_state(Form.sch_target)
        return
    
    # Ø¥Ø¶Ø§ÙØ©/Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…
    data = await state.get_data()
    days = data.get('selected_days', [])
    
    if message.text in days:
        days.remove(message.text)
        await message.answer(f"âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡: {message.text}")
    else:
        days.append(message.text)
        await message.answer(f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ©: {message.text}")
    
    await state.update_data(selected_days=days)

@router.message(Form.sch_target)
async def process_schedule_target(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    target_map = {
        "Ø§Ù„ÙƒÙ„": "all",
        "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†": "users",
        "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª": "groups",
        "Ø§Ù„Ù‚Ù†ÙˆØ§Øª": "channels",
        "Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª": "channels_groups"
    }
    
    target = target_map.get(message.text)
    if not target:
        await message.answer("âš ï¸ Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©", reply_markup=get_bc_target_kb())
        return
    
    await state.update_data(sch_target=target)
    
    # Ø·Ù„Ø¨ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
    await message.answer(
        "ğŸ“ <b>Ø£Ø±Ø³Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:</b>\n\n"
        "ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„:\n"
        "â€¢ Ù†Øµ\n"
        "â€¢ ØµÙˆØ±Ø© Ù…Ø¹ Ù†Øµ\n"
        "â€¢ ÙÙŠØ¯ÙŠÙˆ\n"
        "â€¢ Ù…Ù„Ù ØµÙˆØªÙŠ",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.sch_content)

# ===============
# Ø¯Ø¹Ù… ØªØ¬Ù…ÙŠØ¹ Ø¹Ø¯Ø© Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„Ø¬Ø¯ÙˆÙ„Ø©
# ===============

@router.message(Form.sch_content)
async def process_schedule_content(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return

    # Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø©
    sch_messages = (await state.get_data()).get('sch_messages', [])

    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†ÙˆØ¹ ÙˆÙ…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    content_type = 'text'
    file_id = None
    text = message.text or message.caption or ""
    entities = message.entities or message.caption_entities or []
    entities_json = None
    if entities:
        entities_list = []
        for entity in entities:
            entities_list.append({
                'type': entity.type,
                'offset': entity.offset,
                'length': entity.length,
                'url': entity.url if hasattr(entity, 'url') else None,
                'user': entity.user.id if hasattr(entity, 'user') and entity.user else None,
                'language': entity.language if hasattr(entity, 'language') else None,
            })
        entities_json = json.dumps(entities_list, ensure_ascii=False)
    effect_id = message.effect_id if hasattr(message, 'effect_id') else None
    if message.photo:
        content_type = 'photo'
        file_id = message.photo[-1].file_id
    elif message.video:
        content_type = 'video'
        file_id = message.video.file_id
    elif message.audio:
        content_type = 'audio'
        file_id = message.audio.file_id
    elif message.voice:
        content_type = 'voice'
        file_id = message.voice.file_id
    elif message.document:
        content_type = 'document'
        file_id = message.document.file_id
    elif message.animation:
        content_type = 'animation'
        file_id = message.animation.file_id
    elif message.sticker:
        content_type = 'sticker'
        file_id = message.sticker.file_id

    # Ø£Ø¶Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    sch_messages.append({
        'type': content_type,
        'file_id': file_id,
        'text': text,
        'entities': entities_json,
        'effect_id': effect_id
    })
    await state.update_data(sch_messages=sch_messages)

    # Ø§Ø³Ø£Ù„ Ø§Ù„Ù…Ø´Ø±Ù: Ø£Ø¶Ù Ø±Ø³Ø§Ù„Ø© Ø£Ø®Ø±Ù‰ Ø£Ù… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©ØŸ
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="â• Ø£Ø¶Ù Ø±Ø³Ø§Ù„Ø© Ø£Ø®Ø±Ù‰")],
        [types.KeyboardButton(text="âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ], resize_keyboard=True)
    await message.answer(f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø±Ù‚Ù… {len(sch_messages)}\nÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸.", reply_markup=keyboard)
    # Ù„Ø§ ØªØºÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©ØŒ ÙŠØ¨Ù‚Ù‰ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø­Ø§Ù„Ø© Ø­ØªÙ‰ ÙŠØ®ØªØ§Ø± ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸

@router.message(Form.sch_content, F.text == "â• Ø£Ø¶Ù Ø±Ø³Ø§Ù„Ø© Ø£Ø®Ø±Ù‰")
async def add_another_schedule_message(message: types.Message, state: FSMContext):
    await message.answer("Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© (Ù†Øµ Ø£Ùˆ Ù…Ù„Ù)...")

@router.message(Form.sch_content, F.text == "âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸")
async def confirm_schedule_save(message: types.Message, state: FSMContext):
    data = await state.get_data()
    sch_messages = data.get('sch_messages', [])
    if not sch_messages:
        await message.answer("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„ Ù…Ø­ÙÙˆØ¸Ø©!")
        await state.clear()
        return
    # Ø§Ø­ÙØ¸ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© (ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹ Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ ÙƒÙ„Ù‡Ø§)
    await state.update_data(sch_messages=sch_messages)
    await message.answer(f"âœ… ØªÙ… Ø­ÙØ¸ {len(sch_messages)} Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø¬Ø¯ÙˆÙ„Ø©.")
    await state.set_state(Form.sch_confirm)
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    # Ø­ÙØ¸ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ (Ø¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù„ÙØ§Øª)
    content_type = 'text'
    file_id = None
    text = message.text or message.caption or ""
    
    # âœ¨ Ø­ÙØ¸ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„Ù†ØµÙŠØ©
    entities = message.entities or message.caption_entities or []
    entities_json = None
    if entities:
        entities_list = []
        for entity in entities:
            entities_list.append({
                'type': entity.type,
                'offset': entity.offset,
                'length': entity.length,
                'url': entity.url if hasattr(entity, 'url') else None,
                'user': entity.user.id if hasattr(entity, 'user') and entity.user else None,
                'language': entity.language if hasattr(entity, 'language') else None,
            })
        entities_json = json.dumps(entities_list, ensure_ascii=False)
        logger.info(f"âœ¨ Schedule message has {len(entities)} formatting entities")
    
    effect_id = message.effect_id if hasattr(message, 'effect_id') else None
    if effect_id:
        logger.info(f"âœ¨ Schedule message has effect: {effect_id}")
    
    if message.photo:
        content_type = 'photo'
        file_id = message.photo[-1].file_id
    elif message.video:
        content_type = 'video'
        file_id = message.video.file_id
    elif message.audio:
        content_type = 'audio'
        file_id = message.audio.file_id
    elif message.voice:
        content_type = 'voice'
        file_id = message.voice.file_id
    elif message.document:
        content_type = 'document'
        file_id = message.document.file_id
    
    await state.update_data(
        sch_content_type=content_type,
        sch_file_id=file_id,
        sch_text=text,
        sch_entities=entities_json,  # âœ¨ Ø­ÙØ¸ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª
        sch_effect_id=effect_id
    )
    
    # Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ£ÙƒÙŠØ¯ Ù…Ø¹ Ø²Ø± ØªØ¬Ø±ÙŠØ¨ÙŠ
    data = await state.get_data()
    schedule_type = data.get('sch_type')
    time = data.get('sch_time')
    target = data.get('sch_target')
    days = data.get('selected_days', [])
    once_date = data.get('sch_once_date')
    
    summary = f"ğŸ“‹ <b>Ù…Ù„Ø®Øµ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©:</b>\n\n"
    summary += f"ğŸ• Ø§Ù„ÙˆÙ‚Øª: <code>{time}</code>\n"
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
    if schedule_type == 'once' and once_date:
        summary += f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: <code>{once_date}</code>\n"
        try:
            scheduled_dt = datetime.strptime(f"{once_date} {time}", "%Y-%m-%d %H:%M")
            now = datetime.now()
            time_diff = scheduled_dt - now
            
            if time_diff.total_seconds() > 0:
                hours = int(time_diff.total_seconds() // 3600)
                minutes = int((time_diff.total_seconds() % 3600) // 60)
                days_count = time_diff.days
                
                if days_count > 0:
                    summary += f"â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <code>{days_count} ÙŠÙˆÙ… Ùˆ {hours % 24} Ø³Ø§Ø¹Ø© Ùˆ {minutes} Ø¯Ù‚ÙŠÙ‚Ø©</code>\n"
                elif hours > 0:
                    summary += f"â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <code>{hours} Ø³Ø§Ø¹Ø© Ùˆ {minutes} Ø¯Ù‚ÙŠÙ‚Ø©</code>\n"
                else:
                    summary += f"â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <code>{minutes} Ø¯Ù‚ÙŠÙ‚Ø©</code>\n"
            else:
                summary += f"âš ï¸ <b>ØªØ­Ø°ÙŠØ±: Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù‚Ø¯ Ù…Ø¶Ù‰!</b>\n"
        except:
            pass
    
    summary += f"ğŸ“† Ø§Ù„Ù†ÙˆØ¹: <code>{schedule_type}</code>\n"
    if schedule_type == 'weekly':
        summary += f"ğŸ“… Ø§Ù„Ø£ÙŠØ§Ù…: {', '.join(days)}\n"
    summary += f"ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: <code>{target}</code>\n"
    summary += f"ğŸ“¦ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰: <code>{content_type}</code>\n\n"
    summary += "Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø£Ø¹Ù„Ø§Ù‡ â¬†ï¸\n\n"
    summary += "ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© Ù„Ù†ÙØ³Ùƒ Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„ØªØ£ÙƒØ¯"
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="ğŸ§ª Ø¥Ø±Ø³Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ")],
        [types.KeyboardButton(text="âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸")],
        [types.KeyboardButton(text="Ø¥Ù„ØºØ§Ø¡")]
    ], resize_keyboard=True)
    
    await message.answer(summary, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(Form.sch_confirm)

@router.message(Form.sch_confirm)
async def process_schedule_confirm(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        # Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†
        if get_db().is_admin(message.from_user.id):
            keyboard = get_admin_kb()
            await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        else:
            await cmd_start(message)
        return
    
    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ
    if message.text == "ğŸ§ª Ø¥Ø±Ø³Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ":
        data = await state.get_data()
        content_type = data.get('sch_content_type')
        file_id = data.get('sch_file_id')
        text = data.get('sch_text')
        
        try:
            if content_type == 'text':
                await message.answer(text)
            elif content_type == 'photo':
                await message.answer_photo(file_id, caption=text)
            elif content_type == 'video':
                await message.answer_video(file_id, caption=text)
            elif content_type == 'audio':
                await message.answer_audio(file_id, caption=text)
            elif content_type == 'voice':
                await message.answer_voice(file_id, caption=text)
            elif content_type == 'document':
                await message.answer_document(file_id, caption=text)
            
            await message.answer("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© Ù„Ùƒ!\n\nğŸ’¡ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØµØ­ÙŠØ­Ø©ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ 'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸'")
        except Exception as e:
            await message.answer(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {e}")
        
        return
    
    if message.text != "âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸":
        return
    
    # Ø­ÙØ¸ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    data = await state.get_data()
    db = get_db()
    
    schedule_name = f"Ø¬Ø¯ÙˆÙ„ {datetime.now().strftime('%Y-%m-%d %H:%M')}"
    schedule_type = data.get('sch_type')
    time_str = data.get('sch_time')
    target = data.get('sch_target')
    content_type = data.get('sch_content_type')
    file_id = data.get('sch_file_id')
    text = data.get('sch_text')
    days = ','.join(data.get('selected_days', [])) if schedule_type == 'weekly' else None
    
    # Ù„Ù„Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©: Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯ ÙƒÙ€ end_date
    once_date = data.get('sch_once_date') if schedule_type == 'once' else None
    
    # ØªØ­Ù‚Ù‚ Ù†Ù‡Ø§Ø¦ÙŠ: Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙˆÙ‚Øª Ù„Ù… ÙŠÙ…Ø¶ÙŠ
    if schedule_type == 'once' and once_date and time_str:
        try:
            scheduled_datetime = datetime.strptime(f"{once_date} {time_str}", "%Y-%m-%d %H:%M")
            now = datetime.now()
            
            if scheduled_datetime <= now:
                await message.answer(
                    "âš ï¸ <b>Ø®Ø·Ø£: Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù‚Ø¯ Ù…Ø¶Ù‰!</b>\n\n"
                    "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­ÙØ¸ Ø¬Ø¯ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ.\n"
                    "ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨ÙˆÙ‚Øª ØµØ­ÙŠØ­.",
                    parse_mode="HTML"
                )
                await state.clear()
                keyboard = get_admin_kb() if db.is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
                await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
                return
        except ValueError:
            pass
    
    conn = db.get_connection()
    cursor = conn.execute("""
        INSERT INTO scheduled_tasks 
        (task_name, task_type, target, content_type, file_id, text, 
         run_time, days_of_week, end_date, is_active, validation_status, start_date)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 1, 'validated', date('now'))
    """, (schedule_name, schedule_type, target, content_type, file_id, text,
          time_str, days, once_date))
    
    task_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    # Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯
    confirm_msg = f"âœ… <b>ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n" \
                  f"ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„: <code>{task_id}</code>\n" \
                  f"â° Ø§Ù„ÙˆÙ‚Øª: <code>{time_str}</code>\n"
    
    if schedule_type == 'once' and once_date:
        confirm_msg += f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: <code>{once_date}</code>\n"
    
    confirm_msg += f"ğŸ“… Ø§Ù„Ù†ÙˆØ¹: <code>{schedule_type}</code>\n\n" \
                   f"ğŸ’¡ <i>Ø³ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªÙ†ÙÙŠØ° ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø§Ù„Ù…Ø­Ø¯Ø¯</i>"
    
    await message.answer(confirm_msg, parse_mode="HTML")
    
    await state.clear()
    is_admin = db.is_admin(message.from_user.id)
    await message.answer("ØªÙ…!", reply_markup=get_main_kb(message.from_user.id, is_admin))

# ==========================================
# Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©
# ==========================================

# Ø²Ø± Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©: ÙŠØ¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø© ÙØ¹Ù„ÙŠØ§Ù‹ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
@router.message(F.text.in_(["Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©", "ğŸ“‹ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©", "â° Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©"]))
async def btn_active_schedules(message: types.Message, state: FSMContext = None):
    db = get_db()
    if not db.is_admin(message.from_user.id):
        await message.answer("âŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·.")
        return

    conn = db.get_connection()
    tasks = conn.execute("""
        SELECT id, task_name, task_type, run_time, target, 
               last_run, run_count, total_targets, start_date, end_date, days_of_week
        FROM scheduled_tasks 
        WHERE is_active = 1
        ORDER BY id DESC
        LIMIT 20
    """).fetchall()
    conn.close()

    if not tasks:
        await message.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return

    # Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
    type_names = {
        'daily': 'ÙŠÙˆÙ…ÙŠ â°',
        'specific_days': 'Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© ğŸ“…',
        'weekly': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ ğŸ“†',
        'once': 'Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ””',
        'one_time': 'Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ””'
    }
    target_names = {
        'all': 'Ø§Ù„Ø¬Ù…ÙŠØ¹ ğŸŒ',
        'users': 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ğŸ‘¥',
        'groups': 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ğŸ‘¥',
        'channels': 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª ğŸ“¢',
        'channels_groups': 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª'
    }

    text = """â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ“‹ <b>Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
    for task in tasks:
        tid, name, ttype, time, target, last_run, run_count, total_targets, start_date, end_date, days_of_week = task
        ttype_ar = type_names.get(ttype, ttype)
        target_ar = target_names.get(target, target)
        text += f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„:</b> <code>{tid}</code>
<b>ğŸ“› Ø§Ù„Ø§Ø³Ù…:</b> {name}
<b>ğŸ“† Ø§Ù„Ù†ÙˆØ¹:</b> {ttype_ar}
<b>ğŸ• Ø§Ù„ÙˆÙ‚Øª:</b> <code>{time}</code>
<b>ğŸ¯ Ø§Ù„Ù‡Ø¯Ù:</b> {target_ar}
<b>ğŸ“… Ù…Ù†:</b> <code>{start_date}</code>  <b>Ø¥Ù„Ù‰:</b> <code>{end_date or 'Ø¨Ø¯ÙˆÙ† Ù†Ù‡Ø§ÙŠØ©'}</code>
<b>ğŸ“Š Ù…Ø±Ø§Øª Ø§Ù„ØªÙ†ÙÙŠØ°:</b> <code>{run_count}</code>
<b>ğŸ‘¥ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙŠÙ†:</b> <code>{total_targets}</code>
"""
        if days_of_week:
            text += f"<b>Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹:</b> <code>{days_of_week}</code>\n"

    text += f"""\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</b> <code>{len(tasks)}</code> Ø¬Ø¯ÙˆÙ„ Ù†Ø´Ø·
ğŸ’¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ØªÙØ­Ø°Ù ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°
"""

    # Ø£Ø²Ø±Ø§Ø± ØªØ­ÙƒÙ… (Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„)
    keyboard_buttons = []
    for task in tasks[:10]:
        tid = task[0]
        keyboard_buttons.append([types.InlineKeyboardButton(text=f"ğŸ—‘ï¸ Ø­Ø°Ù #{tid}", callback_data=f"del_schedule_{tid}")])
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=keyboard_buttons) if keyboard_buttons else None

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    db = get_db()
    if not db.is_admin(message.from_user.id):
        await message.answer("âŒ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·.")
        return

    conn = db.get_connection()
    tasks = conn.execute("""
        SELECT id, task_name, task_type, run_time, target, 
               last_run, run_count, total_targets, start_date, end_date, days_of_week
        FROM scheduled_tasks 
        WHERE is_active = 1
        ORDER BY id DESC
        LIMIT 20
    """).fetchall()
    conn.close()

    if not tasks:
        await message.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return

    # Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
    type_names = {
        'daily': 'ÙŠÙˆÙ…ÙŠ â°',
        'specific_days': 'Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© ğŸ“…',
        'weekly': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ ğŸ“†',
        'once': 'Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ””',
        'one_time': 'Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ””'
    }
    target_names = {
        'all': 'Ø§Ù„Ø¬Ù…ÙŠØ¹ ğŸŒ',
        'users': 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ğŸ‘¥',
        'groups': 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ğŸ‘¥',
        'channels': 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª ğŸ“¢',
        'channels_groups': 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª'
    }

    text = """â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ“‹ <b>Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
    for task in tasks:
        tid, name, ttype, time, target, last_run, run_count, total_targets, start_date, end_date, days_of_week = task
        ttype_ar = type_names.get(ttype, ttype)
        target_ar = target_names.get(target, target)
        text += f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„:</b> <code>{tid}</code>
<b>ğŸ“› Ø§Ù„Ø§Ø³Ù…:</b> {name}
<b>ğŸ“† Ø§Ù„Ù†ÙˆØ¹:</b> {ttype_ar}
<b>ğŸ• Ø§Ù„ÙˆÙ‚Øª:</b> <code>{time}</code>
<b>ğŸ¯ Ø§Ù„Ù‡Ø¯Ù:</b> {target_ar}
<b>ğŸ“… Ù…Ù†:</b> <code>{start_date}</code>  <b>Ø¥Ù„Ù‰:</b> <code>{end_date or 'Ø¨Ø¯ÙˆÙ† Ù†Ù‡Ø§ÙŠØ©'}</code>
<b>ğŸ“Š Ù…Ø±Ø§Øª Ø§Ù„ØªÙ†ÙÙŠØ°:</b> <code>{run_count}</code>
<b>ğŸ‘¥ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙŠÙ†:</b> <code>{total_targets}</code>
"""
        if days_of_week:
            text += f"<b>Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹:</b> <code>{days_of_week}</code>\n"

    text += f"""\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</b> <code>{len(tasks)}</code> Ø¬Ø¯ÙˆÙ„ Ù†Ø´Ø·
ğŸ’¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ØªÙØ­Ø°Ù ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°
"""

    # Ø£Ø²Ø±Ø§Ø± ØªØ­ÙƒÙ… (Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„)
    keyboard_buttons = []
    for task in tasks[:10]:
        tid = task[0]
        keyboard_buttons.append([types.InlineKeyboardButton(text=f"ğŸ—‘ï¸ Ø­Ø°Ù #{tid}", callback_data=f"del_schedule_{tid}")])
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=keyboard_buttons) if keyboard_buttons else None

    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    if not get_db().is_admin(message.from_user.id): 
        # ...existing code...
        return
    db = get_db()
    conn = db.get_connection()
    # ...existing code...
    # Ù„Ø§ ØªØºÙŠÙŠØ± ÙÙŠ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©
    # ...existing code...
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø© Ù…Ø¹ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
    tasks = conn.execute("""
        SELECT id, task_name, task_type, run_time, target, 
               last_run, run_count, total_targets, start_date, end_date, days_of_week
        FROM scheduled_tasks 
        WHERE is_active = 1
        ORDER BY id DESC
        LIMIT 20
    """).fetchall()
    conn.close()
    
    if not tasks:
        await message.answer("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹")
        return
    
    # Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
    type_names = {
        'daily': 'ÙŠÙˆÙ…ÙŠ â°',
        'specific_days': 'Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© ğŸ“…',
        'weekly': 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ ğŸ“†',
        'once': 'Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ””',
        'one_time': 'Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ””'
    }
    
    target_names = {
        'all': 'Ø§Ù„Ø¬Ù…ÙŠØ¹ ğŸŒ',
        'users': 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ğŸ‘¥',
        'groups': 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ğŸ‘¥',
        'channels': 'Ø§Ù„Ù‚Ù†ÙˆØ§Øª ğŸ“¢'
    }
    
    text = """â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ“‹ <b>Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
    
    for task in tasks:
        task_id, name, task_type, run_time, target, last_run, run_count, total_targets, start_date, end_date, days_of_week = task
        
        type_display = type_names.get(task_type, task_type)
        target_display = target_names.get(target, target)
        
        text += f"ğŸ”¹ <b>#{task_id}</b> - {name or 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}\n"
        text += f"   ğŸ“Š Ø§Ù„Ù†ÙˆØ¹: {type_display}\n"
        text += f"   â° Ø§Ù„ÙˆÙ‚Øª: <code>{run_time}</code>\n"
        text += f"   ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: {target_display}\n"
        
        if last_run:
            text += f"   ğŸ“… Ø¢Ø®Ø± ØªØ´ØºÙŠÙ„: <code>{last_run[:16]}</code>\n"
        else:
            text += f"   ğŸ“… Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¨Ø¹Ø¯\n"
        
        text += f"   ğŸ”„ Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„ØªØ´ØºÙŠÙ„: <code>{run_count or 0}</code>\n"
        text += f"   âœ… Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙŠÙ†: <code>{total_targets or 0}</code>\n"
        
        if end_date:
            if task_type in ['once', 'one_time']:
                text += f"   ğŸ“… Ù…ÙˆØ¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°: <code>{end_date}</code>\n"
            else:
                text += f"   â³ ÙŠÙ†ØªÙ‡ÙŠ ÙÙŠ: <code>{end_date}</code>\n"
        
        text += "\n"
    
    text += f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„: <code>{len(tasks)}</code>
â€¢ ØªØ¹Ù…Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø© âœ…

ğŸ’¡ <i>Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ØªÙØ­Ø°Ù ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°
Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© ØªÙØ­Ø°Ù ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</i>
"""
    
    # Ø£Ø²Ø±Ø§Ø± Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„
    keyboard_buttons = []
    for task in tasks[:10]:  # Ø£ÙˆÙ„ 10 Ø¬Ø¯Ø§ÙˆÙ„ ÙÙ‚Ø·
        task_id = task[0]
        task_name = task[1] or f"Ø¬Ø¯ÙˆÙ„Ø© #{task_id}"
        keyboard_buttons.append([
            InlineKeyboardButton(
                text=f"âŒ Ø­Ø°Ù: {task_name[:30]}",
                callback_data=f"del_schedule_{task_id}"
            )
        ])
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons) if keyboard_buttons else None
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# Handler Ù„Ø­Ø°Ù Ø¬Ø¯ÙˆÙ„Ø©
# 2. Handler Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© (ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ ØºØ§Ù„Ø¨Ø§Ù‹)
@router.callback_query(F.data.startswith("del_schedule_"))
async def cb_delete_schedule(callback: types.CallbackQuery):
    task_id = int(callback.data.split("_")[2])
    db = get_db()
    conn = db.get_connection()
    conn.execute("DELETE FROM scheduled_tasks WHERE id=?", (task_id,))
    conn.commit()
    conn.close()
    await callback.answer("âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©", show_alert=True)
    await callback.message.edit_text(
        callback.message.text + f"\n\nâŒ <b>ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© #{task_id}</b>",
        parse_mode="HTML"
    )
    """Ø­Ø°Ù Ø¬Ø¯ÙˆÙ„Ø© Ù…Ø­Ø¯Ø¯Ø©"""
    task_id = int(callback.data.split("_")[2])
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©
    conn.execute("DELETE FROM scheduled_tasks WHERE id=?", (task_id,))
    conn.commit()
    conn.close()
    
    await callback.answer("âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©", show_alert=True)
    await callback.message.edit_text(
        callback.message.text + f"\n\nâŒ <b>ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© #{task_id}</b>",
        parse_mode="HTML"
    )

# ==========================================
# Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
# ==========================================

@router.message(F.text.in_(["Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", "ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"]))
async def btn_statistics(message: types.Message):
    """Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    if not get_db().is_admin(message.from_user.id): return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª")],
        [types.KeyboardButton(text="ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ping)")],
        [types.KeyboardButton(text="Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ù…ÙŠØ²Ø§Øª")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(
        "<b>ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</b>\n\nØ§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:",
        reply_markup=keyboard,
        parse_mode="HTML"
    )

@router.message(F.text == "Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª")
async def btn_stats_users_channels(message: types.Message):
    """Ø§Ù„Ø­Ù„ Ø§Ù„Ø¬Ø°Ø±ÙŠ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ - Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¯Ù‚ÙŠÙ‚Ø© 100% Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ù…Ø´Ø§ÙƒÙ„"""
    if not get_db().is_admin(message.from_user.id): return
    
    # Ø±Ø³Ø§Ù„Ø© Ø§Ù†ØªØ¸Ø§Ø±
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©...")
    
    db = get_db()
    conn = db.get_connection()  # Ø¥Ø¶Ø§ÙØ© conn Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ DEBUG
    
    # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    stats = db.get_live_stats()
    
    if not stats:
        await wait_msg.edit_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª")
        return
    
    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    user_total = stats['users']['total']
    user_active = stats['users']['active']
    user_blocked = stats['users']['blocked']
    user_inactive = stats['users']['inactive']
    
    channels_total = stats['channels']['total']
    channels_active = stats['channels']['active']
    channels_inactive = stats['channels']['inactive']
    
    groups_total = stats['groups']['total']
    groups_active = stats['groups']['active']
    groups_inactive = stats['groups']['inactive']
    
    unknown_total = stats['unknown_chats']['total']
    unknown_active = stats['unknown_chats']['active']
    
    total_all = stats['total_all']
    total_active_all = stats['total_active']
    total_inactive_all = stats['total_inactive']
    
    new_today = stats['today']['new_users']
    active_week = stats['week']['active_users']
    
    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ø³Ø¨
    user_active_percent = (user_active / user_total * 100) if user_total > 0 else 0
    channels_active_percent = (channels_active / channels_total * 100) if channels_total > 0 else 0
    groups_active_percent = (groups_active / groups_total * 100) if groups_total > 0 else 0
    total_active_percent = (total_active_all / total_all * 100) if total_all > 0 else 0
    
    # Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ù†Ø¸Ù…Ø© Ø¨Ø´ÙƒÙ„ Ù†Ø¸ÙŠÙ
    text = f"""
<b>ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©</b>

ğŸ‘¥ <b>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{user_total:,}</code>
â€¢ âœ… Ù†Ø´Ø·ÙŠÙ†: <code>{user_active:,}</code> ({user_active_percent:.1f}%)
â€¢ ğŸ’¤ ØºÙŠØ± Ù†Ø´Ø·ÙŠÙ†: <code>{user_inactive:,}</code>
â€¢ ğŸš« Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: <code>{user_blocked:,}</code>
â€¢ ğŸ†• Ø¬Ø¯Ø¯ Ø§Ù„ÙŠÙˆÙ…: <code>{new_today:,}</code>
â€¢ ğŸ“… Ù†Ø´Ø·ÙŠÙ† Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹: <code>{active_week:,}</code>

ğŸ“¢ <b>Ø§Ù„Ù‚Ù†ÙˆØ§Øª:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{channels_total:,}</code>
â€¢ âœ… Ù†Ø´Ø·Ø©: <code>{channels_active:,}</code> ({channels_active_percent:.1f}%)
â€¢ ğŸ’¤ ØºÙŠØ± Ù†Ø´Ø·Ø©: <code>{channels_inactive:,}</code>

ğŸ‘¥ <b>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{groups_total:,}</code>
â€¢ âœ… Ù†Ø´Ø·Ø©: <code>{groups_active:,}</code> ({groups_active_percent:.1f}%)
â€¢ ğŸ’¤ ØºÙŠØ± Ù†Ø´Ø·Ø©: <code>{groups_inactive:,}</code>
"""
    
    # Ø¥Ø¶Ø§ÙØ© Ø´Ø§ØªØ§Øª ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
    if unknown_total > 0:
        text += f"""
âš ï¸ <b>Ø´Ø§ØªØ§Øª ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{unknown_total:,}</code>
â€¢ âœ… Ù†Ø´Ø·Ø©: <code>{unknown_active:,}</code>
"""
    
    # Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„ÙŠ
    text += f"""
ğŸ“ˆ <b>Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„ÙŠ:</b>
â€¢ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹: <code>{total_all:,}</code> 
â€¢ âœ… Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: <code>{total_active_all:,}</code> ({total_active_percent:.1f}%)
â€¢ ğŸ’¤ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: <code>{total_all - total_active_all:,}</code>

âœ¨ <i>Ù†Ø¸Ø§Ù… Ø°ÙƒÙŠ - ÙŠØ­Ø³Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</i>
ğŸ”„ <i>Ø§Ø­ØªÙŠØ§Ø·ÙŠ - ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ping Ù„Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙŠØ¯ÙˆÙŠ</i>

ğŸ’¡ Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
    
    await wait_msg.delete()
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ping)")
async def btn_ping_all_users(message: types.Message):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ping Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
    if not get_db().is_admin(message.from_user.id): return
    
    # ØªØ£ÙƒÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    confirm_keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [
            types.InlineKeyboardButton(text="âœ… Ù†Ø¹Ù…ØŒ Ø§Ø¨Ø¯Ø£", callback_data="ping_confirm_yes"),
            types.InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="ping_confirm_no")
        ]
    ])
    
    await message.answer(
        "<b>ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ping)</b>\n\n"
        "<b>Ù†Ø¸Ø§Ù… Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù…ØªØ·ÙˆØ±</b>\n\n"
        "Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø³ØªÙ‚ÙˆÙ… Ø¨Ù€:\n"
        "â€¢ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù‚ØµÙŠØ±Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹ (Ø­ØªÙ‰ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·ÙŠÙ†)\n"
        "â€¢ Ø§ÙƒØªØ´Ø§Ù Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¬Ø¯Ø¯\n"
        "â€¢ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù… (Ù†Ø´Ø·/ØºÙŠØ± Ù†Ø´Ø·)\n"
        "â€¢ Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ ÙˆØ§Ù„Ø¯Ù‚ÙŠÙ‚\n\n"
        "âš ï¸ <b>Ù…Ù„Ø§Ø­Ø¸Ø©:</b> Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø¯Ù‚Ø§Ø¦Ù‚ Ø­Ø³Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†\n"
        "ğŸ’¡ <b>ØªÙ„Ù…ÙŠØ­:</b> Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ ÙŠØ­Ø³Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ - Ù‡Ø°Ø§ Ø§Ø­ØªÙŠØ§Ø·ÙŠ\n\n"
        "Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ",
        reply_markup=confirm_keyboard,
        parse_mode="HTML"
    )

@router.callback_query(F.data == "ping_confirm_no")
async def cb_ping_cancel(callback: types.CallbackQuery):
    await callback.message.edit_text("âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø¯ÙŠØ«")
    await callback.answer()

@router.callback_query(F.data == "ping_confirm_yes")
async def cb_ping_start(callback: types.CallbackQuery):
    """ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ping"""
    await callback.answer()
    
    status_msg = await callback.message.edit_text(
        "â³ <b>Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª...</b>\n\n"
        "â€¢ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...",
        parse_mode="HTML"
    )
    
    db = get_db()
    
    # Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª (Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø­ØªÙ‰ inactive)
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # Ø¬Ù„Ø¨ Ø§Ù„ÙƒÙ„ - Ø­ØªÙ‰ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·ÙŠÙ† - Ù„Ø§ÙƒØªØ´Ø§Ù Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¬Ø¯Ø¯
    cursor.execute("SELECT user_id, username FROM users")
    all_users = cursor.fetchall()
    
    cursor.execute("SELECT chat_id, title, type FROM chats")
    all_chats = cursor.fetchall()
    
    conn.close()
    
    total_targets = len(all_users) + len(all_chats)
    success_users = 0
    failed_users = 0
    success_chats = 0
    failed_chats = 0
    
    # Ø±Ø³Ø§Ø¦Ù„ Ping Ù…ØªÙ†ÙˆØ¹Ø© (Ø£Ø°ÙƒØ§Ø± ÙˆØ£Ø¯Ø¹ÙŠØ©)
    ping_messages = [
        "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø­Ù…Ø¯Ù‡ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…",
        "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ ÙˆØ³Ù„Ù… Ø¹Ù„Ù‰ Ù†Ø¨ÙŠÙ†Ø§ Ù…Ø­Ù…Ø¯",
        "Ù„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡",
        "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø±Ø¨ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠÙ†",
        "Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ… ÙˆØ£ØªÙˆØ¨ Ø¥Ù„ÙŠÙ‡",
        "Ù„Ø§ Ø­ÙˆÙ„ ÙˆÙ„Ø§ Ù‚ÙˆØ© Ø¥Ù„Ø§ Ø¨Ø§Ù„Ù„Ù‡",
        "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆØ§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ ÙˆÙ„Ø§ Ø¥Ù„Ù‡ Ø¥Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±",
        "Ø§Ù„Ù„Ù‡Ù… Ø¥Ù†ÙŠ Ø£Ø³Ø£Ù„Ùƒ Ø§Ù„Ø¬Ù†Ø©",
        "Ø±Ø¨ Ø§ØºÙØ± Ù„ÙŠ ÙˆÙ„ÙˆØ§Ù„Ø¯ÙŠ",
        "Ø­Ø³Ø¨Ù†Ø§ Ø§Ù„Ù„Ù‡ ÙˆÙ†Ø¹Ù… Ø§Ù„ÙˆÙƒÙŠÙ„"
    ]
    
    import random
    # Ø§Ø®ØªÙŠØ§Ø± Ø°ÙƒØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ
    ping_message = random.choice(ping_messages)
    
    # Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    await status_msg.edit_text(
        f"â³ <b>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...</b>\n\n"
        f"ğŸ“¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†: 0/{len(all_users)}\n"
        f"ğŸ“¤ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª: 0/{len(all_chats)}\n\n"
        f"âœ… Ù†Ø¬Ø­: 0\n"
        f"âŒ ÙØ´Ù„: 0",
        parse_mode="HTML"
    )
    
    for idx, (user_id, username) in enumerate(all_users, 1):
        try:
            await bot.send_message(user_id, ping_message)
            success_users += 1
            
            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
            db.add_user(user_id, username)  # Ø³ÙŠØ­Ø¯Ø« last_activity
            
        except Exception as e:
            failed_users += 1
            
            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙƒÙ€ inactive
            try:
                conn = sqlite3.connect(DB_NAME)
                conn.execute(
                    "UPDATE users SET status='inactive' WHERE user_id=?",
                    (user_id,)
                )
                conn.commit()
                conn.close()
            except:
                pass
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙƒÙ„ 5 Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        if idx % 5 == 0 or idx == len(all_users):
            try:
                await status_msg.edit_text(
                    f"â³ <b>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...</b>\n\n"
                    f"ğŸ“¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†: {idx}/{len(all_users)}\n"
                    f"ğŸ“¤ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª: 0/{len(all_chats)}\n\n"
                    f"âœ… Ù†Ø¬Ø­: {success_users}\n"
                    f"âŒ ÙØ´Ù„: {failed_users}",
                    parse_mode="HTML"
                )
            except:
                pass
        
        # ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø¸Ø±
        await asyncio.sleep(0.05)
    
    # Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
    for idx, (chat_id, title, chat_type) in enumerate(all_chats, 1):
        try:
            await bot.send_message(chat_id, ping_message)
            success_chats += 1
            
        except Exception as e:
            failed_chats += 1
            
            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ÙƒÙ€ inactive
            try:
                conn = sqlite3.connect(DB_NAME)
                conn.execute(
                    "UPDATE chats SET status='inactive' WHERE chat_id=?",
                    (chat_id,)
                )
                conn.commit()
                conn.close()
            except:
                pass
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙƒÙ„ 5 Ù…Ø­Ø§Ø¯Ø«Ø§Øª
        if idx % 5 == 0 or idx == len(all_chats):
            try:
                await status_msg.edit_text(
                    f"â³ <b>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...</b>\n\n"
                    f"ğŸ“¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†: {len(all_users)}/{len(all_users)}\n"
                    f"ğŸ“¤ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª: {idx}/{len(all_chats)}\n\n"
                    f"âœ… Ù†Ø¬Ø­: {success_users + success_chats}\n"
                    f"âŒ ÙØ´Ù„: {failed_users + failed_chats}",
                    parse_mode="HTML"
                )
            except:
                pass
        
        await asyncio.sleep(0.05)
    
    # Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
    total_success = success_users + success_chats
    total_failed = failed_users + failed_chats
    
    chats_percent = (success_chats / len(all_chats) * 100) if len(all_chats) > 0 else 0
    
    result_text = f"""
âœ… <b>Ø§ÙƒØªÙ…Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š <b>Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©:</b>

ğŸ‘¤ <b>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†:</b>
  â€¢ ØªÙ… Ø§Ù„ÙØ­Øµ: {len(all_users)}
  â€¢ Ù†Ø´Ø·ÙŠÙ† Ø§Ù„Ø¢Ù†: {success_users}
  â€¢ ØºÙŠØ± Ù†Ø´Ø·ÙŠÙ†: {failed_users}
  â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø´Ø§Ø·: {(success_users/len(all_users)*100):.1f}%

ğŸ’¬ <b>Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª:</b>
  â€¢ ØªÙ… Ø§Ù„ÙØ­Øµ: {len(all_chats)}
  â€¢ Ù†Ø´Ø·Ø© Ø§Ù„Ø¢Ù†: {success_chats}
  â€¢ ØºÙŠØ± Ù†Ø´Ø·Ø©: {failed_chats}
  â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø´Ø§Ø·: {chats_percent:.1f}%

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ˆ <b>Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</b>
  â€¢ âœ… Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: <code>{total_success}</code>
  â€¢ âŒ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: <code>{total_failed}</code>
  â€¢ ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„ÙŠ: <code>{total_targets}</code>
  â€¢ ğŸ¯ Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø´Ø§Ø·: <code>{(total_success/total_targets*100):.1f}%</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ <b>ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</b>
âœ¨ <b>Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ Ø¬Ø§Ù‡Ø² Ø§Ù„Ø¢Ù† Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù„Ø­Ø§Ù„Ù‡</b>

â° <i>Ø§Ù„ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</i>
"""
    
    await status_msg.edit_text(result_text, parse_mode="HTML")

@router.message(F.text == "Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ù…ÙŠØ²Ø§Øª")
async def btn_stats_system(message: types.Message):
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ù…ÙŠØ²Ø§Øª"""
    if not get_db().is_admin(message.from_user.id): return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„...")
    
    db = get_db()
    conn = db.get_connection()

    # Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ÙˆØ§Ù„Ø¥Ø°Ø§Ø¹Ø§Øª
    active_tasks = conn.execute("SELECT COUNT(*) FROM scheduled_tasks WHERE is_active=1").fetchone()[0]
    total_broadcasts = conn.execute("SELECT COUNT(*) FROM broadcast_history").fetchone()[0]
    broadcasts_week = conn.execute("SELECT COUNT(*) FROM broadcast_history WHERE sent_at >= datetime('now', '-7 days')").fetchone()[0]
    
    # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù‚Ø±Ø¢Ù†
    quran_searches = conn.execute("""
        SELECT COUNT(DISTINCT user_id) 
        FROM user_activity 
        WHERE activity_type='quran_search' AND DATE(timestamp) >= DATE('now', '-7 days')
    """).fetchone()[0] or 0
    
    random_ayah_count = conn.execute("""
        SELECT COUNT(*) 
        FROM user_activity 
        WHERE activity_type='random_ayah' AND DATE(timestamp) >= DATE('now', '-7 days')
    """).fetchone()[0] or 0
    
    # Ø£ÙƒØ«Ø± Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹
    top_features = conn.execute("""
        SELECT activity_type, COUNT(*) as count 
        FROM user_activity 
        WHERE DATE(timestamp) >= DATE('now', '-7 days')
        GROUP BY activity_type 
        ORDER BY count DESC 
        LIMIT 10
    """).fetchall()
    
    # Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„ÙŠÙˆÙ…ÙŠ
    daily_activities = conn.execute("""
        SELECT COUNT(*) 
        FROM user_activity 
        WHERE DATE(timestamp) = DATE('now')
    """).fetchone()[0]
    
    conn.close()
    
    text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ¯ <b>Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ù…ÙŠØ²Ø§Øª</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<b>ğŸ“¢ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© ÙˆØ§Ù„Ø¬Ø¯ÙˆÙ„Ø©:</b>

â€¢ Ø¬Ø¯Ø§ÙˆÙ„ Ù†Ø´Ø·Ø©: <code>{active_tasks}</code>
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø§Øª: <code>{total_broadcasts:,}</code>
â€¢ Ø¥Ø°Ø§Ø¹Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹: <code>{broadcasts_week}</code>

<b>ğŸ“– Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…:</b>

â€¢ Ø¹Ù…Ù„ÙŠØ§Øª Ø¨Ø­Ø« (7 Ø£ÙŠØ§Ù…): <code>{quran_searches}</code>
â€¢ Ø¢ÙŠØ§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (7 Ø£ÙŠØ§Ù…): <code>{random_ayah_count}</code>

<b>ğŸ“Š Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„ÙŠÙˆÙ…ÙŠ:</b>
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„ÙŠÙˆÙ…: <code>{daily_activities}</code>

<b>ğŸ¯ Ø£ÙƒØ«Ø± 10 Ù…ÙŠØ²Ø§Øª Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹ (7 Ø£ÙŠØ§Ù…):</b>

"""
    
    feature_names = {
        'quran_search': 'ğŸ” Ø¨Ø­Ø« Ø§Ù„Ù‚Ø±Ø¢Ù†',
        'random_ayah': 'ğŸ² Ø¢ÙŠØ§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©',
        'azkar': 'ğŸ“¿ Ø§Ù„Ø£Ø°ÙƒØ§Ø±',
        'tasbih': 'ğŸ“¿ Ø§Ù„Ù…Ø³Ø¨Ø­Ø©',
        'hadith': 'ğŸ“š Ø§Ù„Ø­Ø¯ÙŠØ«',
        'khatma': 'ğŸ“– Ø§Ù„Ø®ØªÙ…Ø©',
        'audio': 'ğŸ™ï¸ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ'
    }
    
    if top_features:
        for i, (feature, count) in enumerate(top_features, 1):
            fname = feature_names.get(feature, feature)
            text += f"{i}. {fname}: <code>{count}</code>\n"
    else:
        text += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª\n"
    
    text += f"""

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>ğŸ’¾ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…:</b>
â€¢ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: SQLite3
â€¢ Ø§Ù„Ø¥ØµØ¯Ø§Ø±: v3.5 Smart
â€¢ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©: {DEFAULT_TIMEZONE}

â° <code>{datetime.now().strftime('%Y-%m-%d %H:%M')}</code>

âœ… <b>Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ©</b>
"""
    
    await wait_msg.delete()
    await message.answer(text, parse_mode="HTML")

@router.callback_query(F.data.startswith("svc_toggle_"))
async def cb_toggle_service(callback: types.CallbackQuery):
    service = callback.data.split("_")[2]
    db = get_db()
    uid = callback.message.chat.id
    
    current = db.get_chat_services(uid)
    new_status = not (current.get(service, 0) == 1)
    
    # Update DB
    db.update_chat_service(uid, service, new_status)
    
    # Refresh stats
    services = db.get_chat_services(uid)
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text=f"{'âœ…' if services['afaq'] else 'âŒ'} Ù†Ø´Ø± Ø¢ÙØ§Ù‚", callback_data="svc_toggle_afaq"),
        ],
        [
            InlineKeyboardButton(text=f"{'âœ…' if services['wird'] else 'âŒ'} Ø§Ù„ÙˆØ±Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ", callback_data="svc_toggle_wird"),
        ],
        [
            InlineKeyboardButton(text=f"{'âœ…' if services['salawat'] else 'âŒ'} Ù…Ù†Ø¨Ù‡ Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ", callback_data="svc_toggle_salawat"),
        ]
    ])
    
    try:
        await callback.message.edit_reply_markup(reply_markup=kb)
        state_text = "ØªÙ… Ø§Ù„ØªÙØ¹ÙŠÙ„ âœ…" if new_status else "ØªÙ… Ø§Ù„ØªØ¹Ø·ÙŠÙ„ âŒ"
        await callback.answer(state_text)
    except Exception as e:
        await callback.answer()

@router.message(F.text == "ï¿½ğŸ”„ ØªØµÙÙŠØ± Ø§Ù„ÙˆØ±Ø¯")

@router.message(F.text == "Ø¥Ø°Ø§Ø¹Ø© Ù„Ø¢ÙØ§Ù‚")
async def btn_broadcast_afaq(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    await state.update_data(bc_service='afaq')
    await message.answer("ğŸ“¢ <b>Ø¥Ø°Ø§Ø¹Ø© Ø¢ÙØ§Ù‚</b>\nØ§Ø®ØªØ± Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù (Ø³ÙŠØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù…Ù† Ù„Ù… ÙŠØ¹Ø·Ù„ Ø§Ù„Ø®Ø¯Ù…Ø© ÙÙ‚Ø·):", parse_mode="HTML", reply_markup=get_bc_target_kb())
    await state.set_state(Form.bc_target)

@router.callback_query(F.data.startswith("sch_del_"))
async def cb_sch_delete(callback: types.CallbackQuery):
    t_id = int(callback.data.split("_")[2])
    conn = get_db().get_connection()
    conn.execute("UPDATE scheduled_tasks SET is_active=0 WHERE id=?", (t_id,))
    conn.commit()
    conn.close()
    
    await callback.answer("âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„", show_alert=True)
    await callback.message.edit_text(callback.message.text + "\n\nâŒ [Ù…ØªÙˆÙ‚Ù]", reply_markup=None)

@router.message(Form.delete_msg_select)
async def process_delete_select(message: types.Message, state: FSMContext):
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=get_admin_kb())
        return
    
    if message.text == "Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ù…Ø­Ø¯Ø¯Ø©":
        text = """
ğŸ—‘ <b>Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ù…Ø­Ø¯Ø¯Ø©</b>

ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­Ø°Ù Ø¨Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„ØªØ§Ù„ÙŠØ©:
1. <b>Ø±Ø§Ø¨Ø· Ø§Ù„Ø±Ø³Ø§Ù„Ø©:</b> Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†Ø´ÙˆØ± Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.
   (Ù…Ø«Ø§Ù„: <code>https://t.me/channel_name/123</code>)
   
2. <b>Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ¬ÙŠÙ‡:</b> Ù‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø© Ø¥Ù„ÙŠ Ù‡Ù†Ø§.

3. <b>Ø§Ù„Ù…Ø¹Ø±Ù:</b> Ø£Ø±Ø³Ù„ <code>ChatID:MessageID</code> ÙŠØ¯ÙˆÙŠØ§Ù‹.

âš ï¸ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±ÙØ§Ù‹ Ø¨ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø°Ù ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.
"""
        await message.answer(text, reply_markup=get_cancel_kb(), parse_mode="HTML")
        await state.set_state(Form.delete_msg_single)
    elif message.text == "Ø­Ø°Ù Ø¢Ø®Ø± Ø±Ø³Ø§Ø¦Ù„":
        await message.answer("Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±.", reply_markup=get_admin_kb())
        await state.clear()

@router.message(Form.delete_msg_single)
async def process_delete_single(message: types.Message, state: FSMContext):
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=get_admin_kb())
        return
    
    chat_id = None
    message_id = None
    
    # 1. Try Forwarded Message
    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        message_id = message.forward_from_message_id
    elif message.forward_from:
        # Not useful for deletion usually unless it's the bot itself, but we need the chat context
        pass
        
    # 2. Try Link Regex
    if not chat_id and message.text:
        # Match https://t.me/username/123
        match_public = re.search(r't\.me\/([\w\d_]+)\/(\d+)', message.text)
        # Match https://t.me/c/1234567890/123 (Private link)
        match_private = re.search(r't\.me\/c\/(\d+)\/(\d+)', message.text)
        
        if match_public:
            username = match_public.group(1)
            msg_id = int(match_public.group(2))
            # Resolve username to chat_id? delete_message accepts username too like @username
            chat_id = f"@{username}"
            message_id = msg_id
        elif match_private:
            # Private chat id in links usually needs -100 prefix fix if not present
            c_id = match_private.group(1)
            chat_id = int(f"-100{c_id}")
            message_id = int(match_private.group(2))
            
    # 3. Try manual format ChatID:MessageID
    if not chat_id and message.text and ":" in message.text:
        try:
            parts = message.text.split(":")
            chat_id = int(parts[0])
            message_id = int(parts[1])
        except:
            pass

    if chat_id and message_id:
        try:
            await message.bot.delete_message(chat_id, message_id)
            await message.answer(f"âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© {message_id} Ù…Ù† {chat_id}")
            await state.clear()
            await message.answer("Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=get_admin_kb())
        except Exception as e:
            await message.answer(f"âŒ ÙØ´Ù„ Ø§Ù„Ø­Ø°Ù: {e}\n\nØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±Ù ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.")
    else:
        await message.answer("âš ï¸ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ùˆ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡.")

# ==========================================
# Chat Member Updates (Smart Real-time Stats)
# ==========================================
@router.my_chat_member()
async def bot_chat_member_update(update: types.ChatMemberUpdated):
    db = get_db()
    
    old_status = update.old_chat_member.status if update.old_chat_member else None
    new_status = update.new_chat_member.status if update.new_chat_member else None
    
    chat_id = update.chat.id
    chat_type = update.chat.type
    chat_title = update.chat.title or update.chat.username or "Unknown"
    user_id = update.from_user.id
    
    logger.info(f"ğŸ“Š Chat member update: {chat_type} {chat_id} - Status: {old_status} -> {new_status}")
    
    # Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…/Ø§Ù„ØªÙØ¹ÙŠÙ„
    if new_status in ["member", "administrator"]:
        if chat_type == "private":
            db.add_user(user_id, update.from_user.username)
            logger.info(f"âœ… User {user_id} (@{update.from_user.username}) started bot")
        else:
            # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
            invite_link = None
            try:
                # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©
                if update.chat.username:
                    invite_link = f"https://t.me/{update.chat.username}"
                else:
                    chat_obj = await update.bot.get_chat(chat_id)
                    if hasattr(chat_obj, 'invite_link'):
                        invite_link = chat_obj.invite_link
            except:
                pass
            
            db.add_chat(
                chat_id=chat_id,
                chat_type=chat_type,
                title=chat_title,
                username=update.chat.username,
                link=invite_link
            )
            logger.info(f"âœ… Bot added to {chat_type}: {chat_title} (ID: {chat_id})")
    
    # Ø­Ø§Ù„Ø© Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©/Ø§Ù„Ø·Ø±Ø¯
    elif new_status in ["left", "kicked"]:
        if chat_type == "private":
            db.update_entity_status(user_id, "user", "inactive")
            logger.info(f"âŒ User {user_id} blocked bot")
        else:
            db.remove_chat(chat_id)
            logger.info(f"âŒ Bot removed from {chat_type}: {chat_title} (ID: {chat_id})")

# ==========================================
# Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
# ==========================================

@router.message(F.text == "ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª")
async def btn_channels_groups_list(message: types.Message):
    """Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
    
    if not get_db().is_admin(message.from_user.id):
        return
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ø¯Ø§ÙˆÙ„ users Ùˆ chats Ù…Ø¨Ø§Ø´Ø±Ø©
    channels = conn.execute("""
        SELECT chat_id, title, username, status, added_date
        FROM chats
        WHERE type = 'channel' AND status = 'active'
        ORDER BY added_date DESC
    """).fetchall()
    
    groups = conn.execute("""
        SELECT chat_id, title, username, status, added_date
        FROM chats
        WHERE type IN ('group', 'supergroup') AND status = 'active'
        ORDER BY added_date DESC
    """).fetchall()
    
    # Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    stats_channels = conn.execute("""
        SELECT status, COUNT(*) as count
        FROM chats
        WHERE type = 'channel'
        GROUP BY status
    """).fetchall()
    
    stats_groups = conn.execute("""
        SELECT status, COUNT(*) as count
        FROM chats
        WHERE type IN ('group', 'supergroup')
        GROUP BY status
    """).fetchall()
    
    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    total_channels = sum(row[1] for row in stats_channels)
    active_channels = sum(row[1] for row in stats_channels if row[0] == 'active')
    
    total_groups = sum(row[1] for row in stats_groups)
    active_groups = sum(row[1] for row in stats_groups if row[0] == 'active')
    
    # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    stats_users = conn.execute("""
        SELECT status, COUNT(*) as count
        FROM users
        GROUP BY status
    """).fetchall()
    
    total_users = sum(row[1] for row in stats_users)
    active_users = sum(row[1] for row in stats_users if row[0] == 'active')
    
    conn.close()
    
    logger.info(f"ğŸ“Š Stats - Users: {active_users}/{total_users}, Channels: {active_channels}/{total_channels}, Groups: {active_groups}/{total_groups}")
    
    text = f"""

  ğŸ“¢ <b>Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</b>  


ğŸ“Š <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†: <code>{active_users}/{total_users}</code> Ù†Ø´Ø·
ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: <code>{active_channels}/{total_channels}</code> Ù†Ø´Ø·Ø©
ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: <code>{active_groups}/{total_groups}</code> Ù†Ø´Ø·Ø©

ğŸ“ˆ <b>Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</b> <code>{total_users + total_channels + total_groups}</code>
âœ… <b>Ø§Ù„Ù†Ø´Ø·:</b> <code>{active_users + active_channels + active_groups}</code>


"""
    
    # Ø§Ù„Ù‚Ù†ÙˆØ§Øª
    if channels:
        text += "\n<b>ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©:</b>\n\n"
        for i, row in enumerate(channels[:100], 1):
            chat_id = row[0]
            title = row[1]
            username = row[2] if len(row) > 2 else None
            invite_link = row[3] if len(row) > 3 else None
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø§Ø¨Ø·
            if username:
                link = f"https://t.me/{username}"
                text += f"{i}. âœ… <a href='{link}'>{title}</a>\n"
            elif invite_link:
                text += f"{i}. âœ… <a href='{invite_link}'>{title}</a>\n"
            else:
                text += f"{i}. âœ… {title} <code>({chat_id})</code>\n"
        
        if len(channels) > 100:
            text += f"\n<i>... ÙˆÙ‡Ù†Ø§Ùƒ {len(channels) - 100} Ù‚Ù†Ø§Ø© Ø£Ø®Ø±Ù‰</i>\n"
    
    # Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
    if groups:
        text += "\n\n<b>ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©:</b>\n\n"
        for i, row in enumerate(groups[:100], 1):
            chat_id = row[0]
            title = row[1]
            username = row[2] if len(row) > 2 else None
            invite_link = row[3] if len(row) > 3 else None
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø§Ø¨Ø·
            if username:
                link = f"https://t.me/{username}"
                text += f"{i}. âœ… <a href='{link}'>{title}</a>\n"
            elif invite_link:
                text += f"{i}. âœ… <a href='{invite_link}'>{title}</a>\n"
            else:
                text += f"{i}. âœ… {title} <code>({chat_id})</code>\n"
        
        if len(groups) > 100:
            text += f"\n<i>... ÙˆÙ‡Ù†Ø§Ùƒ {len(groups) - 100} Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ø®Ø±Ù‰</i>\n"
    
    if not channels and not groups:
        text += "\nâš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ø£Ùˆ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…Ø³Ø¬Ù„Ø©\n"
        text += "\nğŸ’¡ <b>Ù†ØµÙŠØ­Ø©:</b> Ø£Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰ Ù‚Ù†ÙˆØ§ØªÙƒ ÙˆÙ…Ø¬Ù…ÙˆØ¹Ø§ØªÙƒ Ù„ØªØ¸Ù‡Ø± Ù‡Ù†Ø§"
    
    text += "\n\n"
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ØªØ­Ø¯ÙŠØ«", callback_data="refresh_channels_list")],
        [InlineKeyboardButton(text="Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©", callback_data="channels_stats_detailed")],
        [InlineKeyboardButton(text="ØªØµØ¯ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©", callback_data="export_channels_list")]
    ])
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML", disable_web_page_preview=True)

@router.callback_query(F.data == "refresh_channels_list")
async def cb_refresh_channels(callback: types.CallbackQuery):
    """ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª"""
    await callback.answer("ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ«...")
    await callback.message.delete()
    
    # Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    await btn_channels_groups_list(callback.message)

@router.callback_query(F.data == "channels_stats_detailed")
async def cb_channels_stats_detailed(callback: types.CallbackQuery):
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
    
    db = get_db()
    stats = db.get_live_stats()
    
    if not stats:
        await callback.answer("âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", show_alert=True)
        return
    
    text = f"""
ğŸ“Š <b>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©</b>

ğŸ‘¤ <b>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{stats['users']['total']}</code>
â€¢ Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: <code>{stats['users']['active']}</code>
â€¢ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: <code>{stats['users']['inactive']}</code>
â€¢ Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: <code>{stats['users']['blocked']}</code>

ğŸ“¢ <b>Ø§Ù„Ù‚Ù†ÙˆØ§Øª:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{stats['channels']['total']}</code>
â€¢ Ø§Ù„Ù†Ø´Ø·Ø©: <code>{stats['channels']['active']}</code>
â€¢ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·Ø©: <code>{stats['channels']['inactive']}</code>

ğŸ‘¥ <b>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{stats['groups']['total']}</code>
â€¢ Ø§Ù„Ù†Ø´Ø·Ø©: <code>{stats['groups']['active']}</code>
â€¢ ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·Ø©: <code>{stats['groups']['inactive']}</code>

âš ï¸ <b>ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ:</b>
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{stats['unknown_chats']['total']}</code>
â€¢ Ø§Ù„Ù†Ø´Ø·Ø©: <code>{stats['unknown_chats']['active']}</code>

ğŸ“ˆ <b>Ø§Ù„Ù†Ø´Ø§Ø·:</b>
â€¢ Ø¬Ø¯Ø¯ Ø§Ù„ÙŠÙˆÙ…: <code>{stats['today']['new_users']}</code>
â€¢ Ù†Ø´Ø·ÙŠÙ† Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹: <code>{stats['week']['active_users']}</code>

ğŸ’¡ Ø§Ø³ØªØ®Ø¯Ù… get_live_stats() ÙÙ‚Ø·
"""
    
    await callback.answer()
    await callback.message.answer(text, parse_mode="HTML")

@router.callback_query(F.data == "back_to_channels_list")
async def cb_back_to_channels(callback: types.CallbackQuery):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª"""
    await callback.message.delete()
    await btn_channels_groups_list(callback.message)

@router.callback_query(F.data == "export_channels_list")
async def cb_export_channels(callback: types.CallbackQuery):
    """ØªØµØ¯ÙŠØ± Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙƒÙ…Ù„Ù"""
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„
    tables = [t[0] for t in conn.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()]
    
    export_text = "ğŸ“¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª\n"
    export_text += f"ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØµØ¯ÙŠØ±: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n"
    export_text += "=" * 50 + "\n\n"
    
    if 'entities' in tables:
        # Ø§Ù„Ù‚Ù†ÙˆØ§Øª
        channels = conn.execute("""
            SELECT entity_id, title, username, status
            FROM entities
            WHERE type = 'channel'
            ORDER BY title
        """).fetchall()
        
        export_text += f"Ø§Ù„Ù‚Ù†ÙˆØ§Øª ({len(channels)}):\n"
        export_text += "-" * 50 + "\n"
        for chat_id, title, username, status in channels:
            status_text = "Ù†Ø´Ø·" if status == "active" else "ØºÙŠØ± Ù†Ø´Ø·"
            link = f"https://t.me/{username}" if username else f"ID: {chat_id}"
            export_text += f"{title}\n{link}\nØ§Ù„Ø­Ø§Ù„Ø©: {status_text}\n\n"
        
        # Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
        groups = conn.execute("""
            SELECT entity_id, title, username, status
            FROM entities
            WHERE type IN ('group', 'supergroup')
            ORDER BY title
        """).fetchall()
        
        export_text += "\n" + "=" * 50 + "\n"
        export_text += f"Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ({len(groups)}):\n"
        export_text += "-" * 50 + "\n"
        for chat_id, title, username, status in groups:
            status_text = "Ù†Ø´Ø·" if status == "active" else "ØºÙŠØ± Ù†Ø´Ø·"
            link = f"https://t.me/{username}" if username else f"ID: {chat_id}"
            export_text += f"{title}\n{link}\nØ§Ù„Ø­Ø§Ù„Ø©: {status_text}\n\n"
    
    conn.close()
    
    # Ø­ÙØ¸ ÙƒÙ…Ù„Ù Ù…Ø¤Ù‚Øª ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡
    import io
    file = io.BytesIO(export_text.encode('utf-8'))
    file.name = f"channels_list_{datetime.now().strftime('%Y%m%d_%H%M')}.txt"
    
    await callback.message.answer_document(
        document=types.BufferedInputFile(file.getvalue(), filename=file.name),
        caption="ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"
    )
    
    await callback.answer("âœ… ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©!")

## ==========================================
# Advanced Scheduler Background Engine
# ==========================================
def check_scheduled_tasks():
    """Traditional sync scheduler function for BackgroundScheduler - DISABLED"""
    # ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª ÙˆØ§Ù„ÙˆØ±Ø¯
    pass

async def execute_scheduled_task(task_id, target, content_type, file_id, text, entities_json, service_filter='all'):
    """ğŸ”¥ ØªÙ†ÙÙŠØ° Ù…Ù‡Ù…Ø© Ù…Ø¬Ø¯ÙˆÙ„Ø© - Ù†Ø¸Ø§Ù… Ù…ØªØ·ÙˆØ± Ù…Ø¹ ØªØªØ¨Ø¹ Ø°ÙƒÙŠ"""
    try:
        db = get_db()
        
        # ğŸ¯ Ø¬Ù„Ø¨ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø¯Ù‚Ø©
        ids = db.get_broadcast_targets(target, only_active=True)
        
        if not ids:
            logger.warning(f"âš ï¸ Scheduled task #{task_id} has NO targets!")
            db.mark_task_executed(task_id, 0)
            return
        
        logger.info(f"ğŸš€ SCHEDULED TASK #{task_id} START: target={target}, ids={len(ids)}, type={content_type}")
        
        # ØªØ­ÙˆÙŠÙ„ entities Ù…Ù† JSON
        entities = []
        if entities_json and entities_json != "[]":
            try:
                entities_data = json.loads(entities_json)
                from aiogram.types import MessageEntity
                entities = [MessageEntity(**e) for e in entities_data]
            except:
                pass
        
        success_count = 0
        failed_count = 0
        failed_ids = []
        conn = db.get_connection()
        
        for uid in ids:
            status = 'failed'
            try:
                if content_type == 'photo':
                    await bot.send_photo(uid, file_id, caption=text, caption_entities=entities, parse_mode=None)
                elif content_type == 'video':
                    await bot.send_video(uid, file_id, caption=text, caption_entities=entities, parse_mode=None)
                elif content_type == 'audio':
                    await bot.send_audio(uid, file_id, caption=text, caption_entities=entities, parse_mode=None)
                elif content_type == 'voice':
                    await bot.send_voice(uid, file_id, caption=text, caption_entities=entities, parse_mode=None)
                elif content_type == 'document':
                    await bot.send_document(uid, file_id, caption=text, caption_entities=entities, parse_mode=None)
                elif content_type == 'animation':
                    await bot.send_animation(uid, file_id, caption=text, caption_entities=entities, parse_mode=None)
                elif content_type == 'sticker':
                    await bot.send_sticker(uid, file_id)
                else:
                    await bot.send_message(uid, text, entities=entities, parse_mode=None)
                
                success_count += 1
                status = 'success'
                logger.debug(f"âœ… Scheduled sent to {uid}")
                
                # âœ¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
                try:
                    if uid > 0:  # Ù…Ø³ØªØ®Ø¯Ù…
                        existing = conn.execute("SELECT user_id FROM users WHERE user_id=?", (uid,)).fetchone()
                        if not existing:
                            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                            conn.execute("""
                                INSERT INTO users (user_id, username, join_date, last_activity, status)
                                VALUES (?, ?, ?, ?, 'active')
                            """, (uid, None, now, now))
                            logger.info(f"âœ¨ SCHEDULED AUTO-REGISTERED USER: {uid}")
                        else:
                            conn.execute("""
                                UPDATE users 
                                SET status='active', last_activity=datetime('now')
                                WHERE user_id=?
                            """, (uid,))
                    else:  # Ù‚Ù†Ø§Ø©/Ù…Ø¬Ù…ÙˆØ¹Ø©
                        existing = conn.execute("SELECT chat_id FROM chats WHERE chat_id=?", (uid,)).fetchone()
                        if not existing:
                            try:
                                chat_info = await bot.get_chat(uid)
                                now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                conn.execute("""
                                    INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                                    VALUES (?, ?, ?, ?, ?, 'active')
                                """, (uid, chat_info.type, chat_info.title or "Unknown", now, now))
                                logger.info(f"âœ¨ SCHEDULED AUTO-REGISTERED CHAT: {uid}")
                            except:
                                now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                conn.execute("""
                                    INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                                    VALUES (?, 'group', 'Unknown', ?, ?, 'active')
                                """, (uid, now, now))
                        else:
                            conn.execute("""
                                UPDATE chats 
                                SET status='active', last_activity=datetime('now')
                                WHERE chat_id=?
                            """, (uid,))
                except Exception as reg_error:
                    logger.warning(f"âš ï¸ Scheduled auto-register failed for {uid}: {reg_error}")
                
            except Exception as e:
                failed_count += 1
                failed_ids.append(uid)
                logger.warning(f"âŒ Scheduled failed to {uid}: {e}")
                
                # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…/Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
                try:
                    if 'bot was blocked' in str(e).lower() or 'user is deactivated' in str(e).lower():
                        conn.execute("UPDATE users SET status='blocked' WHERE user_id=?", (uid,))
                    elif 'chat not found' in str(e).lower() or 'bot was kicked' in str(e).lower():
                        conn.execute("UPDATE chats SET status='inactive' WHERE chat_id=?", (uid,))
                except:
                    pass
            
            # Ø­ÙØ¸ ÙÙŠ broadcast_history
            try:
                conn.execute("""
                    INSERT INTO broadcast_history 
                    (target, status, sent_at, service) 
                    VALUES (?, ?, datetime('now'), 'scheduled')
                """, (uid, status))
            except:
                pass
            
            await asyncio.sleep(0.05)
        
        conn.commit()
        conn.close()
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ­Ø°Ù Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
        db.mark_task_executed(task_id, success_count)
        logger.info(f"Task #{task_id} completed: {success_count} success, {failed_count} failed")
        
    except Exception as e:
        logger.error(f"Execute scheduled task error: {e}")

async def scheduler_worker():
    """Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ø¬Ø¯ÙˆÙ„Ø© - ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ…Ø± (Async)"""
    logger.info("âœ… Scheduler Worker Started - Checking every minute")
    
    # Ø§Ù†ØªØ¸Ø§Ø± 5 Ø«ÙˆØ§Ù†ÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
    await asyncio.sleep(5)
    
    while True:
        try:
            # Sync with next minute
            now = datetime.now()
            current_time = now.strftime("%H:%M")
            sleep_seconds = 60 - now.second
            
            logger.info(f"â° Scheduler check at {current_time} - sleeping {sleep_seconds}s until next minute")
            await asyncio.sleep(sleep_seconds)

            db = get_db()
            
            # 1. Advanced Scheduler Tasks
            db.cleanup_expired_tasks()
            tasks = db.get_pending_tasks()
            
            if tasks:
                logger.info(f"ğŸ¯ Advanced Scheduler: Found {len(tasks)} tasks to execute at {current_time}")
                for task in tasks:
                    task_id, task_type, target, content_type, file_id, text, entities, service, days_of_week, end_date, last_run = task
                    
                    # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù‡Ù…Ø© Ù„Ù… ØªÙØ­Ø°Ù
                    task_exists = db.get_connection().execute(
                        "SELECT id FROM scheduled_tasks WHERE id=? AND is_active=1",
                        (task_id,)
                    ).fetchone()
                    
                    if not task_exists:
                        logger.warning(f"âš ï¸ Task #{task_id} was deleted, skipping")
                        continue
                    
                    logger.info(f"ğŸ“¤ Executing task #{task_id} (type: {task_type}, target: {target})")
                    asyncio.create_task(
                        execute_scheduled_task(task_id, target, content_type, file_id, text, entities, service)
                    )
            else:
                logger.debug(f"No tasks to execute at {current_time}")

            # 2. Smart Alarms System (Ù…Ø¹Ø·Ù„)
            # due_alarms = db.get_due_alarms()
            # if due_alarms:
            #      logger.info(f"Smart Alarms: Found {len(due_alarms)} due alarms to process")
            #      asyncio.create_task(process_due_alarms(due_alarms))

        except asyncio.CancelledError:
            logger.info("Scheduler Worker stopped")
            break
        except Exception as e:
            logger.error(f"Scheduler Worker Error: {e}", exc_info=True)
            await asyncio.sleep(5)

async def process_due_alarms(rows):
    """Execution logic for Smart Alarms - DISABLED"""
    # ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª
    pass

# ==========================================
# Helpers for content browsing (updated for DB)
# ==========================================

# ==========================================
# Helpers for content browsing (updated for DB)
# ==========================================

# ==========================================
# âš¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹ ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© - ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù‚Ø¨Ù„ user_tracker
# ==========================================

@router.message(F.text.in_(["Ø±Ø¬ÙˆØ¹", "â—€ï¸ Ø±Ø¬ÙˆØ¹", "Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", "Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…", "Ø±Ø¬ÙˆØ¹ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø¢ÙØ§Ù‚", "Ø±Ø¬ÙˆØ¹ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª"]))
async def btn_back(message: types.Message, state: FSMContext):
    """Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© - handler Ù…ÙˆØ­Ø¯ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹"""
    await state.clear()
    
    db = get_db()
    is_admin = db.is_admin(message.from_user.id)
    
    # Ø§Ù„Ø¹ÙˆØ¯Ø© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø²Ø±
    if "Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" in message.text or "Ù„Ø¥Ø¯Ø§Ø±Ø©" in message.text:
        if is_admin:
            await btn_admin_panel(message, state)
        else:
            await message.answer("Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=get_main_kb(message.from_user.id, False))
    elif "Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©" in message.text:
        await message.answer("Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=get_main_kb(message.from_user.id, is_admin))
    else:
        # Ø²Ø± Ø±Ø¬ÙˆØ¹ Ø¹Ø§Ø¯ÙŠ
        if is_admin:
            await btn_admin_panel(message, state)
        else:
            await message.answer("Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=get_main_kb(message.from_user.id, False))

@router.message(F.text == "ğŸ¯ Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±")
async def btn_buttons_manager(message: types.Message):
    """Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø´Ø§Ù…Ù„Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¨ÙˆØª"""
    if not get_db().is_admin(message.from_user.id):
        return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø¯Ø§Ø±Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")],
        [types.KeyboardButton(text="Ø¥Ø¯Ø§Ø±Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø±Ø¢Ù†")],
        [types.KeyboardButton(text="Ø¥Ø¯Ø§Ø±Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£Ø°ÙƒØ§Ø±")],
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø¬Ø¯ÙŠØ¯")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ø²Ø±")],
        [types.KeyboardButton(text="ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø²Ø±")],
        [types.KeyboardButton(text="ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø±")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…")]
    ], resize_keyboard=True)
    
    text = (
        "ğŸ¯ <b>Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø£Ø²Ø±Ø§Ø±</b>\n\n"
        "Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¯Ø§Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¨ÙˆØª:\n\n"
        "â€¢ <b>Ø¥Ø¯Ø§Ø±Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:</b> ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©\n"
        "â€¢ <b>Ø¥Ø¯Ø§Ø±Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø±Ø¢Ù†:</b> Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…\n"
        "â€¢ <b>Ø¥Ø¯Ø§Ø±Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£Ø°ÙƒØ§Ø±:</b> Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø°ÙƒØ§Ø±\n"
        "â€¢ <b>Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø¬Ø¯ÙŠØ¯:</b> Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ù…Ø®ØµØµ\n"
        "â€¢ <b>Ø­Ø°Ù Ø²Ø±:</b> Ø­Ø°Ù Ø²Ø± Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…\n"
        "â€¢ <b>ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø²Ø±:</b> Ø¥Ø®ÙØ§Ø¡ Ø£Ùˆ Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø±\n"
        "â€¢ <b>ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø±:</b> ØªØºÙŠÙŠØ± ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø±\n\n"
        "ğŸ’¡ <i>Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©</i>"
    )
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text.in_(["Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", "ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"]))
async def btn_main_menu(message: types.Message, state: FSMContext):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    # Ù…Ø³Ø­ Ø£ÙŠ state Ù†Ø´Ø·
    await state.clear()
    await cmd_start(message)

# ==========================================
# Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
# ==========================================

@router.message(F.text.in_(["Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª", "ğŸ”„ Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª", "ğŸ”„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©", "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©"]))
async def btn_sync_chats(message: types.Message, state: FSMContext):
    """Ù…Ø²Ø§Ù…Ù†Ø© ÙˆØªØ³Ø¬ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ
    current_users = conn.execute("SELECT COUNT(*) FROM users WHERE status='active'").fetchone()[0]
    current_chats = conn.execute("SELECT COUNT(*) FROM chats WHERE status='active'").fetchone()[0]
    total = current_users + current_chats
    conn.close()
    
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="âœ… ÙÙ‡Ù…ØªØŒ Ø³Ø£Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†", callback_data="sync_understood")]
    ])
    
    await message.answer(
        f"ğŸ“Š <b>Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:</b>\n"
        f"ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: <code>{current_users}</code>\n"
        f"ğŸ’¬ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: <code>{current_chats}</code>\n"
        f"ğŸ“ˆ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{total}</code>\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"âš ï¸ <b>Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹:</b>\n"
        f"Telegram Ù„Ø§ ÙŠØ³Ù…Ø­ Ù„Ù„Ø¨ÙˆØªØ§Øª Ø¨Ø±Ø¤ÙŠØ© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!\n\n"
        f"âœ… <b>Ø§Ù„Ø­Ù„ Ø§Ù„Ø¨Ø³ÙŠØ· (Ø·Ø±ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·):</b>\n\n"
        f"<b>ÙÙŠ ÙƒÙ„ Ù‚Ù†Ø§Ø©/Ù…Ø¬Ù…ÙˆØ¹Ø© Ù‚Ø¯ÙŠÙ…Ø©:</b>\n"
        f"1ï¸âƒ£ Ø§ÙØªØ­ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©\n"
        f"2ï¸âƒ£ Ø§ÙƒØªØ¨ Ø£ÙŠ Ø´ÙŠØ¡ (Ø­ØªÙ‰ Ù†Ù‚Ø·Ø© <code>.</code>)\n"
        f"3ï¸âƒ£ Ø³ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!\n\n"
        f"ğŸ’¡ <b>Ù†ØµÙŠØ­Ø©:</b>\n"
        f"â€¢ Ø§ÙØªØ­ ÙƒÙ„ Ù‚Ù†Ø§Ø©\n"
        f"â€¢ Ø§ÙƒØªØ¨: <code>/start</code>\n"
        f"â€¢ Ø§Ù†ØªÙ‚Ù„ Ù„Ù„ØªØ§Ù„ÙŠØ©\n"
        f"â€¢ ÙƒØ±Ø± Ø­ØªÙ‰ ØªÙ†ØªÙ‡ÙŠ\n\n"
        f"â±ï¸ <b>Ø§Ù„Ù…Ø¯Ø©:</b> 2-3 Ø¯Ù‚Ø§Ø¦Ù‚ Ù„Ù€ 220 Ù…Ø­Ø§Ø¯Ø«Ø©\n\n"
        f"ğŸ“Š Ø¨Ø¹Ø¯Ù‡Ø§ Ø§Ø°Ù‡Ø¨ Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ³ØªØ±Ø§Ù‡Ø§ ÙƒÙ„Ù‡Ø§!",
        parse_mode="HTML",
        reply_markup=keyboard
    )

@router.callback_query(F.data == "sync_understood")
async def cb_sync_understood(callback: types.CallbackQuery):
    """Ø¨Ø¹Ø¯ Ø£Ù† ÙŠÙÙ‡Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©"""
    await callback.message.edit_text(
        "âœ… <b>Ù…Ù…ØªØ§Ø²!</b>\n\n"
        "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†:\n"
        "â€¢ Ø§ÙØªØ­ ÙƒÙ„ Ù‚Ù†Ø§Ø©/Ù…Ø¬Ù…ÙˆØ¹Ø© Ù‚Ø¯ÙŠÙ…Ø©\n"
        "â€¢ Ø§ÙƒØªØ¨ <code>/start</code> Ø£Ùˆ <code>.</code>\n"
        "â€¢ Ø§Ù†ØªÙ‚Ù„ Ù„Ù„ØªØ§Ù„ÙŠØ©\n\n"
        "ğŸ’¡ <b>Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„ØªÙ‚Ø¯Ù…:</b>\n"
        "Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</b> ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø¯Ø«\n\n"
        "ğŸ¯ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ØŒ Ø§Ù„Ø¹Ø¯Ø¯ Ø³ÙŠÙƒÙˆÙ† 220+",
        parse_mode="HTML"
    )
    await callback.answer()

# ==========================================
# Data Protection Handlers - Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
# ==========================================

@router.message(F.text.in_(["Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", "ğŸ›¡ï¸ Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"]))
async def btn_data_protection(message: types.Message):
    """Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØ·ÙˆØ±"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="ğŸ’¾ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø¢Ù†"), types.KeyboardButton(text="ğŸ“‹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©")],
        [types.KeyboardButton(text="â™»ï¸ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù†Ø³Ø®Ø©"), types.KeyboardButton(text="ğŸ” ÙØ­Øµ Ø§Ù„Ø³Ù„Ø§Ù…Ø©")],
        [types.KeyboardButton(text="ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹")]
    ], resize_keyboard=True)
    
    # Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø³Ø±ÙŠØ¹Ø©
    backups = data_protection.list_backups()
    integrity = "âœ… Ø³Ù„ÙŠÙ…Ø©" if data_protection.check_integrity() else "âŒ ØªØ§Ù„ÙØ©"
    db_size = round(os.path.getsize(DB_NAME) / (1024*1024), 2) if os.path.exists(DB_NAME) else 0
    
    await message.answer(
        f"ğŸ›¡ï¸ <b>Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØ·ÙˆØ±</b>\n\n"
        f"ğŸ“Š <b>Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:</b>\n"
        f"  â€¢ Ø­Ø¬Ù… Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©: <code>{db_size} MB</code>\n"
        f"  â€¢ Ø§Ù„Ø³Ù„Ø§Ù…Ø©: {integrity}\n"
        f"  â€¢ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: <code>{len(backups)}</code>\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"âš¡ <b>Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:</b>\n"
        f"âœ… Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù…Ø¶ØºÙˆØ·Ø©\n"
        f"âœ… ÙØ­Øµ Ø³Ù„Ø§Ù…Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠ\n"
        f"âœ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø³Ø±ÙŠØ¹Ø©\n"
        f"âœ… Ø­Ù…Ø§ÙŠØ© Ù…Ù† ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n\n"
        f"Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡:",
        reply_markup=keyboard,
        parse_mode="HTML"
    )

@router.message(F.text.in_(["Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø¢Ù†", "ğŸ’¾ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø¢Ù†"]))
async def btn_create_backup_now(message: types.Message):
    """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ÙÙˆØ±ÙŠØ©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©...")
    
    success, path, msg = data_protection.create_backup("manual", compress=True)
    
    if success:
        await wait_msg.edit_text(
            f"âœ… <b>ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
            f"ğŸ“ <b>Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª:</b>\n"
            f"  â€¢ {msg}\n"
            f"  â€¢ Ø§Ù„Ù…ÙˆÙ‚Ø¹: <code>bot_data/backups/manual/</code>\n\n"
            f"ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡Ø§ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø®",
            parse_mode="HTML"
        )
    else:
        await wait_msg.edit_text(
            f"âŒ <b>ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©</b>\n\n"
            f"Ø§Ù„Ø®Ø·Ø£: <code>{msg}</code>",
            parse_mode="HTML"
        )

@router.message(F.text.in_(["Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©", "ğŸ“‹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©"]))
async def btn_list_backups(message: types.Message):
    """Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª...")
    
    backups = data_protection.list_backups()
    
    if not backups:
        await wait_msg.edit_text(
            "âš ï¸ <b>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©</b>\n\n"
            "Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹",
            parse_mode="HTML"
        )
        return
    
    # ØªØ¬Ù…ÙŠØ¹ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
    by_type = {}
    for backup in backups:
        btype = backup['type']
        if btype not in by_type:
            by_type[btype] = []
        by_type[btype].append(backup)
    
    text = "ğŸ“‹ <b>Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ù…ØªÙˆÙØ±Ø©</b>\n\n"
    
    for btype, items in by_type.items():
        type_emoji = {"manual": "ğŸ“", "daily": "ğŸ“…", "weekly": "ğŸ“†", "monthly": "ğŸ—“ï¸", "auto": "âš™ï¸"}.get(btype, "ğŸ“¦")
        type_name = {"manual": "ÙŠØ¯ÙˆÙŠØ©", "daily": "ÙŠÙˆÙ…ÙŠØ©", "weekly": "Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©", "monthly": "Ø´Ù‡Ø±ÙŠØ©", "auto": "ØªÙ„Ù‚Ø§Ø¦ÙŠØ©"}.get(btype, btype)
        
        text += f"{type_emoji} <b>{type_name}</b> ({len(items)}):\n"
        
        for i, backup in enumerate(items[:5], 1):  # Ø£ÙˆÙ„ 5 ÙÙ‚Ø·
            date_str = backup['date'].strftime("%Y-%m-%d %H:%M")
            text += f"  {i}. {backup['size_mb']} MB - {date_str}\n"
        
        if len(items) > 5:
            text += f"  ... Ùˆ {len(items) - 5} Ù†Ø³Ø® Ø£Ø®Ø±Ù‰\n"
        text += "\n"
    
    text += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += f"ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{len(backups)}</code> Ù†Ø³Ø®Ø©\n"
    text += f"ğŸ’¾ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„ÙƒÙ„ÙŠØ©: <code>{sum(b['size_mb'] for b in backups):.2f} MB</code>"
    
    # Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="â™»ï¸ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø£Ø­Ø¯Ø« Ù†Ø³Ø®Ø©", callback_data=f"restore_latest")],
        [types.InlineKeyboardButton(text="ğŸ”™ Ø±Ø¬ÙˆØ¹", callback_data="back_to_protection")]
    ])
    
    await wait_msg.edit_text(text, parse_mode="HTML", reply_markup=keyboard)

@router.callback_query(F.data == "restore_latest")
async def cb_restore_latest(callback: types.CallbackQuery):
    """Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø£Ø­Ø¯Ø« Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©"""
    backups = data_protection.list_backups()
    if not backups:
        await callback.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©!", show_alert=True)
        return
    
    latest = backups[0]
    
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="âœ… Ù†Ø¹Ù…ØŒ Ø§Ø³ØªØ¹Ø§Ø¯Ø©", callback_data=f"restore_confirm_{backups[0]['file']}")],
        [types.InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="back_to_protection")]
    ])
    
    await callback.message.edit_text(
        f"âš ï¸ <b>ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©</b>\n\n"
        f"ğŸ“¦ Ø§Ù„Ù†Ø³Ø®Ø©: <code>{latest['file']}</code>\n"
        f"ğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: {latest['date'].strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"ğŸ’¾ Ø§Ù„Ø­Ø¬Ù…: {latest['size_mb']} MB\n\n"
        f"â— Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©!\n"
        f"ğŸ’¡ Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ù† Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©\n\n"
        f"Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ",
        parse_mode="HTML",
        reply_markup=keyboard
    )
    await callback.answer()

@router.callback_query(F.data.startswith("restore_confirm_"))
async def cb_restore_confirm(callback: types.CallbackQuery):
    """ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©"""
    filename = callback.data.replace("restore_confirm_", "")
    
    # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ÙƒØ§Ù…Ù„
    backups = data_protection.list_backups()
    backup_path = None
    for b in backups:
        if b['file'] == filename:
            backup_path = b['path']
            break
    
    if not backup_path:
        await callback.answer("Ø§Ù„Ù†Ø³Ø®Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©!", show_alert=True)
        return
    
    await callback.message.edit_text("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©...")
    
    success, msg = data_protection.restore_backup(backup_path)
    
    if success:
        await callback.message.edit_text(
            f"âœ… <b>ØªÙ…Øª Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
            f"{msg}\n\n"
            f"ğŸ’¡ Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª",
            parse_mode="HTML"
        )
    else:
        await callback.message.edit_text(
            f"âŒ <b>ÙØ´Ù„Øª Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©</b>\n\n"
            f"Ø§Ù„Ø®Ø·Ø£: <code>{msg}</code>",
            parse_mode="HTML"
        )
    await callback.answer()

@router.callback_query(F.data == "back_to_protection")
async def cb_back_to_protection(callback: types.CallbackQuery):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    await callback.message.delete()
    await callback.answer()

@router.message(F.text.in_(["ÙØ­Øµ Ø§Ù„Ø³Ù„Ø§Ù…Ø©", "ğŸ” ÙØ­Øµ Ø§Ù„Ø³Ù„Ø§Ù…Ø©"]))
async def btn_check_integrity(message: types.Message):
    """ÙØ­Øµ Ø³Ù„Ø§Ù…Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø³Ù„Ø§Ù…Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    
    is_ok = data_protection.check_integrity()
    
    if is_ok:
        await wait_msg.edit_text(
            "âœ… <b>Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø³Ù„ÙŠÙ…Ø©</b>\n\n"
            "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø´Ø§ÙƒÙ„ ÙÙŠ Ø§Ù„Ø¨Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
            parse_mode="HTML"
        )
    else:
        await wait_msg.edit_text(
            "âŒ <b>Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ù„ÙØ©!</b>\n\n"
            "âš ï¸ ÙŠÙÙ†ØµØ­ Ø¨Ù€:\n"
            "1. Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø³Ù„ÙŠÙ…Ø©\n"
            "2. Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ± Ø¥Ø°Ø§ Ø§Ø³ØªÙ…Ø±Øª Ø§Ù„Ù…Ø´ÙƒÙ„Ø©",
            parse_mode="HTML"
        )

@router.message(F.text.in_(["Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©", "ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©"]))
async def btn_db_info(message: types.Message):
    """Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ØªÙØµÙŠÙ„ÙŠØ© Ø¹Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª...")
    
    try:
        db = get_db()
        conn = db.get_connection()
        
        # Ø­Ø¬Ù… Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
        db_size = round(os.path.getsize(DB_NAME) / (1024*1024), 2)
        
        # Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table'")
        table_count = cursor.fetchone()[0]
        
        # Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        main_tables = {
            'users': 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
            'chats': 'Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª',
            'scheduled_tasks': 'Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©',
            'broadcast_history': 'Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø§Øª',
            'reciters': 'Ø§Ù„Ù‚Ø±Ø§Ø¡',
            'quran_audio': 'Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ'
        }
        
        text = f"ğŸ“Š <b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</b>\n\n"
        text += f"ğŸ“¦ <b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ø§Ù…Ø©:</b>\n"
        text += f"  â€¢ Ø§Ù„Ø­Ø¬Ù…: <code>{db_size} MB</code>\n"
        text += f"  â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„: <code>{table_count}</code>\n"
        text += f"  â€¢ Ø§Ù„Ø³Ù„Ø§Ù…Ø©: {'âœ… Ø³Ù„ÙŠÙ…Ø©' if data_protection.check_integrity() else 'âŒ ØªØ§Ù„ÙØ©'}\n\n"
        
        text += f"ğŸ“‹ <b>Ø§Ù„Ø³Ø¬Ù„Ø§Øª ÙÙŠ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:</b>\n"
        for table, name in main_tables.items():
            try:
                cursor.execute(f"SELECT COUNT(*) FROM {table}")
                count = cursor.fetchone()[0]
                text += f"  â€¢ {name}: <code>{count:,}</code>\n"
            except:
                text += f"  â€¢ {name}: <code>N/A</code>\n"
        
        # Ø¢Ø®Ø± Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
        backups = data_protection.list_backups()
        if backups:
            latest = backups[0]
            text += f"\nğŸ’¾ <b>Ø¢Ø®Ø± Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©:</b>\n"
            text += f"  â€¢ Ø§Ù„ØªØ§Ø±ÙŠØ®: {latest['date'].strftime('%Y-%m-%d %H:%M')}\n"
            text += f"  â€¢ Ø§Ù„Ø­Ø¬Ù…: {latest['size_mb']} MB\n"
        
        conn.close()
        
        await wait_msg.edit_text(text, parse_mode="HTML")
    
    except Exception as e:
        await wait_msg.edit_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª: <code>{e}</code>", parse_mode="HTML")

# ==========================================
# Admin Panel Buttons - MUST BE BEFORE user_tracker
# ==========================================

@router.message(F.text.in_(["Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†", "ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†"]))
async def btn_admin_management(message: types.Message):
    """Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ù…Ø´Ø±Ù")],
        [types.KeyboardButton(text="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(
        "<b>ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†</b>\n\naØ®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:",
        reply_markup=keyboard,
        parse_mode="HTML"
    )

@router.message(F.text.in_(["Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", "ğŸ“£ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"]))
async def btn_channels_groups_direct(message: types.Message):
    """Ø²Ø± Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª - Ø¹Ø±Ø¶ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    
    db = get_db()
    conn = db.get_connection()
    
    channels = conn.execute("""
        SELECT chat_id, title, username, invite_link 
        FROM chats 
        WHERE type='channel' AND status='active'
        ORDER BY title
    """).fetchall()
    
    groups = conn.execute("""
        SELECT chat_id, title, username, invite_link 
        FROM chats 
        WHERE type IN ('group', 'supergroup') AND status='active'
        ORDER BY title
    """).fetchall()
    
    conn.close()
    
    text = f"""â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ“¢ <b>Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<b>ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
â€¢ Ù‚Ù†ÙˆØ§Øª Ù†Ø´Ø·Ø©: <code>{len(channels)}</code>
â€¢ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù†Ø´Ø·Ø©: <code>{len(groups)}</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    if channels:
        text += "ğŸ“¢ <b>Ø§Ù„Ù‚Ù†ÙˆØ§Øª:</b>\n\n"
        for ch_id, title, username, invite in channels:
            link = f"https://t.me/{username}" if username else (invite or "ØºÙŠØ± Ù…ØªÙˆÙØ±")
            text += f"â€¢ <b>{title}</b>\n  ğŸ”— {link}\n\n"
    else:
        text += "âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ù†Ø´Ø·Ø©\n"
    
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    
    if groups:
        text += "ğŸ‘¥ <b>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:</b>\n\n"
        for g_id, title, username, invite in groups:
            link = f"https://t.me/{username}" if username else (invite or "ØºÙŠØ± Ù…ØªÙˆÙØ±")
            text += f"â€¢ <b>{title}</b>\n  ğŸ”— {link}\n\n"
    else:
        text += "âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù†Ø´Ø·Ø©\n"
    
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += "ğŸ’¡ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø¨ÙˆØª Ø§Ù„Ù†Ø´Ø± ÙÙŠ Ø¬Ù…ÙŠØ¹ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML", disable_web_page_preview=True)

# === ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø£Ø²Ø±Ø§Ø±: Ø¬Ù…Ø¹ IDs + ØªØµØ­ÙŠØ­ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø´Ø§Øª + ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª ===

# Ø­Ø§Ù„Ø© FSM Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ IDs
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©...")
    
    try:
        conn = get_db().get_connection()
        
        # Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ IDs Ù…Ù† broadcast_history (Ø§Ù„Ø¹Ù…ÙˆØ¯: target)
        broadcast_ids = set()
        try:
            cursor = conn.execute("SELECT DISTINCT target FROM broadcast_history WHERE target IS NOT NULL")
            for row in cursor.fetchall():
                if row[0]:
                    broadcast_ids.add(row[0])
        except Exception as e:
            logger.warning(f"âš ï¸ Error reading broadcast_history: {e}")
        
        # Ø¬Ù…Ø¹ IDs Ù…Ù† activity_log (Ø§Ù„Ø¹Ù…ÙˆØ¯: entity_id)
        activity_ids = set()
        try:
            cursor = conn.execute("SELECT DISTINCT entity_id FROM activity_log WHERE entity_id IS NOT NULL")
            for row in cursor.fetchall():
                if row[0]:
                    activity_ids.add(row[0])
        except Exception as e:
            logger.warning(f"âš ï¸ Error reading activity_log: {e}")
        
        # Ø¬Ù…Ø¹ IDs Ù…Ù† contact_messages
        contact_ids = set()
        try:
            cursor = conn.execute("SELECT DISTINCT from_user_id FROM contact_messages WHERE from_user_id IS NOT NULL")
            for row in cursor.fetchall():
                if row[0]:
                    contact_ids.add(row[0])
        except:
            pass
        
        # Ø¯Ù…Ø¬ ÙƒÙ„ IDs
        all_ids = broadcast_ids | activity_ids | contact_ids
        
        logger.info(f"ğŸ” Found {len(all_ids)} unique IDs from history")
        
        # ÙØ­Øµ Ø£ÙŠ Ù…Ù†Ù‡Ø§ ØºÙŠØ± Ù…Ø³Ø¬Ù„
        new_users = 0
        new_chats = 0
        errors = 0
        
        for uid in all_ids:
            try:
                if uid > 0:  # User
                    # ÙØ­Øµ Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯
                    existing = conn.execute("SELECT user_id FROM users WHERE user_id=?", (uid,)).fetchone()
                    if not existing:
                        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                        conn.execute("""
                            INSERT INTO users (user_id, username, join_date, last_activity, status)
                            VALUES (?, 'legacy_user', datetime('now'), datetime('now'), 'active')
                        """, (uid,))
                        new_users += 1
                        logger.info(f"âœ¨ Registered legacy user: {uid}")
                else:  # Chat
                    # ÙØ­Øµ Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯
                    existing = conn.execute("SELECT chat_id FROM chats WHERE chat_id=?", (uid,)).fetchone()
                    if not existing:
                        try:
                            # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø§Øª
                            chat_info = await bot.get_chat(uid)
                            chat_type = chat_info.type
                            chat_title = chat_info.title or "Unknown"
                            
                            conn.execute("""
                                INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                                VALUES (?, ?, ?, datetime('now'), datetime('now'), 'active')
                            """, (uid, chat_type, chat_title))
                            new_chats += 1
                            logger.info(f"âœ¨ Registered legacy chat: {uid} ({chat_type}: {chat_title})")
                        except Exception as e:
                            # Ø¥Ø°Ø§ ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§ØªØŒ ØªØ³Ø¬ÙŠÙ„ Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
                            conn.execute("""
                                INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                                VALUES (?, 'unknown', 'Legacy Chat', datetime('now'), datetime('now'), 'inactive')
                            """, (uid,))
                            new_chats += 1
                            logger.warning(f"âš ï¸ Registered legacy chat with basic info: {uid}")
            except Exception as e:
                errors += 1
                logger.error(f"âŒ Error processing ID {uid}: {e}")
        
        conn.commit()
        
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø­Ø¯Ø«Ø©
        stats = get_db().get_live_stats()
        
        result_text = f"""ğŸ” <b>Ù†ØªØ§Ø¦Ø¬ Ø¬Ù…Ø¹ IDs:</b>

ğŸ“Š <b>IDs Ø§Ù„Ù…ÙƒØªØ´ÙØ© Ù…Ù† Ø§Ù„Ø³Ø¬Ù„Ø§Øª:</b>
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(all_ids)}
â€¢ Ù…Ù† broadcast_history: {len(broadcast_ids)}
â€¢ Ù…Ù† activity_log: {len(activity_ids)}
â€¢ Ù…Ù† contact_messages: {len(contact_ids)}

âœ¨ <b>Ø§Ù„ØªØ³Ø¬ÙŠÙ„Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:</b>
â€¢ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¬Ø¯Ø¯: {new_users}
â€¢ Ù‚Ù†ÙˆØ§Øª/Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©: {new_chats}
â€¢ Ø£Ø®Ø·Ø§Ø¡: {errors}

ğŸ“ˆ <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©:</b>
â€¢ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {stats['users']['total']} ({stats['users']['active']} Ù†Ø´Ø·)
â€¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: {stats['channels']['total']} ({stats['channels']['active']} Ù†Ø´Ø·Ø©)
â€¢ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {stats['groups']['total']} ({stats['groups']['active']} Ù†Ø´Ø·Ø©)

ğŸ’¡ Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø°Ø§Ø¹Ø§Øª Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ†!

ğŸ“ <b>Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù‚Ø¯Ø§Ù…Ù‰ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ† ÙÙŠ Ø§Ù„Ø³Ø¬Ù„Ø§Øª:</b>
â€¢ Ø£Ø±Ø³Ù„ Ù…Ù„Ù Ù†ØµÙŠ (.txt) ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ IDs (ÙƒÙ„ ID ÙÙŠ Ø³Ø·Ø± Ù…Ù†ÙØµÙ„)
â€¢ Ù…Ø«Ø§Ù„: 
  123456789
  -1001234567890
  987654321"""
        
        # Ø¥Ø¶Ø§ÙØ© keyboard Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯
        keyboard = types.ReplyKeyboardMarkup(keyboard=[
            [types.KeyboardButton(text="ğŸŒ Ø¬Ù„Ø¨ Ù…Ù† Telegram")],
            [types.KeyboardButton(text="ğŸ“„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù…Ù„Ù"), types.KeyboardButton(text="ğŸ’¾ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ù‚Ø¯ÙŠÙ…Ø©")],
            [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…")]
        ], resize_keyboard=True)
        
        await wait_msg.delete()
        await message.answer(result_text, parse_mode="HTML", reply_markup=keyboard)
        
    except Exception as e:
        logger.error(f"âŒ Error in collect_ids: {e}")
        await wait_msg.delete()
        await message.answer(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")

# ØªÙ… Ø­Ø°Ù: ImportIDsStates FSM ÙˆÙƒÙ„ Ø¯ÙˆØ§Ù„ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯

@router.message(F.text.in_(["Ø¬Ù„Ø¨ Ù…Ù† Telegram", "ğŸŒ Ø¬Ù„Ø¨ Ù…Ù† Telegram", "ğŸ”„ Ø¬Ù„Ø¨ Ù…Ù† Telegram API"]))
async def btn_fetch_from_telegram(message: types.Message):
    """Ø¬Ù„Ø¨ IDs Ù…Ù† Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«Ø§Øª Telegram"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ù…Ù† Telegram...\nÙ‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ø¯Ù‚ÙŠÙ‚Ø©...")
    
    try:
        from aiogram.methods import GetUpdates
        
        collected_users = set()
        collected_chats = set()
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¬Ù„Ø¨ Ø¢Ø®Ø± 100 ØªØ­Ø¯ÙŠØ«
        offset = -100  # Ø¢Ø®Ø± 100 update
        
        try:
            # Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… getUpdates
            updates = await bot.get_updates(offset=offset, limit=100, timeout=30)
            
            logger.info(f"ğŸ“¥ Received {len(updates)} updates from Telegram")
            
            for update in updates:
                # Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø£Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„ÙØ© Ù…Ù† Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
                
                # Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
                if update.message:
                    if update.message.from_user:
                        collected_users.add(update.message.from_user.id)
                    if update.message.chat:
                        chat_id = update.message.chat.id
                        if chat_id < 0:  # Group or Channel
                            collected_chats.add(chat_id)
                        else:
                            collected_users.add(chat_id)
                
                # Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø­Ø±Ø±Ø©
                if update.edited_message:
                    if update.edited_message.from_user:
                        collected_users.add(update.edited_message.from_user.id)
                    if update.edited_message.chat:
                        chat_id = update.edited_message.chat.id
                        if chat_id < 0:
                            collected_chats.add(chat_id)
                
                # Ù…Ù† callback queries
                if update.callback_query:
                    if update.callback_query.from_user:
                        collected_users.add(update.callback_query.from_user.id)
                    if update.callback_query.message and update.callback_query.message.chat:
                        chat_id = update.callback_query.message.chat.id
                        if chat_id < 0:
                            collected_chats.add(chat_id)
                
                # Ù…Ù† my_chat_member (Ø¹Ù†Ø¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª)
                if update.my_chat_member:
                    if update.my_chat_member.from_user:
                        collected_users.add(update.my_chat_member.from_user.id)
                    if update.my_chat_member.chat:
                        chat_id = update.my_chat_member.chat.id
                        if chat_id < 0:
                            collected_chats.add(chat_id)
                
                # Ù…Ù† chat_member
                if update.chat_member:
                    if update.chat_member.from_user:
                        collected_users.add(update.chat_member.from_user.id)
                    if update.chat_member.chat:
                        chat_id = update.chat_member.chat.id
                        if chat_id < 0:
                            collected_chats.add(chat_id)
            
            logger.info(f"âœ… Collected {len(collected_users)} users, {len(collected_chats)} chats")
            
        except Exception as e:
            logger.error(f"âŒ Error fetching updates: {e}")
            # Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ø§Ø³ØªØ®Ø¯Ø§Ù… getMe Ù„Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
            await wait_msg.edit_text("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø¯ÙŠÙ„Ø©...")
        
        # ØªØ³Ø¬ÙŠÙ„ IDs
        conn = get_db().get_connection()
        new_users = 0
        new_chats = 0
        already_exists = 0
        errors = 0
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        for uid in collected_users:
            try:
                existing = conn.execute("SELECT user_id FROM users WHERE user_id=?", (uid,)).fetchone()
                if not existing:
                    # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                    try:
                        user_info = await bot.get_chat(uid)
                        username = user_info.username or f"user_{uid}"
                        first_name = user_info.first_name or ""
                        
                        conn.execute("""
                            INSERT INTO users (user_id, username, first_name, join_date, last_activity, status)
                            VALUES (?, ?, ?, datetime('now'), datetime('now'), 'active')
                        """, (uid, username, first_name))
                        new_users += 1
                        logger.info(f"âœ¨ Fetched user: {uid} (@{username})")
                    except:
                        # ØªØ³Ø¬ÙŠÙ„ Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
                        conn.execute("""
                            INSERT INTO users (user_id, username, join_date, last_activity, status)
                            VALUES (?, ?, datetime('now'), datetime('now'), 'active')
                        """, (uid, f"user_{uid}"))
                        new_users += 1
                else:
                    already_exists += 1
                    # ØªØ­Ø¯ÙŠØ« last_activity
                    conn.execute("UPDATE users SET last_activity=datetime('now') WHERE user_id=?", (uid,))
            except Exception as e:
                errors += 1
                logger.error(f"âŒ Error processing user {uid}: {e}")
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
        for uid in collected_chats:
            try:
                existing = conn.execute("SELECT chat_id FROM chats WHERE chat_id=?", (uid,)).fetchone()
                if not existing:
                    try:
                        chat_info = await bot.get_chat(uid)
                        chat_type = chat_info.type
                        chat_title = chat_info.title or "Unknown"
                        
                        conn.execute("""
                            INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                            VALUES (?, ?, ?, datetime('now'), datetime('now'), 'active')
                        """, (uid, chat_type, chat_title))
                        new_chats += 1
                        logger.info(f"âœ¨ Fetched chat: {uid} ({chat_type}: {chat_title})")
                    except Exception as e:
                        # ØªØ³Ø¬ÙŠÙ„ Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
                        conn.execute("""
                            INSERT INTO chats (chat_id, type, title, join_date, last_activity, status)
                            VALUES (?, 'unknown', 'Fetched Chat', datetime('now'), datetime('now'), 'active')
                        """, (uid,))
                        new_chats += 1
                        logger.warning(f"âš ï¸ Fetched chat with basic info: {uid}")
                else:
                    already_exists += 1
                    # ØªØ­Ø¯ÙŠØ« last_activity
                    conn.execute("UPDATE chats SET last_activity=datetime('now') WHERE chat_id=?", (uid,))
            except Exception as e:
                errors += 1
                logger.error(f"âŒ Error processing chat {uid}: {e}")
        
        conn.commit()
        
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø­Ø¯Ø«Ø©
        stats = get_db().get_live_stats()
        
        total_collected = len(collected_users) + len(collected_chats)
        
        if total_collected == 0:
            result_text = """âš ï¸ <b>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</b>

ğŸ’¡ <b>Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„:</b>
Ù„Ù… ÙŠØªÙØ§Ø¹Ù„ Ø£Ø­Ø¯ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØª Ù…Ø¤Ø®Ø±Ø§Ù‹ Ø£Ùˆ ØªÙ… Ù…Ø³Ø­ ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª.

ğŸ¯ <b>Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©:</b>

<b>1. Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¯ÙŠÙ…Ø©:</b>
   â€¢ Ø§Ø¶ØºØ· "ğŸ’¾ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ù‚Ø¯ÙŠÙ…Ø©"
   â€¢ Ø³ÙŠØ¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª ÙˆØ³Ù„Ø© Ø§Ù„Ù…Ù‡Ù…Ù„Ø§Øª

<b>2. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù„Ù IDs:</b>
   â€¢ Ø§Ø¶ØºØ· "ğŸ“„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù…Ù„Ù"
   â€¢ Ø£Ø±Ø³Ù„ Ù…Ù„Ù txt Ø¨Ù‡ IDs

<b>3. Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±:</b>
   â€¢ Ø§Ø±Ø³Ù„ Ø¥Ø°Ø§Ø¹Ø© Ù„Ø£ÙŠ ID ØªØ¹Ø±ÙÙ‡
   â€¢ Ø³ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„Ù†Ø¬Ø§Ø­"""
        else:
            result_text = f"""âœ… <b>ØªÙ… Ø¬Ù„Ø¨ IDs Ù…Ù† Telegram!</b>

ğŸ“Š <b>IDs Ø§Ù„Ù…ÙƒØªØ´ÙØ©:</b>
â€¢ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {len(collected_users)}
â€¢ Ù‚Ù†ÙˆØ§Øª/Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {len(collected_chats)}
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_collected}

âœ¨ <b>Ø§Ù„ØªØ³Ø¬ÙŠÙ„Ø§Øª:</b>
â€¢ Ø¬Ø¯ÙŠØ¯: {new_users + new_chats}
â€¢ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹: {already_exists}
â€¢ Ø£Ø®Ø·Ø§Ø¡: {errors}

ğŸ“ˆ <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©:</b>
â€¢ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {stats['users']['total']} ({stats['users']['active']} Ù†Ø´Ø·)
â€¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: {stats['channels']['total']} ({stats['channels']['active']} Ù†Ø´Ø·Ø©)
â€¢ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {stats['groups']['total']} ({stats['groups']['active']} Ù†Ø´Ø·Ø©)
â€¢ <b>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: {stats['broadcast']['all_targets']}</b>

ğŸ¯ Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø°Ø§Ø¹Ø§Øª Ù„Ù‡Ù…!"""
        
        await wait_msg.delete()
        await message.answer(result_text, parse_mode="HTML")
        
        # Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…
        await btn_admin_panel(message)
        
    except Exception as e:
        logger.error(f"âŒ Error in fetch_from_telegram: {e}")
        await wait_msg.delete()
        
        error_text = f"""âŒ <b>Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¬Ù„Ø¨</b>

Ø§Ù„Ø®Ø·Ø£: {str(e)}

ğŸ’¡ <b>Ø¬Ø±Ø¨ Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø©:</b>

<b>1. Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ù‚Ø¯ÙŠÙ…Ø©:</b>
Ø§Ø¶ØºØ· "ğŸ’¾ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ù‚Ø¯ÙŠÙ…Ø©"

<b>2. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù„Ù IDs:</b>
Ø§Ø¶ØºØ· "ğŸ“„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù…Ù„Ù"""
        
        await message.answer(error_text, parse_mode="HTML")

# === ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ handlers: btn_fix_chat_types, btn_check_bot_admin, btn_check_registered_chats, btn_discover_new_chats, btn_import_from_old_db, import_all_old_dbs ===

@router.message(F.text.in_(["Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ø±Ø¯Ø©", "ğŸ“¬ Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ø±Ø¯Ø©"]))
async def btn_inbox(message: types.Message):
    """Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„...")
    
    conn = get_db().get_connection()
    cursor = conn.execute("""
        SELECT id, from_user_id, from_username, content, sent_at, is_replied, content_type, file_id
        FROM contact_messages
        ORDER BY sent_at DESC
        LIMIT 50
    """)
    messages = cursor.fetchall()
    
    if not messages:
        keyboard = types.ReplyKeyboardMarkup(keyboard=[
            [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
        ], resize_keyboard=True)
        
        await wait_msg.delete()
        await message.answer("ğŸ“¬ <b>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ø±Ø¯Ø©</b>", parse_mode="HTML", reply_markup=keyboard)
        return
    
    unread_count = sum(1 for m in messages if not m[5])
    total_count = len(messages)
    
    text = f"""ğŸ“¬ <b>Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©</b>

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_count}
â€¢ ØºÙŠØ± Ù…Ù‚Ø±ÙˆØ¡Ø©: {unread_count}
â€¢ Ù…Ù‚Ø±ÙˆØ¡Ø©: {total_count - unread_count}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    for msg in messages:
        msg_id, user_id, username, content, sent_at, is_replied, content_type, file_id = msg
        status = "âœ…" if is_replied else "â³"
        user_display = f"@{username}" if username else f"User {user_id}"
        preview = content[:30] + "..." if content and len(content) > 30 else (content or "[Ù…Ù„Ù]")
        text += f"{status} <b>#{msg_id}</b> - {user_display}\n   {preview}\n\n"
    
    text += "\nğŸ’¡ <i>Ø§Ø³ØªØ®Ø¯Ù…:</i> /view_contact Ø±Ù‚Ù…_Ø§Ù„Ø±Ø³Ø§Ù„Ø© <i>Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙƒØ§Ù…Ù„Ø©</i>"
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text.in_(["Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ", "ğŸ™ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ"]))
async def btn_audio_admin(message: types.Message):
    """Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    
    db = get_db()
    conn = db.get_connection()
    
    total_reciters = conn.execute("SELECT COUNT(*) FROM reciters").fetchone()[0] or 0
    total_audio = conn.execute("SELECT COUNT(*) FROM quran_audio").fetchone()[0] or 0
    total_surahs = 114
    coverage = (total_audio / (total_reciters * total_surahs) * 100) if total_reciters > 0 else 0
    
    recent_reciters = conn.execute("""
        SELECT name FROM reciters 
        ORDER BY id DESC 
        LIMIT 3
    """).fetchall()
    
    conn.close()
    
    recent_list = "\n".join([f"  â€¢ {r[0]}" for r in recent_reciters]) if recent_reciters else "  Ù„Ø§ ÙŠÙˆØ¬Ø¯"
    
    text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ™ï¸ <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Ø§Ù„Ù‚Ø±Ø§Ø¡: <code>{total_reciters}</code>
â€¢ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØµÙˆØªÙŠØ©: <code>{total_audio}</code>
â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„ØªØºØ·ÙŠØ©: <code>{coverage:.1f}%</code>

ğŸ“Œ <b>Ø£Ø­Ø¯Ø« Ø§Ù„Ù‚Ø±Ø§Ø¡:</b>
{recent_list}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ <b>Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:</b>
"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="â• Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦"), types.KeyboardButton(text="ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡")],
        [types.KeyboardButton(text="ğŸ“¤ Ø±ÙØ¹ ØªÙ„Ø§ÙˆØ©"), types.KeyboardButton(text="ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø±Ø¦")],
        [types.KeyboardButton(text="ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©"), types.KeyboardButton(text="ğŸ—‘ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø°Ù")],
        [types.KeyboardButton(text="âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©"), types.KeyboardButton(text="ğŸŒ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† API")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# ==========================================
# Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦ Ø¬Ø¯ÙŠØ¯ - ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ user_tracker
# ==========================================

@router.message(F.text == "â• Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦")
async def btn_add_reciter(message: types.Message, state: FSMContext):
    """Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦ Ø¬Ø¯ÙŠØ¯"""
    if not get_db().is_admin(message.from_user.id): return
    
    await message.answer(
        "ğŸ“ <b>Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦ Ø¬Ø¯ÙŠØ¯</b>\n\n"
        "Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.quran_add_reciter_name)

@router.message(F.text == "ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡")
async def btn_list_reciters(message: types.Message):
    """Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø±Ø§Ø¡"""
    if not get_db().is_admin(message.from_user.id): return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...")
    
    db = get_db()
    conn = db.get_connection()
    
    reciters = conn.execute("""
        SELECT id, name, description,
               (SELECT COUNT(*) FROM quran_audio WHERE reciter_id = reciters.id) as audio_count
        FROM reciters
        ORDER BY name
    """).fetchall()
    
    conn.close()
    
    if not reciters:
        await wait_msg.delete()
        await message.answer(
            "ğŸ“‹ <b>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡</b>\n\n"
            "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚Ø±Ø§Ø¡ Ù…Ø³Ø¬Ù„ÙˆÙ† Ø­Ø§Ù„ÙŠØ§Ù‹\n\n"
            "ğŸ’¡ Ø§Ø³ØªØ®Ø¯Ù… 'Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦' Ù„Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦ Ø¬Ø¯ÙŠØ¯",
            parse_mode="HTML"
        )
        return
    
    text = f"""ğŸ“‹ <b>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡</b>

ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: <code>{len(reciters)}</code> Ù‚Ø§Ø±Ø¦

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    for reciter in reciters:
        rec_id, name, desc, audio_count = reciter
        desc_text = f"\n  ğŸ“ {desc[:50]}..." if desc else ""
        text += f"""<b>{name}</b>
  ğŸ†” ID: <code>{rec_id}</code>
  ğŸµ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª: {audio_count} Ø³ÙˆØ±Ø©{desc_text}

"""
    
    text += "\nğŸ’¡ Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø±Ø¦ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ 'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø°Ù'"
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="â• Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦", callback_data="add_reciter")],
        [InlineKeyboardButton(text="âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø§Ø±Ø¦", callback_data="edit_reciter")],
        [InlineKeyboardButton(text="ğŸ—‘ï¸ Ø­Ø°Ù Ù‚Ø§Ø±Ø¦", callback_data="delete_reciter")]
    ])
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "ğŸ“¤ Ø±ÙØ¹ ØªÙ„Ø§ÙˆØ©")
async def btn_upload_audio(message: types.Message, state: FSMContext):
    """Ø±ÙØ¹ Ù…Ù„Ù ØµÙˆØªÙŠ Ø¬Ø¯ÙŠØ¯"""
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    conn = db.get_connection()
    reciters = conn.execute("SELECT id, name FROM reciters ORDER BY name").fetchall()
    conn.close()
    
    if not reciters:
        await message.answer(
            "âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚Ø±Ø§Ø¡ Ù…Ø³Ø¬Ù„ÙˆÙ†\n\n"
            "ğŸ’¡ ÙŠØ¬Ø¨ Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦ Ø£ÙˆÙ„Ø§Ù‹ Ù…Ù† 'Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦'",
            parse_mode="HTML"
        )
        return
    
    text = "ğŸ“¤ <b>Ø±ÙØ¹ ØªÙ„Ø§ÙˆØ© Ø¬Ø¯ÙŠØ¯Ø©</b>\n\n" \
           "Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø§Ø±Ø¦:\n\n"
    
    keyboard = []
    for rec_id, name in reciters:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ™ï¸ {name}",
            callback_data=f"upload_reciter_{rec_id}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")])
    
    await message.answer(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )

@router.message(F.text == "ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø±Ø¦")
async def btn_search_reciter(message: types.Message, state: FSMContext):
    """Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø±Ø¦"""
    if not get_db().is_admin(message.from_user.id): return
    
    await message.answer(
        "ğŸ” <b>Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø±Ø¦</b>\n\n"
        "Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø£Ùˆ Ø¬Ø²Ø¡ Ù…Ù†Ù‡:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.quran_select_reciter)

@router.message(F.text == "ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©")
async def btn_audio_stats(message: types.Message):
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ØªÙØµÙŠÙ„ÙŠØ© Ù„Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ"""
    if not get_db().is_admin(message.from_user.id): return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„...")
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¹Ø§Ù…Ø©
    total_reciters = conn.execute("SELECT COUNT(*) FROM reciters").fetchone()[0] or 0
    total_audio = conn.execute("SELECT COUNT(*) FROM quran_audio").fetchone()[0] or 0
    total_size = conn.execute("SELECT SUM(file_size) FROM quran_audio").fetchone()[0] or 0
    total_duration = conn.execute("SELECT SUM(duration) FROM quran_audio").fetchone()[0] or 0
    
    # Ø£ÙƒØ«Ø± Ø§Ù„Ù‚Ø±Ø§Ø¡ ØªÙ„Ø§ÙˆØ§Øª
    top_reciters = conn.execute("""
        SELECT r.name, COUNT(qa.id) as count
        FROM reciters r
        LEFT JOIN quran_audio qa ON r.id = qa.reciter_id
        GROUP BY r.id
        ORDER BY count DESC
        LIMIT 5
    """).fetchall()
    
    # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø­Ø³Ø¨ Ø§Ù„Ø´Ù‡Ø±
    monthly = conn.execute("""
        SELECT strftime('%Y-%m', uploaded_at) as month, COUNT(*) as count
        FROM quran_audio
        GROUP BY month
        ORDER BY month DESC
        LIMIT 6
    """).fetchall()
    
    conn.close()
    
    text = f"""ğŸ“Š <b>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Œ <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¹Ø§Ù…Ø©:</b>
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‚Ø±Ø§Ø¡: <code>{total_reciters}</code>
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª: <code>{total_audio}</code>
â€¢ Ù…Ø³Ø§Ø­Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ†: <code>{total_size / (1024*1024):.2f} MB</code>
â€¢ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„ÙƒÙ„ÙŠØ©: <code>{total_duration // 3600}h {(total_duration % 3600) // 60}m</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ† <b>Ø£ÙƒØ«Ø± 5 Ù‚Ø±Ø§Ø¡ ØªÙ„Ø§ÙˆØ§Øª:</b>
"""
    
    for i, (name, count) in enumerate(top_reciters, 1):
        text += f"{i}. {name}: <code>{count}</code> Ø³ÙˆØ±Ø©\n"
    
    text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nğŸ“ˆ <b>Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠØ©:</b>\n"
    
    for month, count in monthly:
        text += f"â€¢ {month}: <code>{count}</code> ØªÙ„Ø§ÙˆØ©\n"
    
    await wait_msg.delete()
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "ğŸ—‘ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø°Ù")
async def btn_delete_management(message: types.Message):
    """Ø¥Ø¯Ø§Ø±Ø© Ø­Ø°Ù Ø§Ù„Ù‚Ø±Ø§Ø¡ ÙˆØ§Ù„ØªÙ„Ø§ÙˆØ§Øª"""
    if not get_db().is_admin(message.from_user.id): return
    
    text = """ğŸ—‘ï¸ <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø°Ù</b>

âš ï¸ <b>ØªØ­Ø°ÙŠØ±:</b> Ø§Ù„Ø­Ø°Ù Ù†Ù‡Ø§Ø¦ÙŠ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡!

Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø­Ø°Ù:"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="ğŸ—‘ï¸ Ø­Ø°Ù Ù‚Ø§Ø±Ø¦"), types.KeyboardButton(text="ğŸ—‘ï¸ Ø­Ø°Ù ØªÙ„Ø§ÙˆØ©")],
        [types.KeyboardButton(text="ğŸ—‘ï¸ Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø§Ø±Ø¦")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹")]
    ], resize_keyboard=True)
    
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "ğŸ—‘ï¸ Ø­Ø°Ù Ù‚Ø§Ø±Ø¦")
async def btn_delete_reciter(message: types.Message, state: FSMContext):
    """Ø­Ø°Ù Ù‚Ø§Ø±Ø¦"""
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    conn = db.get_connection()
    reciters = conn.execute("""
        SELECT id, name, 
               (SELECT COUNT(*) FROM quran_audio WHERE reciter_id = reciters.id) as count
        FROM reciters
        ORDER BY name
    """).fetchall()
    conn.close()
    
    if not reciters:
        await message.answer("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚Ø±Ø§Ø¡ Ù„Ø­Ø°ÙÙ‡Ù…")
        return
    
    keyboard = []
    for rec_id, name, count in reciters:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ—‘ï¸ {name} ({count} ØªÙ„Ø§ÙˆØ©)",
            callback_data=f"confirm_delete_rec_{rec_id}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")])
    
    await message.answer(
        "ğŸ—‘ï¸ <b>Ø­Ø°Ù Ù‚Ø§Ø±Ø¦</b>\n\n"
        "âš ï¸ Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªÙ„Ø§ÙˆØ§Øª Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø£ÙŠØ¶Ø§Ù‹!\n\n"
        "Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø°ÙÙ‡:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )

@router.message(F.text == "ğŸ—‘ï¸ Ø­Ø°Ù ØªÙ„Ø§ÙˆØ©")
async def btn_delete_audio(message: types.Message):
    """Ø­Ø°Ù ØªÙ„Ø§ÙˆØ© Ù…Ø­Ø¯Ø¯Ø©"""
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ù…Ø¹ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù‚Ø±Ø§Ø¡
    audios = conn.execute("""
        SELECT qa.id, r.name, qa.surah_number
        FROM quran_audio qa
        JOIN reciters r ON qa.reciter_id = r.id
        ORDER BY r.name, qa.surah_number
    """).fetchall()
    
    conn.close()
    
    if not audios:
        await message.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ„Ø§ÙˆØ§Øª Ù„Ø­Ø°ÙÙ‡Ø§")
        return
    
    # Ø¥Ù†Ø´Ø§Ø¡ keyboard Ø¨Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10 ØªÙ„Ø§ÙˆØ§Øª (Ù„Ù…Ù†Ø¹ ØªØ¬Ø§ÙˆØ² Ø­Ø¬Ù… Ø§Ù„Ø±Ø³Ø§Ù„Ø©)
    keyboard = []
    for audio_id, reciter_name, surah_num in audios[:10]:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ—‘ï¸ {reciter_name} - Ø³ÙˆØ±Ø© {surah_num}",
            callback_data=f"confirm_del_audio_{audio_id}"
        )])
    
    if len(audios) > 10:
        keyboard.append([InlineKeyboardButton(
            text=f"... Ùˆ {len(audios)-10} ØªÙ„Ø§ÙˆØ© Ø£Ø®Ø±Ù‰",
            callback_data="show_more_audio"
        )])
    
    keyboard.append([InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")])
    
    await message.answer(
        f"ğŸ—‘ï¸ <b>Ø­Ø°Ù ØªÙ„Ø§ÙˆØ©</b>\n\n"
        f"ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {len(audios)} ØªÙ„Ø§ÙˆØ©\n\n"
        f"Ø§Ø®ØªØ± Ø§Ù„ØªÙ„Ø§ÙˆØ© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø°ÙÙ‡Ø§:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )

@router.message(F.text == "ğŸ—‘ï¸ Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø§Ø±Ø¦")
async def btn_delete_reciter_audios(message: types.Message):
    """Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø§Ø±Ø¦ Ù…Ø¹ÙŠÙ†"""
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    conn = db.get_connection()
    
    reciters = conn.execute("""
        SELECT r.id, r.name, COUNT(qa.id) as count
        FROM reciters r
        LEFT JOIN quran_audio qa ON r.id = qa.reciter_id
        GROUP BY r.id
        HAVING count > 0
        ORDER BY r.name
    """).fetchall()
    
    conn.close()
    
    if not reciters:
        await message.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ„Ø§ÙˆØ§Øª Ù„Ø­Ø°ÙÙ‡Ø§")
        return
    
    keyboard = []
    for rec_id, name, count in reciters:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ—‘ï¸ {name} ({count} ØªÙ„Ø§ÙˆØ©)",
            callback_data=f"confirm_del_rec_audios_{rec_id}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")])
    
    await message.answer(
        "ğŸ—‘ï¸ <b>Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ ØªÙ„Ø§ÙˆØ§Øª Ù‚Ø§Ø±Ø¦</b>\n\n"
        "âš ï¸ Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª ÙÙ‚Ø· (Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø³ÙŠØ¨Ù‚Ù‰)\n\n"
        "Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø§Ø±Ø¦:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )

@router.message(F.text == "ğŸŒ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† API")
async def btn_import_api(message: types.Message):
    """Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù‚Ø±Ø§Ø¡ Ù…Ù† quran.com API"""
    if not get_db().is_admin(message.from_user.id): return
    
    text = """ğŸŒ <b>Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† API</b>

ğŸ“¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù‚Ø±Ø§Ø¡ ÙˆØªÙ„Ø§ÙˆØ§Øª Ù…Ù†:
â€¢ quran.com
â€¢ alquran.cloud
â€¢ mp3quran.net

âš™ï¸ <b>Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±</b>

ğŸ’¡ Ø­Ø§Ù„ÙŠØ§Ù‹ ÙŠÙ…ÙƒÙ†Ùƒ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù…Ù† 'Ø±ÙØ¹ ØªÙ„Ø§ÙˆØ©'"""
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©")
async def btn_advanced_settings(message: types.Message):
    """Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ"""
    if not get_db().is_admin(message.from_user.id): return
    
    text = """âš™ï¸ <b>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</b>

ğŸ”§ <b>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>
â€¢ Ø¬ÙˆØ¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„
â€¢ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
â€¢ Ø­Ø¯ Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø£Ù‚ØµÙ‰
â€¢ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©

ğŸ’¡ <b>Ù‚Ø±ÙŠØ¨Ø§Ù‹...</b>"""
    
    await message.answer(text, parse_mode="HTML")

# ==========================================
# Handlers Ù„Ù„Ù€ States Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ
# ==========================================

@router.message(Form.quran_add_reciter_name)
async def process_add_reciter_name(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø§Ù„Ø¬Ø¯ÙŠØ¯"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
        await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        return
    
    reciter_name = message.text.strip()
    
    if not reciter_name or len(reciter_name) < 2:
        await message.answer("âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹! Ø£Ø¯Ø®Ù„ Ø§Ø³Ù…Ø§Ù‹ ØµØ­ÙŠØ­Ø§Ù‹.")
        return
    
    await state.update_data(reciter_name=reciter_name)
    
    await message.answer(
        f"âœ… Ø§Ù„Ø§Ø³Ù…: <b>{reciter_name}</b>\n\n"
        "ğŸ“ Ø£Ø±Ø³Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ø¹Ù† Ø§Ù„Ù‚Ø§Ø±Ø¦ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):\n"
        "Ø£Ùˆ Ø§Ø¶ØºØ· /skip Ù„Ù„ØªØ®Ø·ÙŠ",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.quran_add_reciter_info)

@router.message(Form.quran_add_reciter_info)
async def process_add_reciter_info(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø±Ø¦"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
        await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        return
    
    data = await state.get_data()
    reciter_name = data.get('reciter_name')
    
    description = None if message.text == "/skip" else message.text.strip()
    
    # Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ø±Ø¦ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    db = get_db()
    conn = db.get_connection()
    
    try:
        cursor = conn.execute(
            "INSERT INTO reciters (name, description, created_at) VALUES (?, ?, datetime('now'))",
            (reciter_name, description)
        )
        reciter_id = cursor.lastrowid
        conn.commit()
        
        await message.answer(
            f"âœ… <b>ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
            f"ğŸ™ï¸ Ø§Ù„Ø§Ø³Ù…: {reciter_name}\n"
            f"ğŸ†” Ø§Ù„Ø±Ù‚Ù…: <code>{reciter_id}</code>\n\n"
            f"ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø±ÙØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª Ù…Ù† 'Ø±ÙØ¹ ØªÙ„Ø§ÙˆØ©'",
            parse_mode="HTML"
        )
    except Exception as e:
        await message.answer(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸: {e}")
        logger.error(f"Error adding reciter: {e}")
    finally:
        conn.close()
    
    await state.clear()
    keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
    await message.answer("ØªÙ…!", reply_markup=keyboard)

@router.message(Form.quran_select_reciter)
async def process_search_reciter(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø±Ø¦"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
        await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        return
    
    search_term = message.text.strip()
    
    db = get_db()
    conn = db.get_connection()
    
    reciters = conn.execute("""
        SELECT id, name, description,
               (SELECT COUNT(*) FROM quran_audio WHERE reciter_id = reciters.id) as audio_count
        FROM reciters
        WHERE name LIKE ?
        ORDER BY name
    """, (f"%{search_term}%",)).fetchall()
    
    conn.close()
    
    if not reciters:
        await message.answer(
            f"âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù‚Ø±Ø§Ø¡ Ø¨Ø§Ø³Ù…: <b>{search_term}</b>\n\n"
            "ğŸ’¡ Ø¬Ø±Ø¨ ÙƒÙ„Ù…Ø§Øª Ø¨Ø­Ø« Ø£Ø®Ø±Ù‰",
            parse_mode="HTML"
        )
        await state.clear()
        return
    
    text = f"""ğŸ” <b>Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†:</b> {search_term}

ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬: <code>{len(reciters)}</code> Ù‚Ø§Ø±Ø¦

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    for reciter in reciters:
        rec_id, name, desc, audio_count = reciter
        desc_text = f"\n  ğŸ“ {desc[:50]}..." if desc else ""
        text += f"""<b>{name}</b>
  ğŸ†” ID: <code>{rec_id}</code>
  ğŸµ Ø§Ù„ØªÙ„Ø§ÙˆØ§Øª: {audio_count} Ø³ÙˆØ±Ø©{desc_text}

"""
    
    await message.answer(text, parse_mode="HTML")
    await state.clear()
    
    keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
    await message.answer("ØªÙ…!", reply_markup=keyboard)

@router.message(Form.quran_select_surah)
async def process_select_surah(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø³ÙˆØ±Ø©"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
        await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        return
    
    try:
        surah_number = int(message.text)
        if surah_number < 1 or surah_number > 114:
            await message.answer("âš ï¸ Ø±Ù‚Ù… Ø§Ù„Ø³ÙˆØ±Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ÙŠÙ† 1 Ùˆ 114")
            return
    except ValueError:
        await message.answer("âš ï¸ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ø³ÙˆØ±Ø© (1-114)")
        return
    
    await state.update_data(surah_number=surah_number)
    
    await message.answer(
        f"âœ… Ø§Ù„Ø³ÙˆØ±Ø© Ø±Ù‚Ù…: <code>{surah_number}</code>\n\n"
        "ğŸ“¤ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ Ù„Ù„ØªÙ„Ø§ÙˆØ©",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.quran_upload_audio)

@router.message(Form.quran_upload_audio)
async def process_upload_audio(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ"""
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
        await message.answer("âŒ ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=keyboard)
        return
    
    if not message.audio and not message.voice:
        await message.answer("âš ï¸ Ø£Ø±Ø³Ù„ Ù…Ù„Ù ØµÙˆØªÙŠ (Audio Ø£Ùˆ Voice)")
        return
    
    data = await state.get_data()
    reciter_id = data.get('reciter_id')
    surah_number = data.get('surah_number')
    
    # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù„Ù
    if message.audio:
        file_id = message.audio.file_id
        file_size = message.audio.file_size
        duration = message.audio.duration
    else:
        file_id = message.voice.file_id
        file_size = message.voice.file_size
        duration = message.voice.duration
    
    # Ø­ÙØ¸ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    db = get_db()
    conn = db.get_connection()
    
    try:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØªÙ„Ø§ÙˆØ© Ù…ÙƒØ±Ø±Ø©
        existing = conn.execute(
            "SELECT id FROM quran_audio WHERE reciter_id=? AND surah_number=?",
            (reciter_id, surah_number)
        ).fetchone()
        
        if existing:
            await message.answer(
                "âš ï¸ <b>ØªØ­Ø°ÙŠØ±:</b> ÙŠÙˆØ¬Ø¯ ØªÙ„Ø§ÙˆØ© Ù…Ø³Ø¬Ù„Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø³ÙˆØ±Ø© Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ø±Ø¦!\n\n"
                "Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡Ø§ØŸ",
                parse_mode="HTML"
            )
            # ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© ØªØ£ÙƒÙŠØ¯ Ù‡Ù†Ø§
        
        conn.execute("""
            INSERT OR REPLACE INTO quran_audio 
            (reciter_id, surah_number, file_id, file_size, duration, uploaded_at)
            VALUES (?, ?, ?, ?, ?, datetime('now'))
        """, (reciter_id, surah_number, file_id, file_size, duration))
        
        conn.commit()
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ø±Ø¦
        reciter_name = conn.execute(
            "SELECT name_ar FROM reciters WHERE id=?", (reciter_id,)
        ).fetchone()[0]
        
        await message.answer(
            f"âœ… <b>ØªÙ… Ø±ÙØ¹ Ø§Ù„ØªÙ„Ø§ÙˆØ© Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
            f"ğŸ™ï¸ Ø§Ù„Ù‚Ø§Ø±Ø¦: {reciter_name}\n"
            f"ğŸ“– Ø§Ù„Ø³ÙˆØ±Ø©: {surah_number}\n"
            f"â±ï¸ Ø§Ù„Ù…Ø¯Ø©: {duration}s\n"
            f"ğŸ’¾ Ø§Ù„Ø­Ø¬Ù…: {file_size / 1024:.1f} KB",
            parse_mode="HTML"
        )
    except Exception as e:
        await message.answer(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸: {e}")
        logger.error(f"Error uploading audio: {e}")
    finally:
        conn.close()
    
    await state.clear()
    keyboard = get_admin_kb() if get_db().is_admin(message.from_user.id) else get_main_kb(message.from_user.id, False)
    await message.answer("ØªÙ…!", reply_markup=keyboard)

# ==========================================
# ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª - ÙŠØ£ØªÙŠ Ø¨Ø¹Ø¯ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹
# ==========================================

@router.message()
async def user_tracker(message: types.Message, state: FSMContext):
    """ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ø­Ù„ Ø¬Ø°Ø±ÙŠ Ù…Ø­Ø¯Ø«"""
    try:
        db = get_db()
        
        # ØªØ³Ø¬ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ø­ØªÙ‰ Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†) Ù„ØªØ­Ø¯ÙŠØ« last_activity
        if message.from_user:
            db.add_user(message.from_user.id, message.from_user.username)
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
        if message.chat.type in ['group', 'supergroup', 'channel']:
            invite_link = None
            try:
                if message.chat.username:
                    invite_link = f"https://t.me/{message.chat.username}"
            except:
                pass
            
            db.add_chat(
                chat_id=message.chat.id,
                chat_type=message.chat.type,
                title=message.chat.title or "Unknown",
                username=message.chat.username,
                link=invite_link
            )
    except Exception as e:
        logger.error(f"âŒ User tracker error: {e}")

# ==========================================
# Main
# ==========================================

# ==========================================
# New Features: Onboarding & Content Manager
# ==========================================

from aiogram.filters import ChatMemberUpdatedFilter, IS_NOT_MEMBER, IS_MEMBER, MEMBER, ADMINISTRATOR
from aiogram.types import ChatMemberUpdated

@router.my_chat_member(ChatMemberUpdatedFilter(member_status_changed=IS_NOT_MEMBER >> IS_MEMBER))
async def on_bot_added_to_chat(event: ChatMemberUpdated):
    chat = event.chat
    if chat.type not in ['group', 'supergroup', 'channel']:
        return
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    db = get_db()
    db.add_chat(
        chat_id=chat.id,
        chat_type=chat.type,
        title=chat.title or "Unknown",
        username=chat.username
    )
    logger.info(f"âœ… Bot added to {chat.type}: {chat.title} (ID: {chat.id})")
        
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙˆØª Ø¢ÙØ§Ù‚", callback_data=f"setup_afaq_{chat.id}")],
        [InlineKeyboardButton(text="Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª", callback_data=f"setup_alarms_{chat.id}")],
        [InlineKeyboardButton(text="Ø¥ØºÙ„Ø§Ù‚", callback_data="close_msg")]
    ])
    
    msg = (
        f"ğŸ‘‹ <b>Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒÙ…! Ø´ÙƒØ±Ø§Ù‹ Ù„Ø¥Ø¶Ø§ÙØªÙŠ ÙÙŠ {chat.title}</b>\n\n"
        f"Ø£Ù†Ø§ Ø¨ÙˆØª Ø¢ÙØ§Ù‚ Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠ ğŸ¤–\n"
        f"âœ… ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù†Ø´Ø± Ø§Ù„ØªØ°ÙƒÙŠØ±Ø§ØªØŒ Ø§Ù„Ø£Ø°ÙƒØ§Ø±ØŒ ÙˆØ§Ù„Ø¢ÙŠØ§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.\n"
        f"âœ… Ù„Ø¯ÙŠ Ù†Ø¸Ø§Ù… Ù…Ù†Ø¨Ù‡Ø§Øª Ø¥Ø³Ù„Ø§Ù…ÙŠ Ø°ÙƒÙŠ.\n\n"
        f"ğŸ‘‡ <b>ÙŠØ±Ø¬Ù‰ Ù…Ù† Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ø§Ù„Ø¶ØºØ· Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:</b>"
    )
    try:
        await event.bot.send_message(chat.id, msg, reply_markup=kb, parse_mode="HTML")
    except:
        pass

@router.callback_query(F.data.startswith("setup_"))
async def cb_setup_group(callback: types.CallbackQuery):
    try:
        action, type_, chat_id_str = callback.data.split('_')
        chat_id = int(chat_id_str)
        
        if type_ == 'afaq':
             await callback.message.edit_text("âš™ï¸ <b>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¢ÙØ§Ù‚:</b>\nØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†Ø´Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ:", reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                 [InlineKeyboardButton(text="ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù†Ø´Ø±", callback_data=f"toggle_afaq_{chat_id}_on"), InlineKeyboardButton(text="ØªØ¹Ø·ÙŠÙ„", callback_data=f"toggle_afaq_{chat_id}_off")],
                 [InlineKeyboardButton(text="Ø£ØºÙ„Ù‚", callback_data="close_msg")]
             ]))
        elif type_ == 'alarms':
             await callback.message.edit_text("â° <b>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª:</b>\nÙ„Ø¶Ø¨Ø· Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± /settings Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ùˆ Ø§Ù„Ù‚Ù†Ø§Ø©.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                  [InlineKeyboardButton(text="Ø£ØºÙ„Ù‚", callback_data="close_msg")]
             ]))
    except Exception as e:
        await callback.answer(f"Error: {e}")

@router.callback_query(F.data == "close_msg")
async def cb_close_msg(callback: types.CallbackQuery):
    await callback.message.delete()

@router.message(F.text == "Ø¥Ø¯Ø§Ø±Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª")
async def btn_alarms_content_manage(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    
    buttons = []
    r = []
    for k, v in ALARMS_CONTENT.items():
        r.append(types.KeyboardButton(text=v['title']))
        if len(r) == 2:
            buttons.append(r)
            r = []
    if r: buttons.append(r)
    buttons.append([types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª")])
    
    await message.answer("ğŸ“‚ <b>Ø¥Ø¯Ø§Ø±Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª</b>\nØ§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ù†Ø¨Ù‡ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¹Ù„ÙŠÙ‡:", reply_markup=types.ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True), parse_mode="HTML")
    await state.set_state(Form.data_add_category) 
    await state.update_data(mgmt_mode='alarms_content')

@router.message(Form.data_add_category)
async def process_alarm_content_type_select(message: types.Message, state: FSMContext):
    data = await state.get_data()
    if data.get('mgmt_mode') != 'alarms_content': return
    
    if message.text == "Ø±Ø¬ÙˆØ¹ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª":
        await state.clear()
        await message.answer("Ø±Ø¬ÙˆØ¹.", reply_markup=get_admin_alarms_kb())
        return

    selected_key = None
    for k, v in ALARMS_CONTENT.items():
        if v['title'] == message.text:
            selected_key = k
            break
    
    if not selected_key:
         await message.answer("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.")
         return
            
    await state.update_data(selected_alarm=selected_key)
    
    kb = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ù…Ø­ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯")],
        [types.KeyboardButton(text="ğŸ‘ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†Ø¨Ù‡Ø§Øª")]
    ], resize_keyboard=True)
    
    await message.answer(f"ğŸ”§ <b>Ø¥Ø¯Ø§Ø±Ø©: {message.text}</b>", reply_markup=kb, parse_mode="HTML")
    await state.set_state(Form.data_add_file)

@router.message(Form.data_add_file, F.text == "â• Ø¥Ø¶Ø§ÙØ© Ù…Ø­ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯")
async def btn_alarm_add_new(message: types.Message, state: FSMContext):
    await message.answer("ğŸ“¤ <b>Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¢Ù†:</b> (Ù†ØµØŒ ØµÙˆØ±Ø©ØŒ ØµÙˆØª...)", reply_markup=get_back_kb())
    await state.set_state(Form.custom_btn_add_text)

@router.message(Form.custom_btn_add_text)
async def process_alarm_new_content_receive(message: types.Message, state: FSMContext):
    data = await state.get_data()
    if data.get('mgmt_mode') != 'alarms_content': return
    
    if message.text == "Ø±Ø¬ÙˆØ¹":
         await state.clear()
         await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡", reply_markup=get_admin_alarms_kb())
         return
         
    c_type = 'text'
    text = message.text or message.caption or ""
    file_id = None
    
    if message.photo:
        c_type = 'image'
        file_id = message.photo[-1].file_id
    elif message.audio:
        c_type = 'audio'
        file_id = message.audio.file_id
    elif message.voice:
        c_type = 'voice'
        file_id = message.voice.file_id
    elif message.video:
        c_type = 'video'
        file_id = message.video.file_id
        
    await state.update_data(new_c_type=c_type, new_c_text=text, new_c_file=file_id)
    
    kb = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ù†Ø¹Ù…")],
        [types.KeyboardButton(text="Ù„Ø§")]
    ], resize_keyboard=True)
    
    await message.answer("ğŸ”˜ <b>Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø´ÙØ§ÙØ©ØŸ</b>", reply_markup=kb, parse_mode="HTML")
    await state.set_state(Form.custom_btn_add_confirm)

@router.message(Form.custom_btn_add_confirm)
async def process_alarm_buttons_ask(message: types.Message, state: FSMContext):
    if message.text == "Ù„Ø§":
        await save_alarm_content(message, state)
    elif message.text == "Ù†Ø¹Ù…":
        await message.answer("âœï¸ Ø£Ø±Ø³Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø±:\n<code>Ù†Øµ | Ø±Ø§Ø¨Ø·</code>\n(ÙƒÙ„ Ø²Ø± ÙÙŠ Ø³Ø·Ø±)", parse_mode="HTML", reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(Form.custom_btn_view)

@router.message(Form.custom_btn_view)
async def process_alarm_buttons_save(message: types.Message, state: FSMContext):
    await state.update_data(new_c_buttons=message.text)
    await save_alarm_content(message, state)

async def save_alarm_content(message, state):
    data = await state.get_data()
    alarm_type = data.get('selected_alarm')
    # Save to DB
    db = get_db()
    conn = db.get_connection()
    try:
        conn.execute("INSERT INTO alarm_content (alarm_type, content_type, text_content, file_id, reply_markup, added_by) VALUES (?, ?, ?, ?, ?, ?)",
                     (alarm_type, data.get('new_c_type'), data.get('new_c_text'), data.get('new_c_file'), data.get('new_c_buttons'), message.from_user.id))
        conn.commit()
        await message.answer("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸!", reply_markup=get_admin_alarms_kb())
    except Exception as e:
        await message.answer(f"âŒ Ø®Ø·Ø£: {e}")
    finally:
        conn.close()
        await state.clear()

@router.message(F.text.in_(["Ø¬Ø¯ÙˆÙ„Ø© Ø±Ø³Ø§Ù„Ø©", "ğŸ“… Ø¬Ø¯ÙˆÙ„Ø© Ø±Ø³Ø§Ù„Ø©"]))
async def btn_schedule_direct(message: types.Message, state: FSMContext):
    """Ø²Ø± Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…"""
    if not get_db().is_admin(message.from_user.id): return
    await btn_schedule(message, state)

# ØªÙ… Ø­Ø°Ù handler Ù…ÙƒØ±Ø± - Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø© ØªØ¹Ù…Ù„ Ù…Ù† handler Ø§Ù„Ø³Ø·Ø± 5241

@router.message(F.text.in_(["Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†", "ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†"]))
async def btn_admin_management(message: types.Message):
    """Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù")],
        [types.KeyboardButton(text="Ø­Ø°Ù Ù…Ø´Ø±Ù")],
        [types.KeyboardButton(text="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await message.answer(
        "<b>ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†</b>\n\nØ§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:",
        reply_markup=keyboard,
        parse_mode="HTML"
    )

@router.message(F.text == "Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù")
async def btn_add_admin(message: types.Message, state: FSMContext):
    """Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù Ø¬Ø¯ÙŠØ¯"""
    if not get_db().is_admin(message.from_user.id): return
    
    await message.answer(
        "<b>â• Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø±Ù</b>\n\nØ£Ø±Ø³Ù„ ID Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØªÙ‡ ÙƒÙ…Ø´Ø±Ù:",
        parse_mode="HTML",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(Form.add_admin_id)

@router.message(Form.add_admin_id)
async def process_add_admin(message: types.Message, state: FSMContext):
    if message.text == "Ø±Ø¬ÙˆØ¹":
        await state.clear()
        await cmd_start(message)
        return
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await btn_admin_management(message)
        return
    
    try:
        admin_id = int(message.text)
        db = get_db()
        
        if db.is_admin(admin_id):
            await message.answer("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù Ø¨Ø§Ù„ÙØ¹Ù„")
        else:
            db.add_admin(admin_id)
            await message.answer(
                f"âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø´Ø±Ù\n\nID: <code>{admin_id}</code>",
                parse_mode="HTML"
            )
        
        await state.clear()
        await btn_admin_management(message)
    except ValueError:
        await message.answer("âŒ ID ØºÙŠØ± ØµØ­ÙŠØ­. Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­.")

@router.message(F.text == "Ø­Ø°Ù Ù…Ø´Ø±Ù")
async def btn_remove_admin(message: types.Message):
    """Ø­Ø°Ù Ù…Ø´Ø±Ù"""
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    admins = db.get_admins()
    
    if not admins or len(admins) == 0:
        await message.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø±ÙÙˆÙ† Ù„Ø­Ø°ÙÙ‡Ù…")
        return
    
    keyboard = []
    for admin_id in admins:
        keyboard.append([InlineKeyboardButton(
            text=f"ğŸ—‘ï¸ Ø­Ø°Ù {admin_id}",
            callback_data=f"del_admin_{admin_id}"
        )])
    keyboard.append([InlineKeyboardButton(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")])
    
    await message.answer(
        "<b>Ø­Ø°Ù Ù…Ø´Ø±Ù</b>\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø±Ø§Ø¯ Ø­Ø°ÙÙ‡:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )

@router.callback_query(F.data.startswith("del_admin_"))
async def cb_delete_admin(callback: types.CallbackQuery):
    admin_id = int(callback.data.split("_")[2])
    
    db = get_db()
    if admin_id == callback.from_user.id:
        await callback.answer("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø°Ù Ù†ÙØ³Ùƒ!", show_alert=True)
        return
    
    db.remove_admin(admin_id)
    await callback.answer("âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø´Ø±Ù", show_alert=True)
    await callback.message.edit_text(
        f"âœ… <b>ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø´Ø±Ù</b>\n\nID: <code>{admin_id}</code>",
        parse_mode="HTML"
    )

@router.message(F.text == "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†")
async def btn_list_admins(message: types.Message):
    """Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†"""
    if not get_db().is_admin(message.from_user.id): return
    
    db = get_db()
    admins = db.get_admins()
    
    text = "<b>ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†</b>\n\n"
    
    if admins and len(admins) > 0:
        for i, admin_id in enumerate(admins, 1):
            text += f"{i}. <code>{admin_id}</code>\n"
        text += f"\n<b>Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</b> {len(admins)} Ù…Ø´Ø±Ù"
    else:
        text += "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø±ÙÙˆÙ†"
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text.in_(["Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", "ğŸ“£ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"]))
async def btn_channels_groups_direct(message: types.Message):
    """Ø²Ø± Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª - Ø¹Ø±Ø¶ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·"""
    if not get_db().is_admin(message.from_user.id): return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    
    db = get_db()
    conn = db.get_connection()
    
    # Ø¬Ù„Ø¨ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
    channels = conn.execute("""
        SELECT chat_id, title, username, invite_link 
        FROM chats 
        WHERE type='channel' AND status='active'
        ORDER BY title
    """).fetchall()
    
    # Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
    groups = conn.execute("""
        SELECT chat_id, title, username, invite_link 
        FROM chats 
        WHERE type IN ('group', 'supergroup') AND status='active'
        ORDER BY title
    """).fetchall()
    
    conn.close()
    
    text = f"""â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ“¢ <b>Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<b>ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
â€¢ Ù‚Ù†ÙˆØ§Øª Ù†Ø´Ø·Ø©: <code>{len(channels)}</code>
â€¢ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù†Ø´Ø·Ø©: <code>{len(groups)}</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    if channels:
        text += "<b>ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª:</b>\n\n"
        for row in channels:
            chat_id, title, username, invite_link = row
            name = title or "Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…"
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø§Ø¨Ø·
            if username:
                link = f"https://t.me/{username}"
                text += f"âœ… <a href='{link}'>{name}</a>\n"
            elif invite_link:
                text += f"âœ… <a href='{invite_link}'>{name}</a>\n"
            else:
                text += f"âœ… {name} (ID: <code>{chat_id}</code>)\n"
    else:
        text += "<b>ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª:</b> Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª\n\n"
    
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    
    if groups:
        text += "<b>ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:</b>\n\n"
        for row in groups:
            chat_id, title, username, invite_link = row
            name = title or "Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…"
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø§Ø¨Ø·
            if username:
                link = f"https://t.me/{username}"
                text += f"âœ… <a href='{link}'>{name}</a>\n"
            elif invite_link:
                text += f"âœ… <a href='{invite_link}'>{name}</a>\n"
            else:
                text += f"âœ… {name} (ID: <code>{chat_id}</code>)\n"
    else:
        text += "<b>ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:</b> Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª\n\n"
    
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += "ğŸ’¡ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø¨ÙˆØª Ø§Ù„Ù†Ø´Ø± ÙÙŠ Ø¬Ù…ÙŠØ¹ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª"
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML", disable_web_page_preview=True)

@router.message(F.text.in_(["Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ø±Ø¯Ø©", "ğŸ“¬ Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ø±Ø¯Ø©"]))
async def btn_inbox(message: types.Message):
    """Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„...")
    
    conn = get_db().get_connection()
    cursor = conn.execute("""
        SELECT id, from_user_id, from_username, content, sent_at, is_replied, content_type, file_id
        FROM contact_messages
        ORDER BY sent_at DESC
        LIMIT 50
    """)
    messages = cursor.fetchall()
    
    if not messages:
        keyboard = types.ReplyKeyboardMarkup(keyboard=[
            [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
        ], resize_keyboard=True)
        
        await wait_msg.delete()
        await message.answer(
            "ğŸ“¬ <b>Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©</b>\n\nâœ¨ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹",
            reply_markup=keyboard,
            parse_mode="HTML"
        )
        return
    
    # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø³Ø±ÙŠØ¹Ø©
    unread_count = sum(1 for m in messages if not m[5])
    total_count = len(messages)
    
    text = f"""ğŸ“¬ <b>Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©</b>

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:
â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_count}
â€¢ ØºÙŠØ± Ù…Ù‚Ø±ÙˆØ¡Ø©: {unread_count}
â€¢ Ù…Ù‚Ø±ÙˆØ¡Ø©: {total_count - unread_count}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""
    
    for msg in messages:
        msg_id, user_id, username, content, sent_at, is_replied, content_type, file_id = msg
        status = "âœ‰ï¸" if not is_replied else "âœ…"
        
        # ØªÙ†Ø³ÙŠÙ‚ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        user_display = username or f"User {user_id}"
        
        # ØªÙ‚ØµÙŠØ± Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø©
        if content:
            preview = content[:50] + "..." if len(content) > 50 else content
        else:
            preview = f"[{content_type}]"
        
        text += f"""{status} <b>#{msg_id}</b> - @{user_display}
ğŸ“ {preview}
ğŸ• {sent_at}

"""
    
    text += "\nğŸ’¡ <i>Ø§Ø³ØªØ®Ø¯Ù…:</i> /view_contact Ø±Ù‚Ù…_Ø§Ù„Ø±Ø³Ø§Ù„Ø© <i>Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙƒØ§Ù…Ù„Ø©</i>"
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# ==========================================
# Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø© ÙƒØ§Ù…Ù„Ø©
# ==========================================

@router.message(Command("view_contact"))
async def cmd_view_contact(message: types.Message):
    """Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© ØªÙˆØ§ØµÙ„ ÙƒØ§Ù…Ù„Ø©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    args = message.text.split()
    if len(args) < 2:
        await message.answer("âŒ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: /view_contact Ø±Ù‚Ù…_Ø§Ù„Ø±Ø³Ø§Ù„Ø©\n\nÙ…Ø«Ø§Ù„: /view_contact 5")
        return
    
    try:
        msg_id = int(args[1])
    except ValueError:
        await message.answer("âŒ Ø±Ù‚Ù… Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…Ø§Ù‹ ØµØ­ÙŠØ­Ø§Ù‹")
        return
    
    conn = get_db().get_connection()
    cursor = conn.execute("""
        SELECT id, from_user_id, from_username, content, sent_at, is_replied, content_type, file_id, message_id
        FROM contact_messages
        WHERE id = ?
    """, (msg_id,))
    msg = cursor.fetchone()
    
    if not msg:
        await message.answer(f"âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø¨Ø±Ù‚Ù… #{msg_id}")
        return
    
    msg_id, user_id, username, content, sent_at, is_replied, content_type, file_id, orig_msg_id = msg
    
    # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©
    if not is_replied:
        conn.execute("UPDATE contact_messages SET is_replied = 1 WHERE id = ?", (msg_id,))
        conn.commit()
    
    conn.close()
    
    user_display = username or f"User {user_id}"
    status = "âœ… ØªÙ… Ø§Ù„Ø±Ø¯" if is_replied else "â³ Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø±Ø¯"
    
    text = f"""ğŸ“¬ <b>Ø±Ø³Ø§Ù„Ø© #{msg_id}</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ‘¤ <b>Ø§Ù„Ù…Ø±Ø³Ù„:</b>
â€¢ Ø§Ù„Ù…Ø¹Ø±Ù: <code>{user_id}</code>
{f'â€¢ Ø§Ù„ÙŠÙˆØ²Ø±Ù†ÙŠÙ…: @{username}' if username else ''}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ <b>Ø§Ù„Ù…Ø­ØªÙˆÙ‰:</b> [{content_type}]

{content if content else '[Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Øµ]'}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ• <b>Ø§Ù„ØªØ§Ø±ÙŠØ®:</b> {sent_at}
ğŸ“Š <b>Ø§Ù„Ø­Ø§Ù„Ø©:</b> {status}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Ù„Ù„Ø±Ø¯: /reply_contact {user_id}
"""
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯
    if file_id and content_type != 'text':
        try:
            if content_type == 'photo':
                await message.answer_photo(file_id, caption=text, parse_mode="HTML")
            elif content_type == 'video':
                await message.answer_video(file_id, caption=text, parse_mode="HTML")
            elif content_type == 'document':
                await message.answer_document(file_id, caption=text, parse_mode="HTML")
            elif content_type == 'voice':
                await message.answer_voice(file_id, caption=text, parse_mode="HTML")
            else:
                await message.answer(text, parse_mode="HTML")
        except:
            await message.answer(text, parse_mode="HTML")
    else:
        await message.answer(text, parse_mode="HTML")

# ==========================================
# Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ
# ==========================================

@router.message(F.text.in_(["Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ", "ğŸ™ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ"]))
async def btn_audio_admin(message: types.Message):
    """Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©"""
    if not get_db().is_admin(message.from_user.id):
        await message.answer("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return
    
    wait_msg = await message.answer("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    
    # Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    db = get_db()
    conn = db.get_connection()
    
    total_reciters = conn.execute("SELECT COUNT(*) FROM reciters").fetchone()[0] or 0
    total_audio = conn.execute("SELECT COUNT(*) FROM quran_audio").fetchone()[0] or 0
    total_surahs = 114  # Ø¹Ø¯Ø¯ Ø³ÙˆØ± Ø§Ù„Ù‚Ø±Ø¢Ù†
    coverage = (total_audio / (total_reciters * total_surahs) * 100) if total_reciters > 0 else 0
    
    # Ø£Ø­Ø¯Ø« 3 Ù‚Ø±Ø§Ø¡
    recent_reciters = conn.execute("""
        SELECT name_ar FROM reciters 
        ORDER BY id DESC 
        LIMIT 3
    """).fetchall()
    
    conn.close()
    
    recent_list = "\n".join([f"  â€¢ {r[0]}" for r in recent_reciters]) if recent_reciters else "  Ù„Ø§ ÙŠÙˆØ¬Ø¯"
    
    text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸ™ï¸ <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ØµÙˆØªÙŠ</b> â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Ø§Ù„Ù‚Ø±Ø§Ø¡: <code>{total_reciters}</code>
â€¢ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØµÙˆØªÙŠØ©: <code>{total_audio}</code>
â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„ØªØºØ·ÙŠØ©: <code>{coverage:.1f}%</code>

ğŸ“Œ <b>Ø£Ø­Ø¯Ø« Ø§Ù„Ù‚Ø±Ø§Ø¡:</b>
{recent_list}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ <b>Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:</b>
"""
    
    keyboard = types.ReplyKeyboardMarkup(keyboard=[
        [types.KeyboardButton(text="â• Ø¥Ø¶Ø§ÙØ© Ù‚Ø§Ø±Ø¦"), types.KeyboardButton(text="ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡")],
        [types.KeyboardButton(text="ğŸ“¤ Ø±ÙØ¹ ØªÙ„Ø§ÙˆØ©"), types.KeyboardButton(text="ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø§Ø±Ø¦")],
        [types.KeyboardButton(text="ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©"), types.KeyboardButton(text="ğŸ—‘ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø°Ù")],
        [types.KeyboardButton(text="âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©"), types.KeyboardButton(text="ğŸŒ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† API")],
        [types.KeyboardButton(text="Ø±Ø¬ÙˆØ¹"), types.KeyboardButton(text="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")]
    ], resize_keyboard=True)
    
    await wait_msg.delete()
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")

# ==========================================
# ØªÙ… Ù†Ù‚Ù„ handlers Ø§Ù„Ø±Ø¬ÙˆØ¹ ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ø£Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙˆØ¯ (Ù‚Ø¨Ù„ user_tracker)
@router.message(F.text == "Ø¥Ø°Ø§Ø¹Ø© Ø¹Ø§Ù…Ø©")
async def btn_broadcast_general(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    await state.update_data(bc_service='all')
    await message.answer("ğŸ“¢ <b>Ø¥Ø°Ø§Ø¹Ø© Ø¹Ø§Ù…Ø© (Ù„ÙƒÙ„ Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ†)</b>\nØ§Ø®ØªØ± Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù:", parse_mode="HTML", reply_markup=get_bc_target_kb())
    await state.set_state(Form.bc_target)

@router.callback_query(F.data == "ac_add_menu")
async def cb_ac_add_menu(callback: types.CallbackQuery):
    kb = []
    # Alarm types
    types_map = {
        "salawat_ibrahim": "Ø§Ù„ØµÙ„Ø§Ø© Ø§Ù„Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…ÙŠØ©",
        "salawat_text": "Ù†ØµÙˆØµ Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ",
        "dhikr_tasbih": "Ø§Ù„ØªØ³Ø¨ÙŠØ­",
        "salawat_image": "ØµÙˆØ± Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ",
        "salawat_audio": "ØµÙˆØªÙŠØ§Øª Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ"
    }
    for k, v in types_map.items():
        kb.append([InlineKeyboardButton(text=v, callback_data=f"ac_add_type_{k}")])
    
    await callback.message.edit_text("â• <b>Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ù†Ø¨Ù‡ Ù„Ù„Ø¥Ø¶Ø§ÙØ© Ø¥Ù„ÙŠÙ‡:</b>", parse_mode="HTML", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@router.callback_query(F.data.startswith("ac_add_type_"))
async def cb_ac_add_type(callback: types.CallbackQuery, state: FSMContext):
    atype = callback.data.replace("ac_add_type_", "")
    await state.update_data(ac_type=atype)
    
    if "image" in atype:
        await callback.message.answer("ğŸ“¸ Ø£Ø±Ø³Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¢Ù†:")
        await state.set_state(Form.alarm_content_add_file)
    elif "audio" in atype:
        await callback.message.answer("ğŸ”Š Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ø¢Ù†:")
        await state.set_state(Form.alarm_content_add_file)
    else:
        await callback.message.answer("ğŸ“ Ø£Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø¬Ø¯ÙŠØ¯:")
        await state.set_state(Form.alarm_content_add_text)
    
    await callback.message.delete()

@router.message(Form.alarm_content_add_text)
async def state_ac_add_text(message: types.Message, state: FSMContext):
    data = await state.get_data()
    atype = data.get('ac_type')
    text = message.text
    
    db = get_db()
    # Insert customized content
    conn = db.get_connection()
    conn.execute("INSERT INTO alarm_content (alarm_type, content_type, text_content, added_by) VALUES (?, ?, ?, ?)", 
                 (atype, 'text', text, message.from_user.id))
    conn.commit()
    conn.close()
    
    await message.answer("âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†Øµ Ø¨Ù†Ø¬Ø§Ø­.")
    await state.clear()

@router.message(Form.alarm_content_add_file)
async def state_ac_add_file(message: types.Message, state: FSMContext):
    data = await state.get_data()
    atype = data.get('ac_type')
    
    file_id = None
    ctype = 'text'
    
    if message.photo:
        file_id = message.photo[-1].file_id
        ctype = 'image'
    elif message.audio:
        file_id = message.audio.file_id
        ctype = 'audio'
    elif message.voice:
        file_id = message.voice.file_id
        ctype = 'voice'
        
    if not file_id:
        await message.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        return

    caption = message.caption or ""
    
    db = get_db()
    conn = db.get_connection()
    conn.execute("INSERT INTO alarm_content (alarm_type, content_type, file_id, text_content, added_by) VALUES (?, ?, ?, ?, ?)", 
                 (atype, ctype, file_id, caption, message.from_user.id))
    conn.commit()
    conn.close()
    
    await message.answer("âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­.")
    await state.clear()

@router.callback_query(F.data == "ac_view_menu")
async def cb_ac_view_menu(callback: types.CallbackQuery):
    # Just show types
    kb = []
    types_map = {
        "salawat_ibrahim": "Ø§Ù„ØµÙ„Ø§Ø© Ø§Ù„Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…ÙŠØ©",
        "salawat_text": "Ù†ØµÙˆØµ Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ",
        "salawat_image": "ØµÙˆØ± Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ",
        "salawat_audio": "ØµÙˆØªÙŠØ§Øª Ø§Ù„ØµÙ„Ø§Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ"
    }
    for k, v in types_map.items():
        kb.append([InlineKeyboardButton(text=v, callback_data=f"ac_view_{k}")])
        
    await callback.message.edit_text("ğŸ“‹ Ø§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ Ù„Ø¹Ø±Ø¶ Ù…Ø­ØªÙˆØ§Ù‡:", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@router.callback_query(F.data.startswith("ac_view_"))
async def cb_ac_view_type(callback: types.CallbackQuery):
    atype = callback.data.replace("ac_view_", "")
    db = get_db()
    items = db.get_alarm_content(atype)
    
    if not items:
        await callback.answer("âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø­ØªÙˆÙ‰ Ù…Ø¶Ø§Ù Ù„Ù‡Ø°Ø§ Ø§Ù„ØªØµÙ†ÙŠÙ", show_alert=True)
        return
        
    text = f"ğŸ“‹ <b>Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ ({len(items)}):</b>\n\n"
    for item in items[:10]: # Show first 10 text items logic needs refinement if mixed types
        if item['type'] == 'text':
            text += f"- {item['text'][:50]}...\n"
        else:
            text += f"- [Ù…Ù„Ù] {item['type']}\n"
            
    if len(items) > 10: text += "\n... ÙˆÙ‡Ù†Ø§Ùƒ Ø§Ù„Ù…Ø²ÙŠØ¯."
    
    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="Ø±Ø¬ÙˆØ¹", callback_data="ac_view_menu")]]))

@router.callback_query(F.data == "ac_del_menu")
async def cb_ac_del_menu(callback: types.CallbackQuery):
     # Simple Delete Latest implementation for now or clear all custom
    kb = [
        [InlineKeyboardButton(text="ğŸ—‘ï¸ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø¶Ø§Ù ÙŠØ¯ÙˆÙŠØ§Ù‹", callback_data="ac_del_all_confirm")],
        [InlineKeyboardButton(text="Ø±Ø¬ÙˆØ¹", callback_data="ac_view_menu")]
    ]
    await callback.message.edit_text("ğŸ—‘ï¸ <b>Ø­Ø°Ù Ø§Ù„Ù…Ø­ØªÙˆÙ‰</b>\nÙ„Ù„Ø£Ø³Ù Ø§Ù„Ø­Ø°Ù Ø§Ù„ÙØ±Ø¯ÙŠ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø°Ù ÙƒÙ„ Ù…Ø§ Ø£Ø¶ÙØªÙ‡ ÙŠØ¯ÙˆÙŠØ§Ù‹:", parse_mode="HTML", reply_markup=InlineKeyboardMarkup(inline_keyboard=kb))

@router.callback_query(F.data == "ac_del_all_confirm")
async def cb_ac_del_all(callback: types.CallbackQuery):
    db = get_db()
    conn = db.get_connection()
    conn.execute("DELETE FROM alarm_content WHERE added_by != 0") # Only delete custom
    conn.commit()
    conn.close()
    await callback.message.edit_text("âœ… ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª Ø§Ù„ÙŠØ¯ÙˆÙŠØ©.")

@router.message(F.text == "Ø­Ø°Ù Ø¢Ø®Ø± Ø¥Ø°Ø§Ø¹Ø©")
async def btn_delete_last_broadcast(message: types.Message):
    if not get_db().is_admin(message.from_user.id): return
    
    await message.answer("â³ Ø¬Ø§Ø±ÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© Ø­Ø°Ù Ø¢Ø®Ø± Ø¥Ø°Ø§Ø¹Ø©...", parse_mode="HTML")
    
    db = get_db()
    conn = db.get_connection()
    last = conn.execute("SELECT id, broadcast_name, sent_at FROM broadcast_history ORDER BY id DESC LIMIT 1").fetchone()
    conn.close()
    
    json_ids = db.get_config('last_broadcast_channel_ids')
    
    if not last and not json_ids:
        await message.answer("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø°Ø§Ø¹Ø§Øª Ø³Ø§Ø¨Ù‚Ø© Ù…Ø³Ø¬Ù„Ø© Ø£Ùˆ Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø°Ù Ù…Ø­ÙÙˆØ¸Ø©.")
        return
        
    bname = last[1] if last else "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
    
    deleted_count = 0
    failed_count = 0
    total_ids = 0
    
    if json_ids:
        import json
        try:
            ids_list = json.loads(json_ids) # List of [chat_id, message_id]
            total_ids = len(ids_list)
            
            # Deleting in batches to avoid blocking
            batch_size = 50
            for i in range(0, len(ids_list), batch_size):
                batch = ids_list[i:i+batch_size]
                tasks = []
                for cid, mid in batch:
                    tasks.append(safe_delete_message(message.bot, cid, mid))
                
                results = await asyncio.gather(*tasks)
                deleted_count += results.count(True)
                failed_count += results.count(False)
                await asyncio.sleep(0.5)
                
        except Exception as e:
            logger.error(f"Delete broadcast error: {e}")
            await message.answer(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù: {e}")
            
    # Clear config after attempt
    db.set_config('last_broadcast_channel_ids', '')
            
    msg_text = f"âœ… <b>ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø¢Ø®Ø± Ø¥Ø°Ø§Ø¹Ø© ({bname})</b>\n\n"
    msg_text += f"ğŸ“Š Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙÙˆÙ† Ø§Ù„Ù…Ø³Ø¬Ù„ÙˆÙ†: {total_ids}\n"
    msg_text += f"ğŸ—‘ï¸ ØªÙ… Ø§Ù„Ø­Ø°Ù: {deleted_count}\n"
    msg_text += f"âŒ ÙØ´Ù„ Ø§Ù„Ø­Ø°Ù: {failed_count}\n\n"
    msg_text += "â„¹ï¸ (ÙØ´Ù„ Ø§Ù„Ø­Ø°Ù Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø¨Ø³Ø¨Ø¨ Ù…Ø±ÙˆØ± ÙˆÙ‚Øª Ø·ÙˆÙŠÙ„ØŒ Ø£Ùˆ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹ØŒ Ø£Ùˆ Ù†Ù‚Øµ ØµÙ„Ø§Ø­ÙŠØ§Øª)"
        
    await message.answer(msg_text, parse_mode="HTML")

async def safe_delete_message(bot, chat_id, message_id):
    try:
        await bot.delete_message(chat_id, message_id)
        return True
    except:
        return False

@router.message(F.text == "Ø£Ø²Ø±Ø§Ø± Ù‚Ø§Ø¦Ù…Ø© Ø¢ÙØ§Ù‚")
async def btn_afaq_buttons_settings(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    await show_button_position_editor(message, state, 'afaq')

@router.message(F.text == "Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©")
async def btn_main_buttons_settings(message: types.Message, state: FSMContext):
    if not get_db().is_admin(message.from_user.id): return
    await show_button_position_editor(message, state, 'main')

async def show_button_position_editor(message, state, category: str):
    """Ø¹Ø±Ø¶ Ù…Ø­Ø±Ø± ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ù†Ø¸Ø§Ù… Ø§Ù„ØµÙÙˆÙ ÙˆØ§Ù„Ø£Ø¹Ù…Ø¯Ø©"""
    
    db = get_db()
    buttons = db.get_system_buttons(for_admin=True, category=category)
    
    if not buttons:
        await message.answer("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©")
        return
    
    # ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø­Ø³Ø¨ Ø§Ù„ØªØ±ØªÙŠØ¨
    buttons_sorted = sorted(buttons, key=lambda x: x[3])  # btn_order
    
    text = f"""
  âš™ï¸ <b>ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø±</b>  


ğŸ“‚ <b>Ø§Ù„ÙØ¦Ø©:</b> {"Ù‚Ø§Ø¦Ù…Ø© Ø¢ÙØ§Ù‚" if category == "afaq" else "Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"}

<b>ğŸ”¢ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©:</b>

"""
    
    keyboard_buttons = []
    for idx, btn in enumerate(buttons_sorted, 1):
        btn_id, btn_key, btn_name, btn_order, is_visible, icon = btn
        status = "âœ…" if is_visible else "âŒ"
        emoji = icon or "ğŸ“Œ"
        text += f"{idx}. {status} {emoji} {btn_name} <code>(ØªØ±ØªÙŠØ¨: {btn_order})</code>\n"
        
        # Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ù„ÙƒÙ„ Ø²Ø±
        keyboard_buttons.append([
            InlineKeyboardButton(text=f"{emoji} {btn_name}", callback_data=f"btn_edit_{btn_id}"),
            InlineKeyboardButton(text="â¬†ï¸", callback_data=f"btn_up_{btn_id}"),
            InlineKeyboardButton(text="â¬‡ï¸", callback_data=f"btn_down_{btn_id}"),
            InlineKeyboardButton(text="ğŸ‘" if is_visible else "ğŸš«", callback_data=f"btn_toggle_{btn_id}")
        ])
    
    text += """\n

ğŸ’¡ <b>Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:</b>
â€¢ â¬†ï¸â¬‡ï¸ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø²Ø± Ù„Ù„Ø£Ø¹Ù„Ù‰/Ø§Ù„Ø£Ø³ÙÙ„
â€¢ ğŸ‘/ğŸš« Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø²Ø±
â€¢ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø²Ø± Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªÙØµÙŠÙ„ÙŠ

ğŸ¯ <b>Ù†Ø¸Ø§Ù… Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ø°ÙƒÙŠ:</b>
ÙŠÙ…ÙƒÙ†Ùƒ ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙŠ ØµÙÙˆÙ Ù…Ù† 1-3 Ø£Ø²Ø±Ø§Ø±"""
    
    keyboard_buttons.append([
        InlineKeyboardButton(text="ğŸ’¾ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª", callback_data=f"btn_save_{category}"),
        InlineKeyboardButton(text="Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†", callback_data=f"btn_reset_{category}")
    ])
    keyboard_buttons.append([
        InlineKeyboardButton(text="Ø¥ØºÙ„Ø§Ù‚", callback_data="close_msg")
    ])
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)
    await message.answer(text, reply_markup=keyboard, parse_mode="HTML")
    await state.update_data(btn_category=category)

@router.callback_query(F.data.startswith("btn_up_"))
async def cb_button_move_up(callback: types.CallbackQuery):
    """ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø²Ø± Ù„Ù„Ø£Ø¹Ù„Ù‰"""
    btn_id = int(callback.data.split("_")[2])
    db = get_db()
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø²Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
    current = db.get_button_by_id(btn_id)
    if not current:
        await callback.answer("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø²Ø±")
        return
    
    current_order = current[3]  # btn_order
    
    # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø²Ø± Ø§Ù„Ø°ÙŠ Ù‚Ø¨Ù„Ù‡
    conn = db.get_connection()
    previous = conn.execute(
        "SELECT id, btn_order FROM system_buttons WHERE btn_order < ? ORDER BY btn_order DESC LIMIT 1",
        (current_order,)
    ).fetchone()
    
    if previous:
        # ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØªØ±ØªÙŠØ¨
        prev_id, prev_order = previous
        conn.execute("UPDATE system_buttons SET btn_order = ? WHERE id = ?", (prev_order, btn_id))
        conn.execute("UPDATE system_buttons SET btn_order = ? WHERE id = ?", (current_order, prev_id))
        conn.commit()
        await callback.answer("âœ… ØªÙ… ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø²Ø± Ù„Ù„Ø£Ø¹Ù„Ù‰")
    else:
        await callback.answer("âš ï¸ Ø§Ù„Ø²Ø± ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©", show_alert=True)
    
    conn.close()
    
    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø±Ø¶
    data = await callback.message.bot.get_state_data(callback.from_user.id, callback.message.chat.id)
    category = data.get('btn_category', 'main') if data else 'main'
    await callback.message.delete()
    await show_button_position_editor(callback.message, None, category)

@router.callback_query(F.data.startswith("btn_down_"))
async def cb_button_move_down(callback: types.CallbackQuery):
    """ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø²Ø± Ù„Ù„Ø£Ø³ÙÙ„"""
    btn_id = int(callback.data.split("_")[2])
    db = get_db()
    
    current = db.get_button_by_id(btn_id)
    if not current:
        await callback.answer("âŒ Ø®Ø·Ø£")
        return
    
    current_order = current[3]
    
    conn = db.get_connection()
    next_btn = conn.execute(
        "SELECT id, btn_order FROM system_buttons WHERE btn_order > ? ORDER BY btn_order ASC LIMIT 1",
        (current_order,)
    ).fetchone()
    
    if next_btn:
        next_id, next_order = next_btn
        conn.execute("UPDATE system_buttons SET btn_order = ? WHERE id = ?", (next_order, btn_id))
        conn.execute("UPDATE system_buttons SET btn_order = ? WHERE id = ?", (current_order, next_id))
        conn.commit()
        await callback.answer("âœ… ØªÙ… ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø²Ø± Ù„Ù„Ø£Ø³ÙÙ„")
    else:
        await callback.answer("âš ï¸ Ø§Ù„Ø²Ø± ÙÙŠ Ø£Ø³ÙÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©", show_alert=True)
    
    conn.close()

@router.callback_query(F.data.startswith("btn_toggle_"))
async def cb_button_toggle_visibility(callback: types.CallbackQuery):
    """ØªØ¨Ø¯ÙŠÙ„ Ø­Ø§Ù„Ø© Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø²Ø±"""
    btn_id = int(callback.data.split("_")[2])
    db = get_db()
    
    current = db.get_button_by_id(btn_id)
    if not current:
        await callback.answer("âŒ Ø®Ø·Ø£")
        return
    
    is_visible = current[4]  # current visibility
    new_visibility = not is_visible
    
    db.update_button(btn_id, is_visible=new_visibility)
    
    status_text = "Ù…Ø±Ø¦ÙŠ" if new_visibility else "Ù…Ø®ÙÙŠ"
    await callback.answer(f"âœ… Ø§Ù„Ø²Ø± Ø§Ù„Ø¢Ù† {status_text}")

@router.callback_query(F.data.startswith("btn_edit_"))
async def cb_button_edit_detailed(callback: types.CallbackQuery, state: FSMContext):
    """ØªØ¹Ø¯ÙŠÙ„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø²Ø± (Ø§Ù„Ø§Ø³Ù…ØŒ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©ØŒ Ø§Ù„ØªØ±ØªÙŠØ¨)"""
    btn_id = int(callback.data.split("_")[2])
    db = get_db()
    
    btn = db.get_button_by_id(btn_id)
    if not btn:
        await callback.answer("âŒ Ø®Ø·Ø£")
        return
    
    btn_id, btn_key, btn_name, btn_order, is_visible, icon = btn
    
    text = f"""âš™ï¸ <b>ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø²Ø±</b>

ğŸ·ï¸ <b>Ø§Ù„Ø§Ø³Ù…:</b> {btn_name}
ğŸ“Œ <b>Ø§Ù„Ù…ÙØªØ§Ø­:</b> <code>{btn_key}</code>
{icon} <b>Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©:</b> {icon or "Ø¨Ø¯ÙˆÙ†"}
ğŸ”¢ <b>Ø§Ù„ØªØ±ØªÙŠØ¨:</b> {btn_order}
ğŸ‘ <b>Ø§Ù„Ø­Ø§Ù„Ø©:</b> {"Ù…Ø±Ø¦ÙŠ" if is_visible else "Ù…Ø®ÙÙŠ"}



Ø§Ø®ØªØ± Ù…Ø§ ØªØ±ÙŠØ¯ ØªØ¹Ø¯ÙŠÙ„Ù‡:"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="âœï¸ ØªØºÙŠÙŠØ± Ø§Ù„Ø§Ø³Ù…", callback_data=f"btn_change_name_{btn_id}")],
        [InlineKeyboardButton(text="ğŸ¨ ØªØºÙŠÙŠØ± Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©", callback_data=f"btn_change_icon_{btn_id}")],
        [InlineKeyboardButton(text="ğŸ”¢ ØªØºÙŠÙŠØ± Ø§Ù„ØªØ±ØªÙŠØ¨", callback_data=f"btn_change_order_{btn_id}")],
        [InlineKeyboardButton(text="Ø±Ø¬ÙˆØ¹", callback_data="btn_back_to_list")]
    ])
    
    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="HTML")
    await state.update_data(editing_btn_id=btn_id)

@router.callback_query(F.data.startswith("btn_change_name_"))
async def cb_button_change_name(callback: types.CallbackQuery, state: FSMContext):
    btn_id = int(callback.data.split("_")[3])
    await callback.message.answer("âœï¸ Ø£Ø±Ø³Ù„ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø²Ø±:", reply_markup=get_cancel_kb())
    await state.update_data(editing_btn_id=btn_id, edit_type='name')
    await state.set_state(Form.btn_edit_value)

@router.callback_query(F.data.startswith("btn_change_icon_"))
async def cb_button_change_icon(callback: types.CallbackQuery, state: FSMContext):
    btn_id = int(callback.data.split("_")[3])
    await callback.message.answer("ğŸ¨ Ø£Ø±Ø³Ù„ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Ø¥ÙŠÙ…ÙˆØ¬ÙŠ):", reply_markup=get_cancel_kb())
    await state.update_data(editing_btn_id=btn_id, edit_type='icon')
    await state.set_state(Form.btn_edit_value)

@router.callback_query(F.data.startswith("btn_change_order_"))
async def cb_button_change_order(callback: types.CallbackQuery, state: FSMContext):
    btn_id = int(callback.data.split("_")[3])
    await callback.message.answer("ğŸ”¢ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯:", reply_markup=get_cancel_kb())
    await state.update_data(editing_btn_id=btn_id, edit_type='order')
    await state.set_state(Form.btn_edit_value)

@router.callback_query(F.data == "btn_back_to_list")
async def cb_button_back_to_list(callback: types.CallbackQuery, state: FSMContext):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø±"""
    await callback.message.delete()
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙØ¦Ø© Ù…Ù† state
    data = await state.get_data()
    category = data.get('btn_category', 'main')
    
    # Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    message_obj = callback.message
    message_obj.from_user = callback.from_user
    await show_button_position_editor(message_obj, state, category)

@router.message(Form.btn_edit_value)
async def process_button_edit_value(message: types.Message, state: FSMContext):
    if message.text == "Ø¥Ù„ØºØ§Ø¡":
        await state.clear()
        await message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡", reply_markup=get_admin_kb())
        return
    
    data = await state.get_data()
    btn_id = data.get('editing_btn_id')
    edit_type = data.get('edit_type')
    
    db = get_db()
    
    if edit_type == 'name':
        db.update_button(btn_id, new_name=message.text)
        await message.answer(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ø³Ù… Ø§Ù„Ø²Ø± Ø¥Ù„Ù‰: {message.text}")
    elif edit_type == 'icon':
        db.update_button(btn_id, new_icon=message.text)
        await message.answer(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø¥Ù„Ù‰: {message.text}")
    elif edit_type == 'order':
        try:
            order = int(message.text)
            db.update_button(btn_id, new_order=order)
            await message.answer(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¥Ù„Ù‰: {order}")
        except ValueError:
            await message.answer("âŒ ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­")
            return
    
    await state.clear()
    await message.answer("ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­!", reply_markup=get_admin_kb())

# Wird Admin Handlers
# Wird Admin Handlers

async def main():

    global bot, main_loop

    
    if not API_TOKEN:
        print("Ø®Ø·Ø£: Ø¶Ø¹ Ø§Ù„ØªÙˆÙƒÙŠÙ†!")
        return
    
    # Ø¥Ù†Ø´Ø§Ø¡ instance Ø¬Ø¯ÙŠØ¯ ÙˆØªØ¹ÙŠÙŠÙ†Ù‡ Ù„Ù„Ù€global
    global DB_CONN
    DB_CONN = Database(DB_NAME)
    db = DB_CONN
    
    # --- Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯Ø§Øª Ø§Ù„Ø°ÙƒÙŠØ© (Smart Extensions Integration) ---
    # ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯Ø§Øª Ù…Ø¤Ù‚ØªØ§Ù‹ - Ø§Ù„Ù…Ù„ÙØ§Øª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©
    # try:
    #     from bot_extensions import get_extensions_router
    #     ext_router = get_extensions_router(db)
    #     router.include_router(ext_router)
    #     
    #     # V3 Smart Engine Integration
    #     from smart_engine import get_smart_router
    #     smart_router = get_smart_router(db)
    #     router.include_router(smart_router)
    #     
    #     print("âœ… Smart Extensions & V3 Engine Loaded!")
    # except ImportError as e:
    #     print(f"âš ï¸ Failed to load extensions: {e}")
    # except Exception as e:
    #     print(f"âš ï¸ Error linking extensions: {e}")
    # -------------------------------------------------------------

    # Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
    print("ğŸ›¡ï¸ Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    try:
        success, path, msg = data_protection.create_backup("auto", compress=True)
        if success:
            print(f"   âœ… Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: {msg}")
        else:
            print(f"   âš ï¸ ØªØ­Ø°ÙŠØ± Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ: {msg}")
    except Exception as e:
        print(f"   âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ: {e}")
    
    # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
    print("ğŸ§¹ Ø¬Ø§Ø±ÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
    expired_tasks = db.cleanup_expired_tasks()
    duplicate_azkar = db.remove_duplicate_azkar()
    print(f"   âœ… ØªÙ… Ø­Ø°Ù {expired_tasks} Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ù†ØªÙ‡ÙŠØ©/Ù…Ù„ØºØ§Ø©")
    print(f"   âœ… ØªÙ… Ø­Ø°Ù {duplicate_azkar} Ø£Ø°ÙƒØ§Ø± Ù…ÙƒØ±Ø±Ø©")
    
    # ğŸ”¥ Ø§Ù„Ø­Ù„ Ø§Ù„Ø¬Ø°Ø±ÙŠ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ - Ø§Ø³ØªØ®Ø¯Ø§Ù… get_live_stats() ÙÙ‚Ø·
    
    # ğŸš¨ ØªØ´Ø®ÙŠØµ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© - Ø·Ø¨Ø§Ø¹Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
    import os
    db_full_path = os.path.abspath(DB_NAME)
    db_size_kb = os.path.getsize(DB_NAME) / 1024 if os.path.exists(DB_NAME) else 0
    print(f"\nğŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:")
    print(f"   ğŸ“‚ Ø§Ù„Ù…Ø³Ø§Ø±: {db_full_path}")
    print(f"   ğŸ’¾ Ø§Ù„Ø­Ø¬Ù…: {db_size_kb:.2f} KB")
    print(f"   ğŸ“ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {os.getcwd()}")
    
    live_stats = db.get_live_stats()
    
    # âœ… Ø­Ù…Ø§ÙŠØ© Ù…Ù† None
    if not live_stats:
        logger.error("âŒ ÙØ´Ù„ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª! Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©...")
        import time
        time.sleep(2)
        live_stats = db.get_live_stats()
    
    if not live_stats:
        logger.error("âŒ ÙØ´Ù„ ØªØ§Ù… ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª! Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ©")
        live_stats = {
            'users': {'active': 0, 'total': 0, 'inactive': 0},
            'groups': {'active': 0, 'total': 0},
            'channels': {'active': 0, 'total': 0},
            'broadcast': {'all_targets': 0}
        }
    
    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ø¨Ø§Ø´Ø±Ø©
    total_users = live_stats['users']['total']
    active_users = live_stats['users']['active']
    total_channels = live_stats['channels']['total']
    active_channels = live_stats['channels']['active']
    total_groups = live_stats['groups']['total']
    active_groups = live_stats['groups']['active']
    
    print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸŒŸ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠ - Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ğŸŒŸ            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©:
   
   ğŸ‘¥ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:
      â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_users}
      â€¢ Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: {active_users}
      
   ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª:
      â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_channels}
      â€¢ Ø§Ù„Ù†Ø´Ø·Ø©: {active_channels}
      
   ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:
      â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total_groups}
      â€¢ Ø§Ù„Ù†Ø´Ø·Ø©: {active_groups}

âœ… Ù†Ø¸Ø§Ù… Ø¹Ø¯Ù… Ø§Ù„ØªÙƒØ±Ø§Ø± Ø§Ù„ØµØ§Ø±Ù… Ù…ÙØ¹Ù„
âœ… Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ Ù…ÙØ¹Ù„
âœ… Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©: {DEFAULT_TIMEZONE}
âœ… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙØ¹Ù„Ø©
    """)

    storage = MemoryStorage()
    bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
    main_loop = asyncio.get_running_loop()
    dp = Dispatcher(storage=storage)
    
    # Ø¥Ø¶Ø§ÙØ© middleware Ù„Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙ‚Ø·
    if REQUIRED_CHANNEL:
        dp.message.middleware(SubscriptionMiddleware(REQUIRED_CHANNEL))
        dp.callback_query.middleware(SubscriptionMiddleware(REQUIRED_CHANNEL))
    
    dp.include_router(router)
    
    # Ù…Ù‡Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ (ÙƒÙ„ 24 Ø³Ø§Ø¹Ø©)
    async def auto_backup_task():
        """Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 24 Ø³Ø§Ø¹Ø©"""
        while True:
            try:
                await asyncio.sleep(86400)  # 24 Ø³Ø§Ø¹Ø©
                logger.info("ğŸ›¡ï¸ Ø¨Ø¯Ø¡ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ...")
                success, path, msg = data_protection.create_backup("daily", compress=True)
                if success:
                    logger.info(f"âœ… Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ: {msg}")
                else:
                    logger.error(f"âŒ ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ: {msg}")
            except Exception as e:
                logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: {e}")
    
    # Ù…Ù‡Ù…Ø© Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø§Ù„Ø¯ÙˆØ±ÙŠØ© (ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚)
    async def periodic_save_task():
        """Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø­Ø§Ù„Ø© ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚"""
        while True:
            try:
                await asyncio.sleep(300)  # 5 Ø¯Ù‚Ø§Ø¦Ù‚
                auto_save.save_state()
                
                # Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø®ÙÙŠÙØ© ÙƒÙ„ Ø³Ø§Ø¹Ø©
                if (datetime.now().minute == 0):
                    logger.info("ğŸ’¾ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø³Ø§Ø¹ÙŠØ©...")
                    auto_save.create_emergency_backup()
            except Exception as e:
                logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: {e}")
    
    # Ø¨Ø¯Ø¡ Ù…Ù‡Ø§Ù… Ø§Ù„Ø®Ù„ÙÙŠØ©
    asyncio.create_task(scheduler_worker())  # Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ù‡Ø§Ù…
    asyncio.create_task(auto_backup_task())  # Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 24 Ø³Ø§Ø¹Ø©
    asyncio.create_task(periodic_save_task())  # Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
    
    # Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ© - ØªØ¹Ù…Ù„ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø© (Async only)
    # sc = BackgroundScheduler()
    # sc.add_job(check_scheduled_tasks, 'interval', minutes=1, id='advanced_scheduler')
    # sc.start()
    
    print("âœ… ØªÙ… Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­ Ù…Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…!")
    print("ğŸ›¡ï¸ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: ÙƒÙ„ 24 Ø³Ø§Ø¹Ø©")
    print("ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚")
    print("ğŸ”’ Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: Ù…ÙØ¹Ù„Ø© (ÙŠØ­ÙØ¸ Ø¹Ù†Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚)")
    
    try:
        await dp.start_polling(bot)
    except KeyboardInterrupt:
        logger.info("\nâš ï¸ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ctrl+C)")
        auto_save.graceful_shutdown()
    except Exception as e:
        logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙˆØª: {e}")
        auto_save.graceful_shutdown()
        raise

if __name__ == "__main__":
    if sys.platform == 'win32':
        try:
            sys.stdout.reconfigure(encoding='utf-8')
            sys.stderr.reconfigure(encoding='utf-8')
        except AttributeError:
            pass

    sys.path = [p for p in sys.path if not any(x in p.lower() for x in ['asyncio.py', 'subprocess.py', 'events.py'])]
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
